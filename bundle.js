/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {__webpack_require__(25);
	var SourceMap = __webpack_require__(3);
	var UglifyJS = __webpack_require__(17);
	var generateHtml = __webpack_require__(16);
	
	var exampleKinds = ["coffee", "simple-coffee", "typescript", "babel", "sass"];
	var SOURCE_MAPPING_URL_REG_EXP = /\/\/[@#]\s*sourceMappingURL\s*=\s*data:[^\n]*?base64,([^\n]*)/;
	var SOURCE_MAPPING_URL_REG_EXP2 = /\/\*\s*[@#]\s*sourceMappingURL\s*=\s*data:[^\n]*?base64,([^\n]*)\s*\*\//;
	$(function () {
		__webpack_require__(51);
		__webpack_require__(47);
		$("body").html(__webpack_require__(26)({ kinds: exampleKinds }));
	
		var oldHash = "";
		$(".close").click(function () {
			window.location.hash = oldHash;
		});
	
		$(window).hashchange(function () {
			var exampleKind = window.location.hash.replace(/^#/, "");
	
			if (exampleKind !== "custom-choose")
				$(".custom-modal").modal("hide");
	
			if (exampleKind.indexOf("base64") === 0) {
				var input = exampleKind.split(",").slice(1).map(function (str) {
					return decodeURIComponent(escape(atob(str)));
				});
				var gen = input.shift();
				var map = JSON.parse(input.shift());
				loadExample(input, gen, map);
				oldHash = exampleKind;
				return;
			}
			exampleKind = exampleKind.toLowerCase();
			if (exampleKind === "custom") return;
			if (exampleKind === "custom-choose") {
	
				$(".custom-modal .modal-body").html(__webpack_require__(28)());
				$(".custom-modal").modal({
					show: true
				});
				$(".custom-error").addClass("hide");
	
				var generatedSource, sourceMap, sourcesContent = [];
				$(".custom-continue").click(continueWithStep2);
				$(".file").change(continueWithStep2);
				function continueWithStep2() {
					$(".custom-continue").attr("disabled", true);
					loadFile($(".file"), function (err, _generatedSource) {
						$(".custom-error").addClass("hide");
						if (err) {
							$(".custom-error").removeClass("hide").text(err.message);
							return $(".custom-continue").attr("disabled", false);
						}
						if (!_generatedSource)
							return $(".custom-continue").attr("disabled", false);
						generatedSource = _generatedSource;
						step2();
					});
					return false;
				}
				function step2() {
					if ((SOURCE_MAPPING_URL_REG_EXP.test(generatedSource) || SOURCE_MAPPING_URL_REG_EXP2.test(generatedSource)) && typeof atob == "function") {
						var match = SOURCE_MAPPING_URL_REG_EXP.exec(generatedSource) || SOURCE_MAPPING_URL_REG_EXP2.exec(generatedSource);
						generatedSource = generatedSource.replace(SOURCE_MAPPING_URL_REG_EXP, "/* base64 source map removed */").replace(SOURCE_MAPPING_URL_REG_EXP2, "/* base64 source map removed */");
						try {
							sourceMap = JSON.parse(decodeURIComponent(escape(atob(match[1]))));
							return step3();
						} catch (e) { }
					}
					$(".custom-modal .modal-body").html(__webpack_require__(29)({
						generatedSource: generatedSource
					}));
					$(".custom-continue").click(continueWithStep3);
					$(".file").change(continueWithStep3);
					function continueWithStep3() {
						loadFile($(".file"), function (err, _sourceMap) {
							$(".custom-error").addClass("hide");
							if (err) {
								$(".custom-error").removeClass("hide").text(err.message);
								return $(".custom-continue").attr("disabled", false);
							}
							try {
								_sourceMap = JSON.parse(_sourceMap);
								if (!_sourceMap.sources) throw new Error("SourceMap has no sources field");
								if (!_sourceMap.mappings) throw new Error("SourceMap has no mappings field");
							} catch (e) {
								$(".custom-error").removeClass("hide").text(e.message);
								_sourceMap = false;
							}
							if (!_sourceMap)
								return $(".custom-continue").attr("disabled", false);
							sourceMap = _sourceMap;
							step3();
						});
					}
				}
				function step3() {
					if (!sourceMap.sources || !sourceMap.mappings) {
						return $(".custom-error")
							.removeClass("hide")
							.text("This is not a valid SourceMap.");
					}
					if (sourceMap.sourcesContent) {
						sourcesContent = sourceMap.sourcesContent;
						return step4();
					}
					var sourceFile, sourceFileIndex;
					for (var i = 0; i < sourceMap.sources.length; i++) {
						if (!sourcesContent[i]) {
							sourceFile = sourceMap.sources[i];
							sourceFileIndex = i;
							break;
						}
					}
					if (i == sourceMap.sources.length) return step4();
					$(".custom-modal .modal-body").html(__webpack_require__(30)({
						generatedSource: generatedSource,
						sourceMap: sourceMap,
						source: sourceFile
					}));
					$(".custom-continue").click(continueWithStep4);
					$(".file").change(continueWithStep4);
					function continueWithStep4() {
						loadFile($(".file"), function (err, _originalSource) {
							$(".custom-error").addClass("hide");
							if (err) {
								$(".custom-error").removeClass("hide").text(err.message);
								return $(".custom-continue").attr("disabled", false);
							}
							if (!_originalSource)
								return $(".custom-continue").attr("disabled", false);
							sourcesContent[sourceFileIndex] = _originalSource;
							return step3();
						});
					}
				}
				function step4() {
					try {
						loadCustomExample(sourcesContent, generatedSource, sourceMap);
						$(".custom-modal").modal("hide");
						oldHash = window.location.hash = "custom";
					} catch (e) {
						$(".custom-error").removeClass("hide").text(e.message);
						console.error(e.stack);
						return $(".custom-continue").attr("disabled", false);
					}
				}
	
			} else {
				if (exampleKinds.indexOf(exampleKind) < 0) exampleKind = "typescript";
				var exampleJs = __webpack_require__(21)("./" + exampleKind + "/example.js");
				var exampleMap = __webpack_require__(19)("./" + exampleKind + "/example.map");
				var sources = exampleMap.sourcesContent;
				if (!sources) {
					sources = [__webpack_require__(20)("./" + exampleKind + "/example")];
				}
				loadExample(sources, exampleJs, exampleMap);
				$(".custom-link").text("");
				oldHash = exampleKind;
			}
		});
		$(window).hashchange();
		var allFiles = [];
	
		$(window).on("dragenter dragover", function (e) {
			e.stopPropagation();
			e.preventDefault();
	
			var m = $(".custom-modal").data("modal");
			if (m && m.isShown) return;
			//if there was no modal, this is a new drag-n-drop session. clear out the files list
			allFiles = [];
			$(".custom-modal .modal-body").html(__webpack_require__(27)());
			$(".custom-modal").modal({
				show: true
			});
			$(".custom-error").addClass("hide");
			return false;
		});
		$(window).on("drop", function (e) {
			e.stopPropagation();
			e.preventDefault();
	
			var files = e.originalEvent.dataTransfer.files;
	
			var count = files.length;
			if (count === 0) return false;
			var filesData = Array.prototype.map.call(files, function (file) { return { file: file, name: file.name }; });
			filesData.forEach(function (data) {
				readFile(data.file, function (err, result) {
					data.err = err;
					data.result = result;
					if (--count === 0) finished();
				});
			});
			return false;
			function finished() {
				try {
					var erroredFiles = filesData.filter(function (data) { return data.err; });
					if (erroredFiles.length > 0) {
						var errorText = erroredFiles.map(function (data) {
							return data.name + ": " + data.err;
						}).join("\n");
						throw new Error(errorText);
					}
	
					allFiles.push(...filesData);
					filesData = [...allFiles];
	
					var $filesList = $(".custom-modal .modal-body .files .list");
					if ($filesList.length === 0) {
						$(".custom-modal .modal-body").append('<div class="files"><b>Files:</b><ul class="list"></ul></div>');
						$filesList = $(".custom-modal .modal-body .files .list");
					}
	
					$filesList.html(allFiles.map(x => `<li>${x.name}</li>`).join(''));
					var sourceMapFile, generatedFile;
					//find inline sourcemap
					var generatedFileWithSourceMap = filesData.filter(function (data) {
						return SOURCE_MAPPING_URL_REG_EXP.test(data.result) || SOURCE_MAPPING_URL_REG_EXP2.test(data.result);
					})[0];
					if (generatedFileWithSourceMap) {
						if (typeof atob !== "function")
							throw new Error("Your browser doesn't support atob. Cannot decode base64.");
						// Extract SourceMap from base64 DataUrl
						generatedFile = generatedFileWithSourceMap;
						filesData.splice(filesData.indexOf(generatedFile), 1);
						var generatedSource = generatedFile.result;
						var match = SOURCE_MAPPING_URL_REG_EXP.exec(generatedSource) || SOURCE_MAPPING_URL_REG_EXP2.exec(generatedSource);
						generatedFile.result = generatedFile.result.replace(SOURCE_MAPPING_URL_REG_EXP, "/* base64 source map removed */").replace(SOURCE_MAPPING_URL_REG_EXP2, "/* base64 source map removed */");
						sourceMapFile = {
							result: decodeURIComponent(escape(atob(match[1])))
						};
						sourceMapFile.json = JSON.parse(sourceMapFile.result);
					} else {
						// Find SourceMap in provided files
						var mapFiles = filesData.filter(function (data) {
							return /\.map$/.test(data.name);
						});
						if (mapFiles.length === 1) {
							// Use the .map file as SourceMap
							sourceMapFile = mapFiles[0];
							filesData.splice(filesData.indexOf(sourceMapFile), 1);
						} else {
							var jsonFiles = filesData.filter(function (data) {
								return /\.json$/.test(data.name);
							});
							if (jsonFiles.length === 1) {
								// Use the .json file as SourceMap
								sourceMapFile = jsonFiles[0];
								filesData.splice(filesData.indexOf(sourceMapFile), 1);
							} else {
								throw new Error("No SourceMap provided.");
							}
						}
						sourceMapFile.json = JSON.parse(sourceMapFile.result);
	
						//get name from SourceMap (or generate a name by removing .map from the sourcemap if possible)
						var name = sourceMapFile.json.file || sourceMapFile.name.replace(/\.map$/, '');
	
						generatedFile = filesData.filter(function (data) {
							// The file with the exact name
							return data.name === name;
						})[0] || filesData.filter(function (data) {
							// The first js file
							return /\.js$/.test(data.name);
						})[0];
						if (!generatedFile) {
							throw Error("No original file provided.");
						}
						filesData.splice(filesData.indexOf(generatedFile), 1);
					}
					var providedSourcesContent = filesData.map(function (data) { return data.result; });
					var sourcesContentSet = sourceMapFile.json.sourcesContent && sourceMapFile.json.sourcesContent.length > 0
					if (providedSourcesContent.length > 0 && sourcesContentSet)
						throw new Error("Provided source files, but sourcesContent already provided within SourceMap.");
					loadCustomExample(
						sourcesContentSet ? sourceMapFile.json.sourcesContent : providedSourcesContent,
						generatedFile.result,
						sourceMapFile.json
					);
					$(".custom-modal").modal("hide");
					oldHash = window.location.hash = "custom";
				} catch (err) {
					return $(".custom-error").removeClass("hide").text(err.message).attr("title", err.stack);
				}
			}
			return false;
		});
	
		function loadCustomExample(sourcesContent, generatedSource, sourceMap) {
			loadExample(sourcesContent, generatedSource, sourceMap);
			$(".custom-link").attr("href", "#base64," + [generatedSource, JSON.stringify(sourceMap)].concat(sourcesContent).map(function (str) {
				return btoa(unescape(encodeURIComponent(str)));
			}).join(",")).text("Link to this");
		}
		function loadExample(sources, exampleJs, exampleMap) {
			var visu = $("main").hide().text("");
			var footer = $("footer")
	
			try {
				exampleMap.file = exampleMap.file || "example.js";
				var map = new SourceMap.SourceMapConsumer(exampleMap);
	
				var results = generateHtml(map, exampleJs, sources);
				visu.html(results.files);
				footer.html(results.mappings);
	
				$("body").delegate(".original-item, .generated-item, .mapping-item", "mouseenter", function () {
					$(".selected").removeClass("selected");
					var mappedItems = $(this).data('mapped');
					if (!mappedItems) {
						var source = $(this).data("source");
						var line = $(this).data("line");
						var column = $(this).data("column");
						mappedItems = $(".item-" + source + "-" + line + "-" + column);
						$(this).data('mapped', mappedItems)
					}
					$(mappedItems).addClass("selected");
	
				}).delegate(".original-item, .generated-item, .mapping-item", "click", function () {
					var mappedItems = $(this).data('mapped');
					var elems = $(mappedItems).not(this).get();
					if (elems.length) {
						elems.forEach(function (elem) {
							if ('scrollIntoViewIfNeeded' in elem)
								return elem.scrollIntoViewIfNeeded();
							elem.scrollIntoView({ behavior: 'smooth' })
						})
					}
				});
	
				$('header p .js-minify').off('click').click(function () {
					var result = UglifyJS.minify(exampleJs, {
						outSourceMap: "example.map",
						output: {
							beautify: true
						}
					});
					var minmap = JSON.parse(result.map);
					minmap.file = "example";
					minmap = new SourceMap.SourceMapConsumer(result.map);
					minmap = SourceMap.SourceMapGenerator.fromSourceMap(minmap);
					minmap.setSourceContent("?", exampleJs);
					map.sourcesContent = sources;
					minmap.applySourceMap(map, "?");
					minmap = minmap.toJSON();
					var idx = minmap.sources.indexOf("?");
	
					loadExample(minmap.sourcesContent, result.code, minmap);
					oldHash = window.location.hash = "custom";
				});
			} catch (e) {
				throw e;
			} finally {
				visu.show();
			}
		}
	});
	
	function readFile(file, callback) {
		var fileReader = new FileReader();
		fileReader.readAsText(file, "utf-8");
		fileReader.onload = function (e) {
			callback(null, fileReader.result);
		};
		fileReader.onprogess = function (evt) {
			if (evt.lengthComputable) {
				var percentLoaded = Math.round((evt.loaded / evt.total) * 100);
				if (percentLoaded < 100) {
					$(".read-progress").css("width", percentLoaded + "%");
				}
			}
		};
		fileReader.onabort = function (e) {
			return callback(new Error('File read cancelled'));
		};
		fileReader.onerror = function (evt) {
			switch (evt.target.error.code) {
				case evt.target.error.NOT_FOUND_ERR:
					return callback(new Error('File Not Found!'));
				case evt.target.error.NOT_READABLE_ERR:
					return callback(new Error('File is not readable'));
				case evt.target.error.ABORT_ERR:
					return callback();
				default:
					return callback(new Error('An error occurred reading this file.'));
			}
		};
	}
	
	function loadFile(fileInput, callback) {
		var file = $(fileInput)[0].files[0];
		if (!file) return callback();
		readFile(file, callback);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Merge two attribute objects giving precedence
	 * to values in object `b`. Classes are special-cased
	 * allowing for arrays and merging/joining appropriately
	 * resulting in a string.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api private
	 */
	
	exports.merge = function merge(a, b) {
	  if (arguments.length === 1) {
	    var attrs = a[0];
	    for (var i = 1; i < a.length; i++) {
	      attrs = merge(attrs, a[i]);
	    }
	    return attrs;
	  }
	  var ac = a['class'];
	  var bc = b['class'];
	
	  if (ac || bc) {
	    ac = ac || [];
	    bc = bc || [];
	    if (!Array.isArray(ac)) ac = [ac];
	    if (!Array.isArray(bc)) bc = [bc];
	    a['class'] = ac.concat(bc).filter(nulls);
	  }
	
	  for (var key in b) {
	    if (key != 'class') {
	      a[key] = b[key];
	    }
	  }
	
	  return a;
	};
	
	/**
	 * Filter null `val`s.
	 *
	 * @param {*} val
	 * @return {Boolean}
	 * @api private
	 */
	
	function nulls(val) {
	  return val != null && val !== '';
	}
	
	/**
	 * join array as classes.
	 *
	 * @param {*} val
	 * @return {String}
	 */
	exports.joinClasses = joinClasses;
	function joinClasses(val) {
	  return (Array.isArray(val) ? val.map(joinClasses) :
	    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
	    [val]).filter(nulls).join(' ');
	}
	
	/**
	 * Render the given classes.
	 *
	 * @param {Array} classes
	 * @param {Array.<Boolean>} escaped
	 * @return {String}
	 */
	exports.cls = function cls(classes, escaped) {
	  var buf = [];
	  for (var i = 0; i < classes.length; i++) {
	    if (escaped && escaped[i]) {
	      buf.push(exports.escape(joinClasses([classes[i]])));
	    } else {
	      buf.push(joinClasses(classes[i]));
	    }
	  }
	  var text = joinClasses(buf);
	  if (text.length) {
	    return ' class="' + text + '"';
	  } else {
	    return '';
	  }
	};
	
	
	exports.style = function (val) {
	  if (val && typeof val === 'object') {
	    return Object.keys(val).map(function (style) {
	      return style + ':' + val[style];
	    }).join(';');
	  } else {
	    return val;
	  }
	};
	/**
	 * Render the given attribute.
	 *
	 * @param {String} key
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @param {Boolean} terse
	 * @return {String}
	 */
	exports.attr = function attr(key, val, escaped, terse) {
	  if (key === 'style') {
	    val = exports.style(val);
	  }
	  if ('boolean' == typeof val || null == val) {
	    if (val) {
	      return ' ' + (terse ? key : key + '="' + key + '"');
	    } else {
	      return '';
	    }
	  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
	    if (JSON.stringify(val).indexOf('&') !== -1) {
	      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
	                   'will be escaped to `&amp;`');
	    };
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will eliminate the double quotes around dates in ' +
	                   'ISO form after 2.0.0');
	    }
	    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
	  } else if (escaped) {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + exports.escape(val) + '"';
	  } else {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + val + '"';
	  }
	};
	
	/**
	 * Render the given attributes object.
	 *
	 * @param {Object} obj
	 * @param {Object} escaped
	 * @return {String}
	 */
	exports.attrs = function attrs(obj, terse){
	  var buf = [];
	
	  var keys = Object.keys(obj);
	
	  if (keys.length) {
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i]
	        , val = obj[key];
	
	      if ('class' == key) {
	        if (val = joinClasses(val)) {
	          buf.push(' ' + key + '="' + val + '"');
	        }
	      } else {
	        buf.push(exports.attr(key, val, false, terse));
	      }
	    }
	  }
	
	  return buf.join('');
	};
	
	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */
	
	var jade_encode_html_rules = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};
	var jade_match_html = /[&<>"]/g;
	
	function jade_encode_char(c) {
	  return jade_encode_html_rules[c] || c;
	}
	
	exports.escape = jade_escape;
	function jade_escape(html){
	  var result = String(html).replace(jade_match_html, jade_encode_char);
	  if (result === '' + html) return html;
	  else return result;
	};
	
	/**
	 * Re-throw the given `err` in context to the
	 * the jade in `filename` at the given `lineno`.
	 *
	 * @param {Error} err
	 * @param {String} filename
	 * @param {String} lineno
	 * @api private
	 */
	
	exports.rethrow = function rethrow(err, filename, lineno, str){
	  if (!(err instanceof Error)) throw err;
	  if ((typeof window != 'undefined' || !filename) && !str) {
	    err.message += ' on line ' + lineno;
	    throw err;
	  }
	  try {
	    str = str || __webpack_require__(53).readFileSync(filename, 'utf8')
	  } catch (ex) {
	    rethrow(err, null, lineno)
	  }
	  var context = 3
	    , lines = str.split('\n')
	    , start = Math.max(lineno - context, 0)
	    , end = Math.min(lines.length, lineno + context);
	
	  // Error context
	  var context = lines.slice(start, end).map(function(line, i){
	    var curr = i + start + 1;
	    return (curr == lineno ? '  > ' : '    ')
	      + curr
	      + '| '
	      + line;
	  }).join('\n');
	
	  // Alter exception message
	  err.path = filename;
	  err.message = (filename || 'Jade') + ':' + lineno
	    + '\n' + context + '\n\n' + err.message;
	  throw err;
	};
	
	exports.DebugItem = function DebugItem(lineno, filename) {
	  this.lineno = lineno;
	  this.filename = filename;
	}


/***/ }),
/* 2 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;
	
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	
	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;
	
	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;
	
	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);
	
	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');
	
	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }
	
	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;
	
	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }
	
	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }
	
	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }
	
	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }
	
	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;
	
	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};
	
	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	
	  aRoot = aRoot.replace(/\/$/, '');
	
	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }
	
	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }
	
	    ++level;
	  }
	
	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;
	
	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());
	
	function identity (s) {
	  return s;
	}
	
	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }
	
	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;
	
	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }
	
	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;
	
	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }
	
	  var length = s.length;
	
	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }
	
	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }
	
	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;
	
	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }
	
	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }
	
	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }
	
	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }
	
	  if (aStr1 > aStr2) {
	    return 1;
	  }
	
	  return -1;
	}
	
	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	
	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;
	
	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';
	
	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }
	
	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }
	
	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(12).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(45).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(46).SourceNode;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = "// Expression bodies\nvar odds = evens.map(v => v + 1);\nvar nums = evens.map((v, i) => v + i);\n\n// Statement bodies\nnums.forEach(v => {\n  if (v % 5 === 0)\n    fives.push(v);\n});\n\n// Lexical this\nvar bob = {\n  _name: \"Bob\",\n  _friends: [],\n  printFriends() {\n    this._friends.forEach(f =>\n      console.log(this._name + \" knows \" + f));\n  }\n};\n\n\nclass SkinnedMesh extends THREE.Mesh {\n  constructor(geometry, materials) {\n    super(geometry, materials);\n\n    this.idMatrix = SkinnedMesh.defaultMatrix();\n    this.bones = [];\n    this.boneMatrices = [];\n    //...\n  }\n  update(camera) {\n    //...\n    super.update();\n  }\n  static defaultMatrix() {\n    return new THREE.Matrix4();\n  }\n}\n\n\nvar obj = {\n    // __proto__\n    __proto__: theProtoObj,\n    // Does not set internal prototype\n    '__proto__': somethingElse,\n    // Shorthand for ‘handler: handler’\n    handler,\n    // Methods\n    toString() {\n     // Super calls\n     return \"d \" + super.toString();\n    },\n    // Computed (dynamic) property names\n    [ \"prop_\" + (() => 42)() ]: 42\n};\n\n\n// Basic literal string creation\n`This is a pretty little template string.`\n\n// Multiline strings\n`In ES5 this is\n not legal.`\n\n// Interpolate variable bindings\nvar name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n\n// Unescaped template strings\nString.raw`In ES5 \"\\n\" is a line-feed.`\n\n// Construct an HTTP request prefix is used to interpret the replacements and construction\nGET`http://foo.org/bar?a=${a}&b=${b}\n    Content-Type: application/json\n    X-Credentials: ${credentials}\n    { \"foo\": ${foo},\n      \"bar\": ${bar}}`(myOnReadyStateChangeHandler);\n\n\n// list matching\nvar [a, ,b] = [1,2,3];\na === 1;\nb === 3;\n\n// object matching\nvar { op: a, lhs: { op: b }, rhs: c }\n       = getASTNode()\n\n// object matching shorthand\n// binds `op`, `lhs` and `rhs` in scope\nvar {op, lhs, rhs} = getASTNode()\n\n// Can be used in parameter position\nfunction g({name: x}) {\n  console.log(x);\n}\ng({name: 5})\n\n// Fail-soft destructuring\nvar [a] = [];\na === undefined;\n\n// Fail-soft destructuring with defaults\nvar [a = 1] = [];\na === 1;\n\n// Destructuring + defaults arguments\nfunction r({x, y, w = 10, h = 10}) {\n  return x + y + w + h;\n}\nr({x:1, y:2}) === 23\n\n\nfunction f(x, y=12) {\n  // y is 12 if not passed (or passed as undefined)\n  return x + y;\n}\nf(3) == 15\nfunction f(x, ...y) {\n  // y is an Array\n  return x * y.length;\n}\nf(3, \"hello\", true) == 6\nfunction f(x, y, z) {\n  return x + y + z;\n}\n// Pass each elem of array as argument\nf(...[1,2,3]) == 6\n\n\nfunction f() {\n  {\n    let x;\n    {\n      // okay, block scoped name\n      const x = \"sneaky\";\n    }\n    // okay, declared with `let`\n    x = \"bar\";\n  }\n}\n\n\nfunction factorial(n, acc = 1) {\n    \"use strict\";\n    if (n <= 1) return acc;\n    return factorial(n - 1, n * acc);\n}\n\n// Stack overflow in most implementations today,\n// but safe on arbitrary inputs in ES2015\nfactorial(100000)"

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	module.exports = "# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)"

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	module.exports = "$white: #fff;\n$color_tundora: #444;\n$color_primary_brand: #301e80;\n\n@mixin flex-base {\n  display: flex;\n  justify-content: flex-start;\n  align-items: stretch;\n  flex: 1;\n}\n\n@mixin horizontal-container {\n  flex-direction: row;\n  flex-flow: row wrap;\n  @include flex-base;\n}\n\n@mixin vertical-container {\n  flex-direction: column;\n  @include flex-base;\n}\n\n* {\n  box-sizing: border-box;\n}\n\nhtml, body {\n  padding: 0;\n  margin: 0;\n  height: 100%;\n  width: 100%;\n  font-family: 'Helvetica', 'Verdana', sans-serif;\n  font-weight: 400;\n  // Not implemented yet but is a nice solution for async loading fonts\n  font-display: optional;\n  color: $color_tundora;\n}\n\nhtml {\n  overflow: hidden;\n}\n\nbody {\n  @include vertical-container;\n  flex-wrap: nowrap;\n  background: #ececec;\n}\n\n.header {\n  width: 100%;\n  min-height: 56px;\n  color: $white;\n  background: $color_primary_brand;\n  position: fixed;\n  font-size: 20px;\n  padding: 16px 16px 0 16px;\n  will-change: transform;\n  @include horizontal-container;\n  transition: transform 0.233s cubic-bezier(0,0,0.21,1) 0.1s;\n  z-index: 1000;\n\n  .headerButton {\n    width: 24px;\n    height: 24px;\n    margin-right: 16px;\n    text-indent: -30000px;\n    overflow: hidden;\n    opacity: 0.54;\n    transition: opacity 0.333s cubic-bezier(0,0,0.21,1);\n    border: none;\n    outline: none;\n    cursor: pointer;\n  }\n  .butRefresh {\n    background: url(/images/ic_refresh_white_24px.svg) center center no-repeat;\n  }\n  .butAdd {\n    background: url(/images/ic_add_white_24px.svg) center center no-repeat;\n  }\n}\n\n.header__title {\n  font-weight: 400;\n  font-size: 20px;\n  margin: 0;\n  flex: 1;\n}\n\n.loader {\n  left: 50%;\n  top: 50%;\n  position: fixed;\n  transform: translate(-50%, -50%);\n\n  .spinner {\n    box-sizing: border-box;\n    stroke: #673AB7;\n    stroke-width: 3px;\n    transform-origin: 50%;\n\n    animation: line 1.6s cubic-bezier(0.4, 0.0, 0.2, 1) infinite,\n      rotate 1.6s linear infinite;\n  }\n\n  @keyframes rotate {\n\n    from {\n      transform: rotate(0)\n    }\n\n    to {\n      transform: rotate(450deg);\n    }\n  }\n\n  @keyframes line {\n    0% {\n      stroke-dasharray: 2, 85.964;\n      transform: rotate(0);\n    }\n\n    50% {\n      stroke-dasharray: 65.973, 21.9911;\n      stroke-dashoffset: 0;\n    }\n\n    100% {\n      stroke-dasharray: 2, 85.964;\n      stroke-dashoffset: -65.973;\n      transform: rotate(90deg);\n    }\n  }\n}\n\n.main {\n  padding-top: 60px;\n  flex: 1;\n  overflow-x: hidden;\n  overflow-y: auto;\n  -webkit-overflow-scrolling: touch;\n}\n\n.dialog-container {\n  background: rgba(0,0,0,0.57);\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0;\n  pointer-events: none;\n  will-change: opacity;\n  transition: opacity 0.333s cubic-bezier(0,0,0.21,1);\n}\n\n.dialog-container--visible {\n  opacity: 1;\n  pointer-events: auto;\n}\n\n.dialog {\n  background: #FFF;\n  border-radius: 2px;\n  box-shadow: 0 0 14px rgba(0,0,0,.24),\n              0 14px 28px rgba(0,0,0,.48);\n  min-width: 280px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%) translateY(30px);\n  transition: transform 0.333s cubic-bezier(0,0,0.21,1) 0.05s;\n  padding: 24px;\n  font-size: 30px;\n\n  select, button {\n    font-size: 20px;\n  }\n}\n\n@mixin classy-border($color, $width) {\n  border-color: $color;\n  border-width: $width;\n  border-style: solid;\n}\n\n.card {\n  padding: 16px;\n  position: relative;\n  box-sizing: border-box;\n  background: #fff;\n  border-radius: 2px;\n  margin: 16px;\n  box-shadow: 0 3px 1px 1px rgba(0, 0, 0, 0.2);\n  @include classy-border(#eee, 1px);\n}\n\n/* TODO: use variable for smaller icon, too. */\n$iconsize: 96px;\n\n.weather-forecast {\n  .current .icon {\n    width: $iconsize;\n    height: $iconsize;\n  }\n  .future .icon {\n    width: 32px;\n    height: 32px;\n  }\n\n  .current {\n    display: flex;\n    .visual {\n      display: flex;\n      font-size: 2em;\n      .scale {\n        font-size: 0.5em;\n        vertical-align: super;\n      }\n    }\n\n    .visual, .description {\n      flex-grow: 1;\n    }\n\n    $my-color: #888;\n    .feels-like:before {\n      content: \"Feels like: \";\n      color: $my-color;\n    }\n\n    .wind:before {\n      content: \"Wind: \";\n      color: $my-color;\n    }\n\n    .precip:before {\n      content: \"Precipitation: \";\n      color: $my-color;\n    }\n\n    .humidity:before {\n      content: \"Humidity: \";\n      color: $my-color;\n    }\n\n    .pollen:before {\n      content: \"Pollen Count: \";\n      color: $my-color;\n    }\n\n    .pcount:before {\n      content: \"Pollen \";\n      color: $my-color;\n    }\n  }\n\n  .location {\n    font-size: 1.35em;\n  }\n  .date, .description {\n    font-size: 0.7em;\n  }\n\n\n  .future {\n    display: flex;\n\n    .oneday {\n      flex-grow: 1;\n      text-align: center;\n\n      .icon {\n        margin-left: auto;\n        margin-right: auto;\n      }\n\n      .temp-high, .temp-low {\n        display: inline-block;\n      }\n\n      .temp-low {\n        color: #888;\n      }\n    }\n  }\n\n  .icon {\n    background-repeat: no-repeat;\n    background-size: contain;\n    &.clear-day { background-image: url('/images/clear.png'); }\n    &.clear-night { background-image: url('/images/clear.png'); }\n    &.rain { background-image: url('/images/rain.png'); }\n    &.snow { background-image: url('/images/snow.png'); }\n    &.sleet { background-image: url('/images/sleet.png'); }\n    &.wind { background-image: url('/images/wind.png'); }\n    &.fog { background-image: url('/images/fog.png'); }\n    &.cloudy { background-image: url('/images/cloudy.png'); }\n    &.partly-cloudy-day { background-image: url('/images/partly-cloudy.png'); }\n    &.partly-cloudy-night { background-image: url('/images/partly-cloudy.png'); }\n    &.thunderstorms { background-image: url('/images/thunderstorms.png'); }\n  }\n}\n\n@media (min-width: 360px) {\n  .weather-forecast {\n    .location {\n      font-size: 2.25em;\n    }\n    .date, .description {\n      font-size: 0.9em;\n    }\n    .current {\n      .visual {\n        font-size: 3em;\n      }\n    }\n  }\n}\n\n@media (min-width: 500px) {\n  .weather-forecast {\n    .date, .description {\n      font-size: 1.25em;\n    }\n    .location {\n      font-size: 2.45em;\n    }\n    .current {\n      .icon {\n        width: 128px;\n        height: 128px;\n      }\n      .visual {\n        font-size: 4em;\n      }\n    }\n    .future {\n      .oneday {\n        .icon {\n          width: 64px;\n          height: 64px;\n        }\n      }\n    }\n  }\n}\n\n@media (min-width: 1015px) {\n  .main {\n    display: flex;\n    align-items: flex-start;\n    flex-wrap: wrap;\n    align-content: flex-start;\n  }\n\n  .card {\n    flex: 1 1 auto;\n    max-width: calc(50% - 32px);\n  }\n}\n\n\n\nfooter {\n  width: 100%;\n  height: 26px;\n  background: $color_primary_brand;\n  position: fixed;\n  font-size: 20px;\n  bottom: 0;\n  will-change: transform;\n  transition: transform 0.233s cubic-bezier(0,0,0.21,1) 0.1s;\n  z-index: 1000;\n}\n"

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	module.exports = "square = (x) -> x * x\ncube   = (x) -> square(x) * x\n\nalert cube(5)"

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = "module Sayings {\n    export class Greeter {\n        greeting: string;\n        constructor(message: string) {\n            this.greeting = message;\n        }\n        greet() {\n            return \"Hello, \" + this.greeting;\n        }\n    }\n}\nvar greeter = new Sayings.Greeter(\"world\");\n\nvar button = document.createElement('button');\nbutton.innerText = \"Say Hello\";\nbutton.onclick = function() {\n    alert(greeter.greet());\n};\n\ndocument.body.appendChild(button);\n"

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(2);
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	
	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}
	
	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};
	
	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	
	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};
	
	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};
	
	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }
	
	  throw new Error('"' + aStr + '" is not in the set.');
	};
	
	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};
	
	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};
	
	exports.ArraySet = ArraySet;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	
	var base64 = __webpack_require__(41);
	
	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011
	
	var VLQ_BASE_SHIFT = 5;
	
	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}
	
	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}
	
	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	exports.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;
	
	  var vlq = toVLQSigned(aValue);
	
	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);
	
	  return encoded;
	};
	
	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;
	
	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }
	
	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }
	
	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);
	
	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var base64VLQ = __webpack_require__(11);
	var util = __webpack_require__(2);
	var ArraySet = __webpack_require__(10).ArraySet;
	var MappingList = __webpack_require__(43).MappingList;
	
	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}
	
	SourceMapGenerator.prototype._version = 3;
	
	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };
	
	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }
	
	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };
	
	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }
	
	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }
	
	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }
	
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };
	
	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);
	
	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }
	
	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }
	
	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }
	
	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };
	
	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }
	
	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };
	
	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();
	
	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source)
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }
	
	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }
	
	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }
	
	    }, this);
	    this._sources = newSources;
	    this._names = newNames;
	
	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };
	
	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }
	
	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };
	
	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;
	
	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = ''
	
	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }
	
	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;
	
	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;
	
	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;
	
	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;
	
	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }
	
	      result += next;
	    }
	
	    return result;
	  };
	
	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };
	
	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }
	
	    return map;
	  };
	
	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };
	
	exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {"jQuery":true}))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v1.9.1
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2013-2-4
	 */
	(function( window, undefined ) {
	
	// Can't do this because several apps including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	// Support: Firefox 18+
	//"use strict";
	var
		// The deferred used on DOM ready
		readyList,
	
		// A central reference to the root jQuery(document)
		rootjQuery,
	
		// Support: IE<9
		// For `typeof node.method` instead of `node.method !== undefined`
		core_strundefined = typeof undefined,
	
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,
		location = window.location,
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$,
	
		// [[Class]] -> type pairs
		class2type = {},
	
		// List of deleted data cache ids, so we can reuse them
		core_deletedIds = [],
	
		core_version = "1.9.1",
	
		// Save a reference to some core methods
		core_concat = core_deletedIds.concat,
		core_push = core_deletedIds.push,
		core_slice = core_deletedIds.slice,
		core_indexOf = core_deletedIds.indexOf,
		core_toString = class2type.toString,
		core_hasOwn = class2type.hasOwnProperty,
		core_trim = core_version.trim,
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			return new jQuery.fn.init( selector, context, rootjQuery );
		},
	
		// Used for matching numbers
		core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
	
		// Used for splitting on whitespace
		core_rnotwhite = /\S+/g,
	
		// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	
		// Match a standalone tag
		rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
	
		// JSON RegExp
		rvalidchars = /^[\],:{}\s]*$/,
		rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
		rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
		rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		},
	
		// The ready event handler
		completed = function( event ) {
	
			// readyState === "complete" is good enough for us to call the dom ready in oldIE
			if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
				detach();
				jQuery.ready();
			}
		},
		// Clean-up method for dom ready events
		detach = function() {
			if ( document.addEventListener ) {
				document.removeEventListener( "DOMContentLoaded", completed, false );
				window.removeEventListener( "load", completed, false );
	
			} else {
				document.detachEvent( "onreadystatechange", completed );
				window.detachEvent( "onload", completed );
			}
		};
	
	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: core_version,
	
		constructor: jQuery,
		init: function( selector, context, rootjQuery ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;
	
						// scripts is true for back-compat
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );
	
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id !== match[2] ) {
								return rootjQuery.find( selector );
							}
	
							// Otherwise, we inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}
	
						this.context = document;
						this.selector = selector;
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return rootjQuery.ready( selector );
			}
	
			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}
	
			return jQuery.makeArray( selector, this );
		},
	
		// Start with an empty selector
		selector: "",
	
		// The default length of a jQuery object is 0
		length: 0,
	
		// The number of elements contained in the matched element set
		size: function() {
			return this.length;
		},
	
		toArray: function() {
			return core_slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num == null ?
	
				// Return a 'clean' array
				this.toArray() :
	
				// Return just the object
				( num < 0 ? this[ this.length + num ] : this[ num ] );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},
	
		ready: function( fn ) {
			// Add the callback
			jQuery.ready.promise().done( fn );
	
			return this;
		},
	
		slice: function() {
			return this.pushStack( core_slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},
	
		end: function() {
			return this.prevObject || this.constructor(null);
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: core_push,
		sort: [].sort,
		splice: [].splice
	};
	
	// Give the init function the jQuery prototype for later instantiation
	jQuery.fn.init.prototype = jQuery.fn;
	
	jQuery.extend = jQuery.fn.extend = function() {
		var src, copyIsArray, copy, name, options, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}
	
		// extend jQuery itself if only one argument is passed
		if ( length === i ) {
			target = this;
			--i;
		}
	
		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend({
		noConflict: function( deep ) {
			if ( window.$ === jQuery ) {
				window.$ = _$;
			}
	
			if ( deep && window.jQuery === jQuery ) {
				window.jQuery = _jQuery;
			}
	
			return jQuery;
		},
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready );
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
	
			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger("ready").off("ready");
			}
		},
	
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},
	
		isArray: Array.isArray || function( obj ) {
			return jQuery.type(obj) === "array";
		},
	
		isWindow: function( obj ) {
			return obj != null && obj == obj.window;
		},
	
		isNumeric: function( obj ) {
			return !isNaN( parseFloat(obj) ) && isFinite( obj );
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return String( obj );
			}
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ core_toString.call(obj) ] || "object" :
				typeof obj;
		},
	
		isPlainObject: function( obj ) {
			// Must be an Object.
			// Because of IE, we also have to check the presence of the constructor property.
			// Make sure that DOM nodes and window objects don't pass through, as well
			if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}
	
			try {
				// Not own constructor property must be Object
				if ( obj.constructor &&
					!core_hasOwn.call(obj, "constructor") &&
					!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
					return false;
				}
			} catch ( e ) {
				// IE8,9 Will throw exceptions on certain host objects #9897
				return false;
			}
	
			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.
	
			var key;
			for ( key in obj ) {}
	
			return key === undefined || core_hasOwn.call( obj, key );
		},
	
		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		// data: string of html
		// context (optional): If specified, the fragment will be created in this context, defaults to document
		// keepScripts (optional): If true, will include scripts passed in the html string
		parseHTML: function( data, context, keepScripts ) {
			if ( !data || typeof data !== "string" ) {
				return null;
			}
			if ( typeof context === "boolean" ) {
				keepScripts = context;
				context = false;
			}
			context = context || document;
	
			var parsed = rsingleTag.exec( data ),
				scripts = !keepScripts && [];
	
			// Single tag
			if ( parsed ) {
				return [ context.createElement( parsed[1] ) ];
			}
	
			parsed = jQuery.buildFragment( [ data ], context, scripts );
			if ( scripts ) {
				jQuery( scripts ).remove();
			}
			return jQuery.merge( [], parsed.childNodes );
		},
	
		parseJSON: function( data ) {
			// Attempt to parse using the native JSON parser first
			if ( window.JSON && window.JSON.parse ) {
				return window.JSON.parse( data );
			}
	
			if ( data === null ) {
				return data;
			}
	
			if ( typeof data === "string" ) {
	
				// Make sure leading/trailing whitespace is removed (IE can't handle it)
				data = jQuery.trim( data );
	
				if ( data ) {
					// Make sure the incoming data is actual JSON
					// Logic borrowed from http://json.org/json2.js
					if ( rvalidchars.test( data.replace( rvalidescape, "@" )
						.replace( rvalidtokens, "]" )
						.replace( rvalidbraces, "")) ) {
	
						return ( new Function( "return " + data ) )();
					}
				}
			}
	
			jQuery.error( "Invalid JSON: " + data );
		},
	
		// Cross-browser xml parsing
		parseXML: function( data ) {
			var xml, tmp;
			if ( !data || typeof data !== "string" ) {
				return null;
			}
			try {
				if ( window.DOMParser ) { // Standard
					tmp = new DOMParser();
					xml = tmp.parseFromString( data , "text/xml" );
				} else { // IE
					xml = new ActiveXObject( "Microsoft.XMLDOM" );
					xml.async = "false";
					xml.loadXML( data );
				}
			} catch( e ) {
				xml = undefined;
			}
			if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
				jQuery.error( "Invalid XML: " + data );
			}
			return xml;
		},
	
		noop: function() {},
	
		// Evaluates a script in a global context
		// Workarounds based on findings by Jim Driscoll
		// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
		globalEval: function( data ) {
			if ( data && jQuery.trim( data ) ) {
				// We use execScript on Internet Explorer
				// We use an anonymous function so that context is window
				// rather than jQuery in Firefox
				( window.execScript || function( data ) {
					window[ "eval" ].call( window, data );
				} )( data );
			}
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );
	
			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );
	
						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );
	
						if ( value === false ) {
							break;
						}
					}
				}
	
			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );
	
						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );
	
						if ( value === false ) {
							break;
						}
					}
				}
			}
	
			return obj;
		},
	
		// Use native String.trim function wherever possible
		trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
			function( text ) {
				return text == null ?
					"" :
					core_trim.call( text );
			} :
	
			// Otherwise use our own trimming functionality
			function( text ) {
				return text == null ?
					"" :
					( text + "" ).replace( rtrim, "" );
			},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					core_push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			var len;
	
			if ( arr ) {
				if ( core_indexOf ) {
					return core_indexOf.call( arr, elem, i );
				}
	
				len = arr.length;
				i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
	
				for ( ; i < len; i++ ) {
					// Skip accessing in sparse arrays
					if ( i in arr && arr[ i ] === elem ) {
						return i;
					}
				}
			}
	
			return -1;
		},
	
		merge: function( first, second ) {
			var l = second.length,
				i = first.length,
				j = 0;
	
			if ( typeof l === "number" ) {
				for ( ; j < l; j++ ) {
					first[ i++ ] = second[ j ];
				}
			} else {
				while ( second[j] !== undefined ) {
					first[ i++ ] = second[ j++ ];
				}
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, inv ) {
			var retVal,
				ret = [],
				i = 0,
				length = elems.length;
			inv = !!inv;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				retVal = !!callback( elems[ i ], i );
				if ( inv !== retVal ) {
					ret.push( elems[ i ] );
				}
			}
	
			return ret;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];
	
			// Go through the array, translating each of the items to their
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret[ ret.length ] = value;
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret[ ret.length ] = value;
					}
				}
			}
	
			// Flatten any nested arrays
			return core_concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var args, proxy, tmp;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = core_slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		// Multifunctional method to get and set values of a collection
		// The value/s can optionally be executed if it's a function
		access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
			var i = 0,
				length = elems.length,
				bulk = key == null;
	
			// Sets many values
			if ( jQuery.type( key ) === "object" ) {
				chainable = true;
				for ( i in key ) {
					jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
				}
	
			// Sets one value
			} else if ( value !== undefined ) {
				chainable = true;
	
				if ( !jQuery.isFunction( value ) ) {
					raw = true;
				}
	
				if ( bulk ) {
					// Bulk operations run against the entire set
					if ( raw ) {
						fn.call( elems, value );
						fn = null;
	
					// ...except when executing function values
					} else {
						bulk = fn;
						fn = function( elem, key, value ) {
							return bulk.call( jQuery( elem ), value );
						};
					}
				}
	
				if ( fn ) {
					for ( ; i < length; i++ ) {
						fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
					}
				}
			}
	
			return chainable ?
				elems :
	
				// Gets
				bulk ?
					fn.call( elems ) :
					length ? fn( elems[0], key ) : emptyGet;
		},
	
		now: function() {
			return ( new Date() ).getTime();
		}
	});
	
	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {
	
			readyList = jQuery.Deferred();
	
			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// we once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );
	
			// Standards-based browsers support DOMContentLoaded
			} else if ( document.addEventListener ) {
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed, false );
	
				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed, false );
	
			// If IE event model is used
			} else {
				// Ensure firing before onload, maybe late but safe also for iframes
				document.attachEvent( "onreadystatechange", completed );
	
				// A fallback to window.onload, that will always work
				window.attachEvent( "onload", completed );
	
				// If IE and not a frame
				// continually check to see if the document is ready
				var top = false;
	
				try {
					top = window.frameElement == null && document.documentElement;
				} catch(e) {}
	
				if ( top && top.doScroll ) {
					(function doScrollCheck() {
						if ( !jQuery.isReady ) {
	
							try {
								// Use the trick by Diego Perini
								// http://javascript.nwbox.com/IEContentLoaded/
								top.doScroll("left");
							} catch(e) {
								return setTimeout( doScrollCheck, 50 );
							}
	
							// detach all dom ready events
							detach();
	
							// and execute any waiting functions
							jQuery.ready();
						}
					})();
				}
			}
		}
		return readyList.promise( obj );
	};
	
	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});
	
	function isArraylike( obj ) {
		var length = obj.length,
			type = jQuery.type( obj );
	
		if ( jQuery.isWindow( obj ) ) {
			return false;
		}
	
		if ( obj.nodeType === 1 && length ) {
			return true;
		}
	
		return type === "array" || type !== "function" &&
			( length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj );
	}
	
	// All jQuery objects should point back to these
	rootjQuery = jQuery(document);
	// String to Object options format cache
	var optionsCache = {};
	
	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
			// Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( list && ( !fired || stack ) ) {
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	jQuery.extend({
	
		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var action = tuple[ 0 ],
									fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Keep pipe for back-compat
			promise.pipe = promise.then;
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];
	
				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;
	
					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}
	
				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = core_slice.call( arguments ),
				length = resolveValues.length,
	
				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
	
				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
	
				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
						if( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},
	
				progressValues, progressContexts, resolveContexts;
	
			// add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}
	
			// if we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}
	
			return deferred.promise();
		}
	});
	jQuery.support = (function() {
	
		var support, all, a,
			input, select, fragment,
			opt, eventName, isSupported, i,
			div = document.createElement("div");
	
		// Setup
		div.setAttribute( "className", "t" );
		div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	
		// Support tests won't run in some limited or non-browser environments
		all = div.getElementsByTagName("*");
		a = div.getElementsByTagName("a")[ 0 ];
		if ( !all || !a || !all.length ) {
			return {};
		}
	
		// First batch of tests
		select = document.createElement("select");
		opt = select.appendChild( document.createElement("option") );
		input = div.getElementsByTagName("input")[ 0 ];
	
		a.style.cssText = "top:1px;float:left;opacity:.5";
		support = {
			// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
			getSetAttribute: div.className !== "t",
	
			// IE strips leading whitespace when .innerHTML is used
			leadingWhitespace: div.firstChild.nodeType === 3,
	
			// Make sure that tbody elements aren't automatically inserted
			// IE will insert them into empty tables
			tbody: !div.getElementsByTagName("tbody").length,
	
			// Make sure that link elements get serialized correctly by innerHTML
			// This requires a wrapper element in IE
			htmlSerialize: !!div.getElementsByTagName("link").length,
	
			// Get the style information from getAttribute
			// (IE uses .cssText instead)
			style: /top/.test( a.getAttribute("style") ),
	
			// Make sure that URLs aren't manipulated
			// (IE normalizes it by default)
			hrefNormalized: a.getAttribute("href") === "/a",
	
			// Make sure that element opacity exists
			// (IE uses filter instead)
			// Use a regex to work around a WebKit issue. See #5145
			opacity: /^0.5/.test( a.style.opacity ),
	
			// Verify style float existence
			// (IE uses styleFloat instead of cssFloat)
			cssFloat: !!a.style.cssFloat,
	
			// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
			checkOn: !!input.value,
	
			// Make sure that a selected-by-default option has a working selected property.
			// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
			optSelected: opt.selected,
	
			// Tests for enctype support on a form (#6743)
			enctype: !!document.createElement("form").enctype,
	
			// Makes sure cloning an html5 element does not cause problems
			// Where outerHTML is undefined, this still works
			html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
	
			// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
			boxModel: document.compatMode === "CSS1Compat",
	
			// Will be defined later
			deleteExpando: true,
			noCloneEvent: true,
			inlineBlockNeedsLayout: false,
			shrinkWrapBlocks: false,
			reliableMarginRight: true,
			boxSizingReliable: true,
			pixelPosition: false
		};
	
		// Make sure checked status is properly cloned
		input.checked = true;
		support.noCloneChecked = input.cloneNode( true ).checked;
	
		// Make sure that the options inside disabled selects aren't marked as disabled
		// (WebKit marks them as disabled)
		select.disabled = true;
		support.optDisabled = !opt.disabled;
	
		// Support: IE<9
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	
		// Check if we can trust getAttribute("value")
		input = document.createElement("input");
		input.setAttribute( "value", "" );
		support.input = input.getAttribute( "value" ) === "";
	
		// Check if an input maintains its value after becoming a radio
		input.value = "t";
		input.setAttribute( "type", "radio" );
		support.radioValue = input.value === "t";
	
		// #11217 - WebKit loses check when the name is after the checked attribute
		input.setAttribute( "checked", "t" );
		input.setAttribute( "name", "t" );
	
		fragment = document.createDocumentFragment();
		fragment.appendChild( input );
	
		// Check if a disconnected checkbox will retain its checked
		// value of true after appended to the DOM (IE6/7)
		support.appendChecked = input.checked;
	
		// WebKit doesn't clone checked state correctly in fragments
		support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE<9
		// Opera does not clone events (and typeof div.attachEvent === undefined).
		// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
		if ( div.attachEvent ) {
			div.attachEvent( "onclick", function() {
				support.noCloneEvent = false;
			});
	
			div.cloneNode( true ).click();
		}
	
		// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
		// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php
		for ( i in { submit: true, change: true, focusin: true }) {
			div.setAttribute( eventName = "on" + i, "t" );
	
			support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
		}
	
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		// Run tests that need a body at doc ready
		jQuery(function() {
			var container, marginDiv, tds,
				divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
				body = document.getElementsByTagName("body")[0];
	
			if ( !body ) {
				// Return for frameset docs that don't have a body
				return;
			}
	
			container = document.createElement("div");
			container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";
	
			body.appendChild( container ).appendChild( div );
	
			// Support: IE8
			// Check if table cells still have offsetWidth/Height when they are set
			// to display:none and there are still other visible table cells in a
			// table row; if so, offsetWidth/Height are not reliable for use when
			// determining if an element has been hidden directly using
			// display:none (it is still safe to use offsets if a parent element is
			// hidden; don safety goggles and see bug #4512 for more information).
			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
			tds = div.getElementsByTagName("td");
			tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
			isSupported = ( tds[ 0 ].offsetHeight === 0 );
	
			tds[ 0 ].style.display = "";
			tds[ 1 ].style.display = "none";
	
			// Support: IE8
			// Check if empty table cells still have offsetWidth/Height
			support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
	
			// Check box-sizing and margin behavior
			div.innerHTML = "";
			div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
			support.boxSizing = ( div.offsetWidth === 4 );
			support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );
	
			// Use window.getComputedStyle because jsdom on node.js will break without it.
			if ( window.getComputedStyle ) {
				support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
				support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
	
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// Fails in WebKit before Feb 2011 nightlies
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				marginDiv = div.appendChild( document.createElement("div") );
				marginDiv.style.cssText = div.style.cssText = divReset;
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
	
				support.reliableMarginRight =
					!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
			}
	
			if ( typeof div.style.zoom !== core_strundefined ) {
				// Support: IE<8
				// Check if natively block-level elements act like inline-block
				// elements when setting their display to 'inline' and giving
				// them layout
				div.innerHTML = "";
				div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
				support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );
	
				// Support: IE6
				// Check if elements with layout shrink-wrap their children
				div.style.display = "block";
				div.innerHTML = "<div></div>";
				div.firstChild.style.width = "5px";
				support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
	
				if ( support.inlineBlockNeedsLayout ) {
					// Prevent IE 6 from affecting layout for positioned elements #11048
					// Prevent IE from shrinking the body in IE 7 mode #12869
					// Support: IE<8
					body.style.zoom = 1;
				}
			}
	
			body.removeChild( container );
	
			// Null elements to avoid leaks in IE
			container = div = tds = marginDiv = null;
		});
	
		// Null elements to avoid leaks in IE
		all = select = fragment = opt = a = input = null;
	
		return support;
	})();
	
	var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
		rmultiDash = /([A-Z])/g;
	
	function internalData( elem, name, data, pvt /* Internal Use Only */ ){
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}
	
		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",
	
			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,
	
			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,
	
			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;
	
		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}
	
		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = core_deletedIds.pop() || jQuery.guid++;
			} else {
				id = internalKey;
			}
		}
	
		if ( !cache[ id ] ) {
			cache[ id ] = {};
	
			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}
	
		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}
	
		thisCache = cache[ id ];
	
		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}
	
			thisCache = thisCache.data;
		}
	
		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}
	
		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {
	
			// First Try to find as-is property data
			ret = thisCache[ name ];
	
			// Test for null|undefined property data
			if ( ret == null ) {
	
				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}
	
		return ret;
	}
	
	function internalRemoveData( elem, name, pvt ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}
	
		var i, l, thisCache,
			isNode = elem.nodeType,
	
			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;
	
		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}
	
		if ( name ) {
	
			thisCache = pvt ? cache[ id ] : cache[ id ].data;
	
			if ( thisCache ) {
	
				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {
	
					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {
	
						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(" ");
						}
					}
				} else {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = name.concat( jQuery.map( name, jQuery.camelCase ) );
				}
	
				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}
	
				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}
	
		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;
	
			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}
	
		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );
	
		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
			delete cache[ id ];
	
		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	}
	
	jQuery.extend({
		cache: {},
	
		// Unique for each copy of jQuery on the page
		// Non-digits removed to match rinlinejQuery
		expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),
	
		// The following elements throw uncatchable exceptions if you
		// attempt to add expando properties to them.
		noData: {
			"embed": true,
			// Ban all objects except for Flash (which handle expandos)
			"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
			"applet": true
		},
	
		hasData: function( elem ) {
			elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
			return !!elem && !isEmptyDataObject( elem );
		},
	
		data: function( elem, name, data ) {
			return internalData( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			return internalRemoveData( elem, name );
		},
	
		// For internal use only.
		_data: function( elem, name, data ) {
			return internalData( elem, name, data, true );
		},
	
		_removeData: function( elem, name ) {
			return internalRemoveData( elem, name, true );
		},
	
		// A method for determining if a DOM node can handle the data expando
		acceptData: function( elem ) {
			// Do not set data on non-element because it will not be cleared (#8335).
			if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {
				return false;
			}
	
			var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];
	
			// nodes accept data unless otherwise specified; rejection can be conditional
			return !noData || noData !== true && elem.getAttribute("classid") === noData;
		}
	});
	
	jQuery.fn.extend({
		data: function( key, value ) {
			var attrs, name,
				elem = this[0],
				i = 0,
				data = null;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = jQuery.data( elem );
	
					if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
						attrs = elem.attributes;
						for ( ; i < attrs.length; i++ ) {
							name = attrs[i].name;
	
							if ( !name.indexOf( "data-" ) ) {
								name = jQuery.camelCase( name.slice(5) );
	
								dataAttr( elem, name, data[ name ] );
							}
						}
						jQuery._data( elem, "parsedAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					jQuery.data( this, key );
				});
			}
	
			return jQuery.access( this, function( value ) {
	
				if ( value === undefined ) {
					// Try to fetch any internally stored data first
					return elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
				}
	
				this.each(function() {
					jQuery.data( this, key, value );
				});
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each(function() {
				jQuery.removeData( this, key );
			});
		}
	});
	
	function dataAttr( elem, key, data ) {
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
	
			var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
	
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
							data;
				} catch( e ) {}
	
				// Make sure we set the data so it isn't changed later
				jQuery.data( elem, key, data );
	
			} else {
				data = undefined;
			}
		}
	
		return data;
	}
	
	// checks a cache object for emptiness
	function isEmptyDataObject( obj ) {
		var name;
		for ( name in obj ) {
	
			// if the public data object is empty, the private is still empty
			if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
				continue;
			}
			if ( name !== "toJSON" ) {
				return false;
			}
		}
	
		return true;
	}
	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = jQuery._data( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray(data) ) {
						queue = jQuery._data( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			hooks.cur = fn;
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// not intended for public consumption - generates a queueHooks object, or returns the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return jQuery._data( elem, key ) || jQuery._data( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					jQuery._removeData( elem, type + "queue" );
					jQuery._removeData( elem, key );
				})
			});
		}
	});
	
	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}
	
			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );
	
					// ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		// Based off of the plugin by Clint Helfers, with permission.
		// http://blindsignals.com/index.php/2009/07/jquery-delay/
		delay: function( time, type ) {
			time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
			type = type || "fx";
	
			return this.queue( type, function( next, hooks ) {
				var timeout = setTimeout( next, time );
				hooks.stop = function() {
					clearTimeout( timeout );
				};
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while( i-- ) {
				tmp = jQuery._data( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var nodeHook, boolHook,
		rclass = /[\t\r\n]/g,
		rreturn = /\r/g,
		rfocusable = /^(?:input|select|textarea|button|object)$/i,
		rclickable = /^(?:a|area)$/i,
		rboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,
		ruseDefault = /^(?:checked|selected)$/i,
		getSetAttribute = jQuery.support.getSetAttribute,
		getSetInput = jQuery.support.input;
	
	jQuery.fn.extend({
		attr: function( name, value ) {
			return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		},
	
		prop: function( name, value ) {
			return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			name = jQuery.propFix[ name ] || name;
			return this.each(function() {
				// try/catch handles cases where IE balks (such as removing a property on window)
				try {
					this[ name ] = undefined;
					delete this[ name ];
				} catch( e ) {}
			});
		},
	
		addClass: function( value ) {
			var classes, elem, cur, clazz, j,
				i = 0,
				len = this.length,
				proceed = typeof value === "string" && value;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}
	
			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( core_rnotwhite ) || [];
	
				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);
	
					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
						elem.className = jQuery.trim( cur );
	
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, clazz, j,
				i = 0,
				len = this.length,
				proceed = arguments.length === 0 || typeof value === "string" && value;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( core_rnotwhite ) || [];
	
				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);
	
					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
						elem.className = value ? jQuery.trim( cur ) : "";
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isBool = typeof stateVal === "boolean";
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}
	
			return this.each(function() {
				if ( type === "string" ) {
					// toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						state = stateVal,
						classNames = value.match( core_rnotwhite ) || [];
	
					while ( (className = classNames[ i++ ]) ) {
						// check each className given, space separated list
						state = isBool ? state : !self.hasClass( className );
						self[ state ? "addClass" : "removeClass" ]( className );
					}
	
				// Toggle whole class name
				} else if ( type === core_strundefined || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						jQuery._data( this, "__className__", this.className );
					}
	
					// If the element has a class name or if we're passed "false",
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
				}
			});
		},
	
		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}
	
			return false;
		},
	
		val: function( value ) {
			var ret, hooks, isFunction,
				elem = this[0];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
						// handle most common string cases
						ret.replace(rreturn, "") :
						// handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each(function( i ) {
				var val,
					self = jQuery(this);
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, self.val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
				} else if ( typeof val === "number" ) {
					val += "";
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map(val, function ( value ) {
						return value == null ? "" : value + "";
					});
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});
	
	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					// attributes.value is undefined in Blackberry 4.7 but
					// uses .value. See #6932
					var val = elem.attributes.value;
					return !val || val.specified ? elem.value : elem.text;
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// oldIE doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var values = jQuery.makeArray( value );
	
					jQuery(elem).find("option").each(function() {
						this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
					});
	
					if ( !values.length ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		},
	
		attr: function( elem, name, value ) {
			var hooks, notxml, ret,
				nType = elem.nodeType;
	
			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === core_strundefined ) {
				return jQuery.prop( elem, name, value );
			}
	
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
	
			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( notxml ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
			}
	
			if ( value !== undefined ) {
	
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
	
				} else if ( hooks && notxml && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;
	
				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}
	
			} else if ( hooks && notxml && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;
	
			} else {
	
				// In IE9+, Flash objects don't have .getAttribute (#12945)
				// Support: IE9+
				if ( typeof elem.getAttribute !== core_strundefined ) {
					ret =  elem.getAttribute( name );
				}
	
				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},
	
		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( core_rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;
	
					// Boolean attributes get special treatment (#10870)
					if ( rboolean.test( name ) ) {
						// Set corresponding property to false for boolean attributes
						// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8
						if ( !getSetAttribute && ruseDefault.test( name ) ) {
							elem[ jQuery.camelCase( "default-" + name ) ] =
								elem[ propName ] = false;
						} else {
							elem[ propName ] = false;
						}
	
					// See #9699 for explanation of this approach (setting first, then removal)
					} else {
						jQuery.attr( elem, name, "" );
					}
	
					elem.removeAttribute( getSetAttribute ? name : propName );
				}
			}
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
						// Setting the type on a radio button after the value resets the value in IE6-9
						// Reset value to default in case type is set after value during creation
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		propFix: {
			tabindex: "tabIndex",
			readonly: "readOnly",
			"for": "htmlFor",
			"class": "className",
			maxlength: "maxLength",
			cellspacing: "cellSpacing",
			cellpadding: "cellPadding",
			rowspan: "rowSpan",
			colspan: "colSpan",
			usemap: "useMap",
			frameborder: "frameBorder",
			contenteditable: "contentEditable"
		},
	
		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;
	
			// don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
	
			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;
	
				} else {
					return ( elem[ name ] = value );
				}
	
			} else {
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
					return ret;
	
				} else {
					return elem[ name ];
				}
			}
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
					// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					var attributeNode = elem.getAttributeNode("tabindex");
	
					return attributeNode && attributeNode.specified ?
						parseInt( attributeNode.value, 10 ) :
						rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							undefined;
				}
			}
		}
	});
	
	// Hook for boolean attributes
	boolHook = {
		get: function( elem, name ) {
			var
				// Use .prop to determine if this attribute is understood as boolean
				prop = jQuery.prop( elem, name ),
	
				// Fetch it accordingly
				attr = typeof prop === "boolean" && elem.getAttribute( name ),
				detail = typeof prop === "boolean" ?
	
					getSetInput && getSetAttribute ?
						attr != null :
						// oldIE fabricates an empty string for missing boolean attributes
						// and conflates checked/selected into attroperties
						ruseDefault.test( name ) ?
							elem[ jQuery.camelCase( "default-" + name ) ] :
							!!attr :
	
					// fetch an attribute node for properties not recognized as boolean
					elem.getAttributeNode( name );
	
			return detail && detail.value !== false ?
				name.toLowerCase() :
				undefined;
		},
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
				// IE<8 needs the *property* name
				elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );
	
			// Use defaultChecked and defaultSelected for oldIE
			} else {
				elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
			}
	
			return name;
		}
	};
	
	// fix oldIE value attroperty
	if ( !getSetInput || !getSetAttribute ) {
		jQuery.attrHooks.value = {
			get: function( elem, name ) {
				var ret = elem.getAttributeNode( name );
				return jQuery.nodeName( elem, "input" ) ?
	
					// Ignore the value *property* by using defaultValue
					elem.defaultValue :
	
					ret && ret.specified ? ret.value : undefined;
			},
			set: function( elem, value, name ) {
				if ( jQuery.nodeName( elem, "input" ) ) {
					// Does not return so that setAttribute is also used
					elem.defaultValue = value;
				} else {
					// Use nodeHook if defined (#1954); otherwise setAttribute is fine
					return nodeHook && nodeHook.set( elem, value, name );
				}
			}
		};
	}
	
	// IE6/7 do not support getting/setting some attributes with get/setAttribute
	if ( !getSetAttribute ) {
	
		// Use this for any attribute in IE6/7
		// This fixes almost every IE6/7 issue
		nodeHook = jQuery.valHooks.button = {
			get: function( elem, name ) {
				var ret = elem.getAttributeNode( name );
				return ret && ( name === "id" || name === "name" || name === "coords" ? ret.value !== "" : ret.specified ) ?
					ret.value :
					undefined;
			},
			set: function( elem, value, name ) {
				// Set the existing or create a new attribute node
				var ret = elem.getAttributeNode( name );
				if ( !ret ) {
					elem.setAttributeNode(
						(ret = elem.ownerDocument.createAttribute( name ))
					);
				}
	
				ret.value = value += "";
	
				// Break association with cloned elements by also using setAttribute (#9646)
				return name === "value" || value === elem.getAttribute( name ) ?
					value :
					undefined;
			}
		};
	
		// Set contenteditable to false on removals(#10429)
		// Setting to empty string throws an error as an invalid value
		jQuery.attrHooks.contenteditable = {
			get: nodeHook.get,
			set: function( elem, value, name ) {
				nodeHook.set( elem, value === "" ? false : value, name );
			}
		};
	
		// Set width and height to auto instead of 0 on empty string( Bug #8150 )
		// This is for removals
		jQuery.each([ "width", "height" ], function( i, name ) {
			jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
				set: function( elem, value ) {
					if ( value === "" ) {
						elem.setAttribute( name, "auto" );
						return value;
					}
				}
			});
		});
	}
	
	
	// Some attributes require a special call on IE
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !jQuery.support.hrefNormalized ) {
		jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
			jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
				get: function( elem ) {
					var ret = elem.getAttribute( name, 2 );
					return ret == null ? undefined : ret;
				}
			});
		});
	
		// href/src property should get the full normalized URL (#10299/#12915)
		jQuery.each([ "href", "src" ], function( i, name ) {
			jQuery.propHooks[ name ] = {
				get: function( elem ) {
					return elem.getAttribute( name, 4 );
				}
			};
		});
	}
	
	if ( !jQuery.support.style ) {
		jQuery.attrHooks.style = {
			get: function( elem ) {
				// Return undefined in the case of empty string
				// Note: IE uppercases css property names, but if we were to .toLowerCase()
				// .cssText, that would destroy case senstitivity in URL's, like in "background"
				return elem.style.cssText || undefined;
			},
			set: function( elem, value ) {
				return ( elem.style.cssText = value + "" );
			}
		};
	}
	
	// Safari mis-reports the default selected property of an option
	// Accessing the parent's selectedIndex property fixes it
	if ( !jQuery.support.optSelected ) {
		jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
			get: function( elem ) {
				var parent = elem.parentNode;
	
				if ( parent ) {
					parent.selectedIndex;
	
					// Make sure that it also works with optgroups, see #5701
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
				return null;
			}
		});
	}
	
	// IE6/7 call enctype encoding
	if ( !jQuery.support.enctype ) {
		jQuery.propFix.enctype = "encoding";
	}
	
	// Radios and checkboxes getter/setter
	if ( !jQuery.support.checkOn ) {
		jQuery.each([ "radio", "checkbox" ], function() {
			jQuery.valHooks[ this ] = {
				get: function( elem ) {
					// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
					return elem.getAttribute("value") === null ? "on" : elem.value;
				}
			};
		});
	}
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		});
	});
	var rformElems = /^(?:input|select|textarea)$/i,
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
			var tmp, events, t, handleObjIn,
				special, eventHandle, handleObj,
				handlers, type, namespaces, origType,
				elemData = jQuery._data( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
						jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
						undefined;
				};
				// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
				eventHandle.elem = elem;
			}
	
			// Handle multiple events separated by a space
			// jQuery(...).bind("mouseover mouseout", fn);
			types = ( types || "" ).match( core_rnotwhite ) || [""];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener/attachEvent if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						// Bind the global event handler to the element
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );
	
						} else if ( elem.attachEvent ) {
							elem.attachEvent( "on" + type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
			// Nullify elem to prevent memory leaks in IE
			elem = null;
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
			var j, handleObj, tmp,
				origCount, t, events,
				special, handlers, type,
				namespaces, origType,
				elemData = jQuery.hasData( elem ) && jQuery._data( elem );
	
			if ( !elemData || !(events = elemData.events) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( core_rnotwhite ) || [""];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;
	
				// removeData also checks for emptiness and clears the expando if empty
				// so use it instead of delete
				jQuery._removeData( elem, "events" );
			}
		},
	
		trigger: function( event, data, elem, onlyHandlers ) {
			var handle, ontype, cur,
				bubbleType, special, tmp, i,
				eventPath = [ elem || document ],
				type = core_hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			event.isTrigger = true;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
					event.preventDefault();
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
					!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name name as the event.
					// Can't use an .isFunction() check here because IE6/7 fails that test.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						try {
							elem[ type ]();
						} catch ( e ) {
							// IE<9 dies on focus/blur to hidden element (#1486,#12518)
							// only reproducible on winXP IE8 native, not IE9 in IE8 mode
						}
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		dispatch: function( event ) {
	
			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );
	
			var i, ret, handleObj, matched, j,
				handlerQueue = [],
				args = core_slice.call( arguments ),
				handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or
					// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var sel, handleObj, matches, i,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {
	
				for ( ; cur != this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}
	
			return handlerQueue;
		},
	
		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}
	
			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];
	
			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
	
			event = new jQuery.Event( originalEvent );
	
			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}
	
			// Support: IE<9
			// Fix target property (#1925)
			if ( !event.target ) {
				event.target = originalEvent.srcElement || document;
			}
	
			// Support: Chrome 23+, Safari?
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}
	
			// Support: IE<9
			// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
			event.metaKey = !!event.metaKey;
	
			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},
	
		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
	
		fixHooks: {},
	
		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {
	
				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}
	
				return event;
			}
		},
	
		mouseHooks: {
			props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var body, eventDoc, doc,
					button = original.button,
					fromElement = original.fromElement;
	
				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;
	
					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}
	
				// Add relatedTarget, if necessary
				if ( !event.relatedTarget && fromElement ) {
					event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
				}
	
				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}
	
				return event;
			}
		},
	
		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
						this.click();
						return false;
					}
				}
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== document.activeElement && this.focus ) {
						try {
							this.focus();
							return false;
						} catch ( e ) {
							// Support: IE<9
							// If we error on focus to hidden element (#1486, #12518),
							// let .trigger() run the handlers
						}
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === document.activeElement && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Even when returnValue equals to undefined Firefox will still show alert
					if ( event.result !== undefined ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},
	
		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{ type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};
	
	jQuery.removeEvent = document.removeEventListener ?
		function( elem, type, handle ) {
			if ( elem.removeEventListener ) {
				elem.removeEventListener( type, handle, false );
			}
		} :
		function( elem, type, handle ) {
			var name = "on" + type;
	
			if ( elem.detachEvent ) {
	
				// #8545, #7054, preventing memory leaks for custom events in IE6-8
				// detachEvent needed property on element, by name of that event, to properly expose it to GC
				if ( typeof elem[ name ] === core_strundefined ) {
					elem[ name ] = null;
				}
	
				elem.detachEvent( name, handle );
			}
		};
	
	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
				src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
			if ( !e ) {
				return;
			}
	
			// If preventDefault exists, run it on the original event
			if ( e.preventDefault ) {
				e.preventDefault();
	
			// Support: IE
			// Otherwise set the returnValue property of the original event to false
			} else {
				e.returnValue = false;
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
			if ( !e ) {
				return;
			}
			// If stopPropagation exists, run it on the original event
			if ( e.stopPropagation ) {
				e.stopPropagation();
			}
	
			// Support: IE
			// Set the cancelBubble property of the original event to true
			e.cancelBubble = true;
		},
		stopImmediatePropagation: function() {
			this.isImmediatePropagationStopped = returnTrue;
			this.stopPropagation();
		}
	};
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});
	
	// IE submit delegation
	if ( !jQuery.support.submitBubbles ) {
	
		jQuery.event.special.submit = {
			setup: function() {
				// Only need this for delegated form submit events
				if ( jQuery.nodeName( this, "form" ) ) {
					return false;
				}
	
				// Lazy-add a submit handler when a descendant form may potentially be submitted
				jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
					// Node name check avoids a VML-related crash in IE (#9807)
					var elem = e.target,
						form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
					if ( form && !jQuery._data( form, "submitBubbles" ) ) {
						jQuery.event.add( form, "submit._submit", function( event ) {
							event._submit_bubble = true;
						});
						jQuery._data( form, "submitBubbles", true );
					}
				});
				// return undefined since we don't need an event listener
			},
	
			postDispatch: function( event ) {
				// If form was submitted by the user, bubble the event up the tree
				if ( event._submit_bubble ) {
					delete event._submit_bubble;
					if ( this.parentNode && !event.isTrigger ) {
						jQuery.event.simulate( "submit", this.parentNode, event, true );
					}
				}
			},
	
			teardown: function() {
				// Only need this for delegated form submit events
				if ( jQuery.nodeName( this, "form" ) ) {
					return false;
				}
	
				// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
				jQuery.event.remove( this, "._submit" );
			}
		};
	}
	
	// IE change delegation and checkbox/radio fix
	if ( !jQuery.support.changeBubbles ) {
	
		jQuery.event.special.change = {
	
			setup: function() {
	
				if ( rformElems.test( this.nodeName ) ) {
					// IE doesn't fire change on a check/radio until blur; trigger it on click
					// after a propertychange. Eat the blur-change in special.change.handle.
					// This still fires onchange a second time for check/radio after blur.
					if ( this.type === "checkbox" || this.type === "radio" ) {
						jQuery.event.add( this, "propertychange._change", function( event ) {
							if ( event.originalEvent.propertyName === "checked" ) {
								this._just_changed = true;
							}
						});
						jQuery.event.add( this, "click._change", function( event ) {
							if ( this._just_changed && !event.isTrigger ) {
								this._just_changed = false;
							}
							// Allow triggered, simulated change events (#11500)
							jQuery.event.simulate( "change", this, event, true );
						});
					}
					return false;
				}
				// Delegated event; lazy-add a change handler on descendant inputs
				jQuery.event.add( this, "beforeactivate._change", function( e ) {
					var elem = e.target;
	
					if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
						jQuery.event.add( elem, "change._change", function( event ) {
							if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
								jQuery.event.simulate( "change", this.parentNode, event, true );
							}
						});
						jQuery._data( elem, "changeBubbles", true );
					}
				});
			},
	
			handle: function( event ) {
				var elem = event.target;
	
				// Swallow native change events from checkbox/radio, we already triggered them above
				if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
					return event.handleObj.handler.apply( this, arguments );
				}
			},
	
			teardown: function() {
				jQuery.event.remove( this, "._change" );
	
				return !rformElems.test( this.nodeName );
			}
		};
	}
	
	// Create "bubbling" focus and blur events
	if ( !jQuery.support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler while someone wants focusin/focusout
			var attaches = 0,
				handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					if ( attaches++ === 0 ) {
						document.addEventListener( orig, handler, true );
					}
				},
				teardown: function() {
					if ( --attaches === 0 ) {
						document.removeEventListener( orig, handler, true );
					}
				}
			};
		});
	}
	
	jQuery.fn.extend({
	
		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var type, origFn;
	
			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}
	
			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}
	
			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		},
	
		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	});
	/*!
	 * Sizzle CSS Selector Engine
	 * Copyright 2012 jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://sizzlejs.com/
	 */
	(function( window, undefined ) {
	
	var i,
		cachedruns,
		Expr,
		getText,
		isXML,
		compile,
		hasDuplicate,
		outermostContext,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsXML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
		sortOrder,
	
		// Instance-specific data
		expando = "sizzle" + -(new Date()),
		preferredDoc = window.document,
		support = {},
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
	
		// General-purpose constants
		strundefined = typeof undefined,
		MAX_NEGATIVE = 1 << 31,
	
		// Array methods
		arr = [],
		pop = arr.pop,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf if we can't use a native one
		indexOf = arr.indexOf || function( elem ) {
			var i = 0,
				len = this.length;
			for ( ; i < len; i++ ) {
				if ( this[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
	
		// Regular expressions
	
		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),
	
		// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
		operators = "([*^$|!~]?=)",
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
			"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
	
		// Prefer arguments quoted,
		//   then not containing pseudos/brackets,
		//   then attribute selectors/non-parenthetical expressions,
		//   then anything else
		// These preferences are here to reduce the number of selectors
		//   needing tokenize in the PSEUDO preFilter
		pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rsibling = /[\x20\t\r\n\f]*[+~]/,
	
		rnative = /^[^{]+\{\s*\[native code/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rescape = /'|\\/g,
		rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,
		funescape = function( _, escaped ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			return high !== high ?
				escaped :
				// BMP codepoint
				high < 0 ?
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		};
	
	// Use a stripped-down slice if we can't use a native one
	try {
		slice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType;
	} catch ( e ) {
		slice = function( i ) {
			var elem,
				results = [];
			while ( (elem = this[i++]) ) {
				results.push( elem );
			}
			return results;
		};
	}
	
	/**
	 * For feature detection
	 * @param {Function} fn The function to test for native support
	 */
	function isNative( fn ) {
		return rnative.test( fn + "" );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var cache,
			keys = [];
	
		return (cache = function( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key += " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key ] = value);
		});
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return fn( div );
		} catch (e) {
			return false;
		} finally {
			// release memory in IE
			div = null;
		}
	}
	
	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;
	
		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
	
		context = context || document;
		results = results || [];
	
		if ( !selector || typeof selector !== "string" ) {
			return results;
		}
	
		if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
			return [];
		}
	
		if ( !documentIsXML && !seed ) {
	
			// Shortcuts
			if ( (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}
	
				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
					return results;
	
				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getByClassName && context.getElementsByClassName ) {
					push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
					return results;
				}
			}
	
			// QSA path
			if ( support.qsa && !rbuggyQSA.test(selector) ) {
				old = true;
				nid = expando;
				newContext = context;
				newSelector = nodeType === 9 && selector;
	
				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );
	
					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";
	
					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && context.parentNode || context;
					newSelector = groups.join(",");
				}
	
				if ( newSelector ) {
					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							newSelector
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Detect xml
	 * @param {Element|Object} elem An element or a document
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var doc = node ? node.ownerDocument || node : preferredDoc;
	
		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Set our document
		document = doc;
		docElem = doc.documentElement;
	
		// Support tests
		documentIsXML = isXML( doc );
	
		// Check if getElementsByTagName("*") returns only elements
		support.tagNameNoComments = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Check if attributes should be retrieved by attribute nodes
		support.attributes = assert(function( div ) {
			div.innerHTML = "<select></select>";
			var type = typeof div.lastChild.getAttribute("multiple");
			// IE8 returns a string for some attributes even when not present
			return type !== "boolean" && type !== "string";
		});
	
		// Check if getElementsByClassName can be trusted
		support.getByClassName = assert(function( div ) {
			// Opera can't find a second classname (in 9.6)
			div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
			if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
				return false;
			}
	
			// Safari 3.2 caches class attributes and doesn't catch changes
			div.lastChild.className = "e";
			return div.getElementsByClassName("e").length === 2;
		});
	
		// Check if getElementById returns elements by name
		// Check if getElementsByName privileges form controls or returns elements by ID
		support.getByName = assert(function( div ) {
			// Inject content
			div.id = expando + 0;
			div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
			docElem.insertBefore( div, docElem.firstChild );
	
			// Test
			var pass = doc.getElementsByName &&
				// buggy browsers will return fewer than the correct 2
				doc.getElementsByName( expando ).length === 2 +
				// buggy browsers will return more than the correct 0
				doc.getElementsByName( expando + 0 ).length;
			support.getIdNotName = !doc.getElementById( expando );
	
			// Cleanup
			docElem.removeChild( div );
	
			return pass;
		});
	
		// IE6/7 return modified attributes
		Expr.attrHandle = assert(function( div ) {
			div.innerHTML = "<a href='#'></a>";
			return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
				div.firstChild.getAttribute("href") === "#";
		}) ?
			{} :
			{
				"href": function( elem ) {
					return elem.getAttribute( "href", 2 );
				},
				"type": function( elem ) {
					return elem.getAttribute("type");
				}
			};
	
		// ID find and filter
		if ( support.getIdNotName ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [m] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
					var m = context.getElementById( id );
	
					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
				}
			};
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.tagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Name
		Expr.find["NAME"] = support.getByName && function( tag, context ) {
			if ( typeof context.getElementsByName !== strundefined ) {
				return context.getElementsByName( name );
			}
		};
	
		// Class
		Expr.find["CLASS"] = support.getByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== strundefined && !documentIsXML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21),
		// no need to also add to buggyMatches since matches checks buggyQSA
		// A support test would require too much code (would include document ready)
		rbuggyQSA = [ ":focus" ];
	
		if ( (support.qsa = isNative(doc.querySelectorAll)) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explictly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				div.innerHTML = "<select><option selected=''></option></select>";
	
				// IE8 - Some boolean attributes are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
			});
	
			assert(function( div ) {
	
				// Opera 10-12/IE8 - ^= $= *= and empty values
				// Should not select anything
				div.innerHTML = "<input type='hidden' i=''/>";
				if ( div.querySelectorAll("[i^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.webkitMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = new RegExp( rbuggyMatches.join("|") );
	
		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = isNative(docElem.contains) || docElem.compareDocumentPosition ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		// Document order sorting
		sortOrder = docElem.compareDocumentPosition ?
		function( a, b ) {
			var compare;
	
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			if ( (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b )) ) {
				if ( compare & 1 || a.parentNode && a.parentNode.nodeType === 11 ) {
					if ( a === doc || contains( preferredDoc, a ) ) {
						return -1;
					}
					if ( b === doc || contains( preferredDoc, b ) ) {
						return 1;
					}
					return 0;
				}
				return compare & 4 ? -1 : 1;
			}
	
			return a.compareDocumentPosition ? -1 : 1;
		} :
		function( a, b ) {
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
	
			// Parentless nodes are either documents or disconnected
			} else if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		// Always assume the presence of duplicates if sort doesn't
		// pass them to our comparison function (as in Google Chrome).
		hasDuplicate = false;
		[0, 0].sort( sortOrder );
		support.detectDuplicates = hasDuplicate;
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		// rbuggyQSA always contains :focus, so no need for an existence check
		if ( support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr) ) {
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch(e) {}
		}
	
		return Sizzle( expr, document, null, [elem] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		var val;
	
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		if ( !documentIsXML ) {
			name = name.toLowerCase();
		}
		if ( (val = Expr.attrHandle[ name ]) ) {
			return val( elem );
		}
		if ( documentIsXML || support.attributes ) {
			return elem.getAttribute( name );
		}
		return ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) && elem[ name ] === true ?
			name :
			val && val.specified ? val.value : null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	// Document sorting and removing duplicates
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			i = 1,
			j = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			for ( ; (elem = results[i]); i++ ) {
				if ( elem === results[ i - 1 ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		return results;
	};
	
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	// Returns a function to use in pseudos for input types
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	// Returns a function to use in pseudos for buttons
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	// Returns a function to use in pseudos for positionals
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			for ( ; (node = elem[i]); i++ ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[5] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[4] ) {
					match[2] = match[4];
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeName ) {
				if ( nodeName === "*" ) {
					return function() { return true; };
				}
	
				nodeName = nodeName.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];
	
							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}
	
										if ( node === elem ) {
											break;
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf.call( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifider
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsXML ?
							elem.getAttribute("xml:lang") || elem.getAttribute("lang") :
							elem.lang) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
				//   not comment, processing instructions, or others
				// Thanks to Diego Perini for the nodeName shortcut
				//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
				// use getAttribute instead to test this case
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	function tokenize( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( tokens = [] );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				} );
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push( {
						value: matched,
						type: type,
						matches: match
					} );
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	}
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var data, cache, outerCache,
					dirkey = dirruns + " " + doneName;
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
								if ( (data = cache[1]) === true || data === cachedruns ) {
									return data === true;
								}
							} else {
								cache = outerCache[ dir ] = [ dirkey ];
								cache[1] = matcher( elem, context, xml ) || cachedruns;
								if ( cache[1] === true ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf.call( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		// A counter to specify which element is currently being matched
		var matcherCachedRuns = 0,
			bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, expandContext ) {
				var elem, j, matcher,
					setMatched = [],
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					outermost = expandContext != null,
					contextBackup = outermostContext,
					// We must always have either seed elements or context
					elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);
	
				if ( outermost ) {
					outermostContext = context !== document && context;
					cachedruns = matcherCachedRuns;
				}
	
				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				for ( ; (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
							cachedruns = ++matcherCachedRuns;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !group ) {
				group = tokenize( selector );
			}
			i = group.length;
			while ( i-- ) {
				cached = matcherFromTokens( group[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
		}
		return cached;
	};
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function select( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			match = tokenize( selector );
	
		if ( !seed ) {
			// Try to minimize operations if there is only one group
			if ( match.length === 1 ) {
	
				// Take a shortcut and set the context if the root selector is an ID
				tokens = match[0] = match[0].slice( 0 );
				if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
						context.nodeType === 9 && !documentIsXML &&
						Expr.relative[ tokens[1].type ] ) {
	
					context = Expr.find["ID"]( token.matches[0].replace( runescape, funescape ), context )[0];
					if ( !context ) {
						return results;
					}
	
					selector = selector.slice( tokens.shift().value.length );
				}
	
				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
				while ( i-- ) {
					token = tokens[i];
	
					// Abort if we hit a combinator
					if ( Expr.relative[ (type = token.type) ] ) {
						break;
					}
					if ( (find = Expr.find[ type ]) ) {
						// Search, expanding context for leading sibling combinators
						if ( (seed = find(
							token.matches[0].replace( runescape, funescape ),
							rsibling.test( tokens[0].type ) && context.parentNode || context
						)) ) {
	
							// If seed is empty or no tokens remain, we can return early
							tokens.splice( i, 1 );
							selector = seed.length && toSelector( tokens );
							if ( !selector ) {
								push.apply( results, slice.call( seed, 0 ) );
								return results;
							}
	
							break;
						}
					}
				}
			}
		}
	
		// Compile and execute a filtering function
		// Provide `match` to avoid retokenization if we modified the selector above
		compile( selector, match )(
			seed,
			context,
			documentIsXML,
			results,
			rsibling.test( selector )
		);
		return results;
	}
	
	// Deprecated
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Easy API for creating new setFilters
	function setFilters() {}
	Expr.filters = setFilters.prototype = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	// Initialize with the default document
	setDocument();
	
	// Override sizzle attribute retrieval
	Sizzle.attr = jQuery.attr;
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	
	
	})( window );
	var runtil = /Until$/,
		rparentsprev = /^(?:parents|prev(?:Until|All))/,
		isSimple = /^.[^:#\[\.,]*$/,
		rneedsContext = jQuery.expr.match.needsContext,
		// methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend({
		find: function( selector ) {
			var i, ret, self,
				len = this.length;
	
			if ( typeof selector !== "string" ) {
				self = this;
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}
	
			ret = [];
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, this[ i ], ret );
			}
	
			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = ( this.selector ? this.selector + " " : "" ) + selector;
			return ret;
		},
	
		has: function( target ) {
			var i,
				targets = jQuery( target, this ),
				len = targets.length;
	
			return this.filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},
	
		not: function( selector ) {
			return this.pushStack( winnow(this, selector, false) );
		},
	
		filter: function( selector ) {
			return this.pushStack( winnow(this, selector, true) );
		},
	
		is: function( selector ) {
			return !!selector && (
				typeof selector === "string" ?
					// If this is a positional/relative selector, check membership in the returned set
					// so $("p:first").is("p:last") won't return true for a doc with two "p".
					rneedsContext.test( selector ) ?
						jQuery( selector, this.context ).index( this[0] ) >= 0 :
						jQuery.filter( selector, this ).length > 0 :
					this.filter( selector ).length > 0 );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				ret = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;
	
			for ( ; i < l; i++ ) {
				cur = this[i];
	
				while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
					if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
						ret.push( cur );
						break;
					}
					cur = cur.parentNode;
				}
			}
	
			return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
		},
	
		// Determine the position of an element within
		// the matched set of elements
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// index in selector
			if ( typeof elem === "string" ) {
				return jQuery.inArray( this[0], jQuery( elem ) );
			}
	
			// Locate the position of the desired element
			return jQuery.inArray(
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[0] : elem, this );
		},
	
		add: function( selector, context ) {
			var set = typeof selector === "string" ?
					jQuery( selector, context ) :
					jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
				all = jQuery.merge( this.get(), set );
	
			return this.pushStack( jQuery.unique(all) );
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});
	
	jQuery.fn.andSelf = jQuery.fn.addBack;
	
	function sibling( cur, dir ) {
		do {
			cur = cur[ dir ];
		} while ( cur && cur.nodeType !== 1 );
	
		return cur;
	}
	
	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return jQuery.nodeName( elem, "iframe" ) ?
				elem.contentDocument || elem.contentWindow.document :
				jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var ret = jQuery.map( this, fn, until );
	
			if ( !runtil.test( name ) ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				ret = jQuery.filter( selector, ret );
			}
	
			ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
	
			if ( this.length > 1 && rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
	
			return this.pushStack( ret );
		};
	});
	
	jQuery.extend({
		filter: function( expr, elems, not ) {
			if ( not ) {
				expr = ":not(" + expr + ")";
			}
	
			return elems.length === 1 ?
				jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
				jQuery.find.matches(expr, elems);
		},
	
		dir: function( elem, dir, until ) {
			var matched = [],
				cur = elem[ dir ];
	
			while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
				if ( cur.nodeType === 1 ) {
					matched.push( cur );
				}
				cur = cur[dir];
			}
			return matched;
		},
	
		sibling: function( n, elem ) {
			var r = [];
	
			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					r.push( n );
				}
			}
	
			return r;
		}
	});
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, keep ) {
	
		// Can't pass null or undefined to indexOf in Firefox 4
		// Set to 0 to skip string check
		qualifier = qualifier || 0;
	
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep(elements, function( elem, i ) {
				var retVal = !!qualifier.call( elem, i, elem );
				return retVal === keep;
			});
	
		} else if ( qualifier.nodeType ) {
			return jQuery.grep(elements, function( elem ) {
				return ( elem === qualifier ) === keep;
			});
	
		} else if ( typeof qualifier === "string" ) {
			var filtered = jQuery.grep(elements, function( elem ) {
				return elem.nodeType === 1;
			});
	
			if ( isSimple.test( qualifier ) ) {
				return jQuery.filter(qualifier, filtered, !keep);
			} else {
				qualifier = jQuery.filter( qualifier, filtered );
			}
		}
	
		return jQuery.grep(elements, function( elem ) {
			return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
		});
	}
	function createSafeFragment( document ) {
		var list = nodeNames.split( "|" ),
			safeFrag = document.createDocumentFragment();
	
		if ( safeFrag.createElement ) {
			while ( list.length ) {
				safeFrag.createElement(
					list.pop()
				);
			}
		}
		return safeFrag;
	}
	
	var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
			"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
		rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
		rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
		rleadingWhitespace = /^\s+/,
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rtbody = /<tbody/i,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
	
		// We have to close these tags to support XHTML (#13200)
		wrapMap = {
			option: [ 1, "<select multiple='multiple'>", "</select>" ],
			legend: [ 1, "<fieldset>", "</fieldset>" ],
			area: [ 1, "<map>", "</map>" ],
			param: [ 1, "<object>", "</object>" ],
			thead: [ 1, "<table>", "</table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
			// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
			// unless wrapped in a div with non-breaking characters in front of it.
			_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
		},
		safeFragment = createSafeFragment( document ),
		fragmentDiv = safeFragment.appendChild( document.createElement("div") );
	
	wrapMap.optgroup = wrapMap.option;
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	jQuery.fn.extend({
		text: function( value ) {
			return jQuery.access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
			}, null, value, arguments.length );
		},
	
		wrapAll: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function(i) {
					jQuery(this).wrapAll( html.call(this, i) );
				});
			}
	
			if ( this[0] ) {
				// The elements to wrap the target around
				var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
	
				if ( this[0].parentNode ) {
					wrap.insertBefore( this[0] );
				}
	
				wrap.map(function() {
					var elem = this;
	
					while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
						elem = elem.firstChild;
					}
	
					return elem;
				}).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function(i) {
					jQuery(this).wrapInner( html.call(this, i) );
				});
			}
	
			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			});
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each(function(i) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},
	
		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		},
	
		append: function() {
			return this.domManip(arguments, true, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					this.appendChild( elem );
				}
			});
		},
	
		prepend: function() {
			return this.domManip(arguments, true, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					this.insertBefore( elem, this.firstChild );
				}
			});
		},
	
		before: function() {
			return this.domManip( arguments, false, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},
	
		after: function() {
			return this.domManip( arguments, false, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},
	
		// keepData is for internal use only--do not document
		remove: function( selector, keepData ) {
			var elem,
				i = 0;
	
			for ( ; (elem = this[i]) != null; i++ ) {
				if ( !selector || jQuery.filter( selector, [ elem ] ).length > 0 ) {
					if ( !keepData && elem.nodeType === 1 ) {
						jQuery.cleanData( getAll( elem ) );
					}
	
					if ( elem.parentNode ) {
						if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
							setGlobalEval( getAll( elem, "script" ) );
						}
						elem.parentNode.removeChild( elem );
					}
				}
			}
	
			return this;
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; (elem = this[i]) != null; i++ ) {
				// Remove element nodes and prevent memory leaks
				if ( elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem, false ) );
				}
	
				// Remove any remaining nodes
				while ( elem.firstChild ) {
					elem.removeChild( elem.firstChild );
				}
	
				// If this is a select, ensure that it displays empty (#12336)
				// Support: IE<9
				if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
					elem.options.length = 0;
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function () {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},
	
		html: function( value ) {
			return jQuery.access( this, function( value ) {
				var elem = this[0] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined ) {
					return elem.nodeType === 1 ?
						elem.innerHTML.replace( rinlinejQuery, "" ) :
						undefined;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
					( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
					!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {
	
					value = value.replace( rxhtmlTag, "<$1></$2>" );
	
					try {
						for (; i < l; i++ ) {
							// Remove element nodes and prevent memory leaks
							elem = this[i] || {};
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch(e) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function( value ) {
			var isFunc = jQuery.isFunction( value );
	
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( !isFunc && typeof value !== "string" ) {
				value = jQuery( value ).not( this ).detach();
			}
	
			return this.domManip( [ value ], true, function( elem ) {
				var next = this.nextSibling,
					parent = this.parentNode;
	
				if ( parent ) {
					jQuery( this ).remove();
					parent.insertBefore( elem, next );
				}
			});
		},
	
		detach: function( selector ) {
			return this.remove( selector, true );
		},
	
		domManip: function( args, table, callback ) {
	
			// Flatten any nested arrays
			args = core_concat.apply( [], args );
	
			var first, node, hasScripts,
				scripts, doc, fragment,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[0],
				isFunction = jQuery.isFunction( value );
	
			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[0] = value.call( this, index, table ? self.html() : undefined );
					}
					self.domManip( args, table, callback );
				});
			}
	
			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;
	
				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}
	
				if ( first ) {
					table = table && jQuery.nodeName( first, "tr" );
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;
	
					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;
	
						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );
	
							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}
	
						callback.call(
							table && jQuery.nodeName( this[i], "table" ) ?
								findOrAppend( this[i], "tbody" ) :
								this[i],
							node,
							i
						);
					}
	
					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;
	
						// Reenable scripts
						jQuery.map( scripts, restoreScript );
	
						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
	
								if ( node.src ) {
									// Hope ajax is available...
									jQuery.ajax({
										url: node.src,
										type: "GET",
										dataType: "script",
										async: false,
										global: false,
										"throws": true
									});
								} else {
									jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
								}
							}
						}
					}
	
					// Fix #11809: Avoid leaking memory
					fragment = first = null;
				}
			}
	
			return this;
		}
	});
	
	function findOrAppend( elem, tag ) {
		return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		var attr = elem.getAttributeNode("type");
		elem.type = ( attr && attr.specified ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
		if ( match ) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}
		return elem;
	}
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var elem,
			i = 0;
		for ( ; (elem = elems[i]) != null; i++ ) {
			jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
		}
	}
	
	function cloneCopyEvent( src, dest ) {
	
		if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
			return;
		}
	
		var type, i, l,
			oldData = jQuery._data( src ),
			curData = jQuery._data( dest, oldData ),
			events = oldData.events;
	
		if ( events ) {
			delete curData.handle;
			curData.events = {};
	
			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	
		// make the cloned public data object a copy from the original
		if ( curData.data ) {
			curData.data = jQuery.extend( {}, curData.data );
		}
	}
	
	function fixCloneNodeIssues( src, dest ) {
		var nodeName, e, data;
	
		// We do not need to do anything for non-Elements
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		nodeName = dest.nodeName.toLowerCase();
	
		// IE6-8 copies events bound via attachEvent when using cloneNode.
		if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
			data = jQuery._data( dest );
	
			for ( e in data.events ) {
				jQuery.removeEvent( dest, e, data.handle );
			}
	
			// Event data gets referenced instead of copied if the expando gets copied too
			dest.removeAttribute( jQuery.expando );
		}
	
		// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
		if ( nodeName === "script" && dest.text !== src.text ) {
			disableScript( dest ).text = src.text;
			restoreScript( dest );
	
		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		} else if ( nodeName === "object" ) {
			if ( dest.parentNode ) {
				dest.outerHTML = src.outerHTML;
			}
	
			// This path appears unavoidable for IE9. When cloning an object
			// element in IE9, the outerHTML strategy above is not sufficient.
			// If the src has innerHTML and the destination does not,
			// copy the src.innerHTML into the dest.innerHTML. #10324
			if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
				dest.innerHTML = src.innerHTML;
			}
	
		} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
			// IE6-8 fails to persist the checked state of a cloned checkbox
			// or radio button. Worse, IE6-7 fail to give the cloned element
			// a checked appearance if the defaultChecked value isn't also set
	
			dest.defaultChecked = dest.checked = src.checked;
	
			// IE6-7 get confused and end up setting the value of a cloned
			// checkbox/radio button to an empty string instead of "on"
			if ( dest.value !== src.value ) {
				dest.value = src.value;
			}
	
		// IE6-8 fails to return the selected option to the default selected
		// state when cloning options
		} else if ( nodeName === "option" ) {
			dest.defaultSelected = dest.selected = src.defaultSelected;
	
		// IE6-8 fails to set the defaultValue to the correct value when
		// cloning other types of input fields
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				i = 0,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone(true);
				jQuery( insert[i] )[ original ]( elems );
	
				// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
				core_push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	});
	
	function getAll( context, tag ) {
		var elems, elem,
			i = 0,
			found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :
				undefined;
	
		if ( !found ) {
			for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
				if ( !tag || jQuery.nodeName( elem, tag ) ) {
					found.push( elem );
				} else {
					jQuery.merge( found, getAll( elem, tag ) );
				}
			}
		}
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], found ) :
			found;
	}
	
	// Used in buildFragment, fixes the defaultChecked property
	function fixDefaultChecked( elem ) {
		if ( manipulation_rcheckableType.test( elem.type ) ) {
			elem.defaultChecked = elem.checked;
		}
	}
	
	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var destElements, node, clone, i, srcElements,
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
				clone = elem.cloneNode( true );
	
			// IE<=8 does not properly clone detached, unknown element nodes
			} else {
				fragmentDiv.innerHTML = elem.outerHTML;
				fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
			}
	
			if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
					(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
	
				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				// Fix all IE cloning issues
				for ( i = 0; (node = srcElements[i]) != null; ++i ) {
					// Ensure that the destination node is not null; Fixes #9587
					if ( destElements[i] ) {
						fixCloneNodeIssues( node, destElements[i] );
					}
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0; (node = srcElements[i]) != null; i++ ) {
						cloneCopyEvent( node, destElements[i] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			destElements = srcElements = node = null;
	
			// Return the cloned set
			return clone;
		},
	
		buildFragment: function( elems, context, scripts, selection ) {
			var j, elem, contains,
				tmp, tag, tbody, wrap,
				l = elems.length,
	
				// Ensure a safe fragment
				safe = createSafeFragment( context ),
	
				nodes = [],
				i = 0;
	
			for ( ; i < l; i++ ) {
				elem = elems[ i ];
	
				if ( elem || elem === 0 ) {
	
					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );
	
					// Convert html into DOM nodes
					} else {
						tmp = tmp || safe.appendChild( context.createElement("div") );
	
						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
	
						tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];
	
						// Descend through wrappers to the right content
						j = wrap[0];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}
	
						// Manually add leading whitespace removed by IE
						if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
							nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
						}
	
						// Remove IE's autoinserted <tbody> from table fragments
						if ( !jQuery.support.tbody ) {
	
							// String was a <table>, *may* have spurious <tbody>
							elem = tag === "table" && !rtbody.test( elem ) ?
								tmp.firstChild :
	
								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !rtbody.test( elem ) ?
									tmp :
									0;
	
							j = elem && elem.childNodes.length;
							while ( j-- ) {
								if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
									elem.removeChild( tbody );
								}
							}
						}
	
						jQuery.merge( nodes, tmp.childNodes );
	
						// Fix #12392 for WebKit and IE > 9
						tmp.textContent = "";
	
						// Fix #12392 for oldIE
						while ( tmp.firstChild ) {
							tmp.removeChild( tmp.firstChild );
						}
	
						// Remember the top-level container for proper cleanup
						tmp = safe.lastChild;
					}
				}
			}
	
			// Fix #11356: Clear elements from fragment
			if ( tmp ) {
				safe.removeChild( tmp );
			}
	
			// Reset defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			if ( !jQuery.support.appendChecked ) {
				jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
			}
	
			i = 0;
			while ( (elem = nodes[ i++ ]) ) {
	
				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}
	
				contains = jQuery.contains( elem.ownerDocument, elem );
	
				// Append to fragment
				tmp = getAll( safe.appendChild( elem ), "script" );
	
				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}
	
				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}
	
			tmp = null;
	
			return safe;
		},
	
		cleanData: function( elems, /* internal */ acceptData ) {
			var elem, type, id, data,
				i = 0,
				internalKey = jQuery.expando,
				cache = jQuery.cache,
				deleteExpando = jQuery.support.deleteExpando,
				special = jQuery.event.special;
	
			for ( ; (elem = elems[i]) != null; i++ ) {
	
				if ( acceptData || jQuery.acceptData( elem ) ) {
	
					id = elem[ internalKey ];
					data = id && cache[ id ];
	
					if ( data ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Remove cache only if it was not already removed by jQuery.event.remove
						if ( cache[ id ] ) {
	
							delete cache[ id ];
	
							// IE does not allow us to delete expando properties from nodes,
							// nor does it have a removeAttribute function on Document nodes;
							// we must handle all of these cases
							if ( deleteExpando ) {
								delete elem[ internalKey ];
	
							} else if ( typeof elem.removeAttribute !== core_strundefined ) {
								elem.removeAttribute( internalKey );
	
							} else {
								elem[ internalKey ] = null;
							}
	
							core_deletedIds.push( id );
						}
					}
				}
			}
		}
	});
	var iframe, getStyles, curCSS,
		ralpha = /alpha\([^)]*\)/i,
		ropacity = /opacity\s*=\s*([^)]*)/,
		rposition = /^(top|right|bottom|left)$/,
		// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rmargin = /^margin/,
		rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
		rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
		elemdisplay = { BODY: "block" },
	
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: 0,
			fontWeight: 400
		},
	
		cssExpand = [ "Top", "Right", "Bottom", "Left" ],
		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
	
	// return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {
	
		// shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}
	
		// check for vendor prefixed names
		var capName = name.charAt(0).toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}
	
		return origName;
	}
	
	function isHidden( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	}
	
	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;
	
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			values[ index ] = jQuery._data( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}
	
				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
				}
			} else {
	
				if ( !values[ index ] ) {
					hidden = isHidden( elem );
	
					if ( display && display !== "none" || !hidden ) {
						jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
					}
				}
			}
		}
	
		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend({
		css: function( name, value ) {
			return jQuery.access( this, function( elem, name, value ) {
				var len, styles,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			var bool = typeof state === "boolean";
	
			return this.each(function() {
				if ( bool ? state : isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});
	
	jQuery.extend({
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Exclude the following css properties to add px
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			// normalize float css property
			"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
	
			// gets hook for the prefixed version
			// followed by the unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// convert relative number strings (+= or -=) to relative numbers. #7345
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that NaN and null values aren't set. See: #7116
				if ( value == null || type === "number" && isNaN( value ) ) {
					return;
				}
	
				// If a number was passed in, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}
	
				// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
				// but it would mean to define eight (for every problematic property) identical functions
				if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
	
					// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
					// Fixes bug #5509
					try {
						style[ name ] = value;
					} catch(e) {}
				}
	
			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var num, val, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
	
			// gets hook for the prefixed version
			// followed by the unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			//convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Return, converting to number if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		},
	
		// A method for quickly swapping in/out CSS properties to get correct calculations
		swap: function( elem, options, callback, args ) {
			var ret, name,
				old = {};
	
			// Remember the old values, and insert the new ones
			for ( name in options ) {
				old[ name ] = elem.style[ name ];
				elem.style[ name ] = options[ name ];
			}
	
			ret = callback.apply( elem, args || [] );
	
			// Revert the old values
			for ( name in options ) {
				elem.style[ name ] = old[ name ];
			}
	
			return ret;
		}
	});
	
	// NOTE: we've included the "window" in window.getComputedStyle
	// because jsdom on node.js will break without it.
	if ( window.getComputedStyle ) {
		getStyles = function( elem ) {
			return window.getComputedStyle( elem, null );
		};
	
		curCSS = function( elem, name, _computed ) {
			var width, minWidth, maxWidth,
				computed = _computed || getStyles( elem ),
	
				// getPropertyValue is only needed for .css('filter') in IE9, see #12537
				ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
				style = elem.style;
	
			if ( computed ) {
	
				if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
					ret = jQuery.style( elem, name );
				}
	
				// A tribute to the "awesome hack by Dean Edwards"
				// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
				// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
				// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
				if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
					// Remember the original values
					width = style.width;
					minWidth = style.minWidth;
					maxWidth = style.maxWidth;
	
					// Put in the new values to get a computed value out
					style.minWidth = style.maxWidth = style.width = ret;
					ret = computed.width;
	
					// Revert the changed values
					style.width = width;
					style.minWidth = minWidth;
					style.maxWidth = maxWidth;
				}
			}
	
			return ret;
		};
	} else if ( document.documentElement.currentStyle ) {
		getStyles = function( elem ) {
			return elem.currentStyle;
		};
	
		curCSS = function( elem, name, _computed ) {
			var left, rs, rsLeft,
				computed = _computed || getStyles( elem ),
				ret = computed ? computed[ name ] : undefined,
				style = elem.style;
	
			// Avoid setting ret to empty string here
			// so we don't default to auto
			if ( ret == null && style && style[ name ] ) {
				ret = style[ name ];
			}
	
			// From the awesome hack by Dean Edwards
			// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
	
			// If we're not dealing with a regular pixel number
			// but a number that has a weird ending, we need to convert it to pixels
			// but not position css attributes, as those are proportional to the parent element instead
			// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
			if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {
	
				// Remember the original values
				left = style.left;
				rs = elem.runtimeStyle;
				rsLeft = rs && rs.left;
	
				// Put in the new values to get a computed value out
				if ( rsLeft ) {
					rs.left = elem.currentStyle.left;
				}
				style.left = name === "fontSize" ? "1em" : ret;
				ret = style.pixelLeft + "px";
	
				// Revert the changed values
				style.left = left;
				if ( rsLeft ) {
					rs.left = rsLeft;
				}
			}
	
			return ret === "" ? "auto" : ret;
		};
	}
	
	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
			// both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// at this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// at this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// at this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}
	
			// we need the check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	// Try to determine the default display value of an element
	function css_defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];
	
		if ( !display ) {
			display = actualDisplay( nodeName, doc );
	
			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {
				// Use the already-created iframe if possible
				iframe = ( iframe ||
					jQuery("<iframe frameborder='0' width='0' height='0'/>")
					.css( "cssText", "display:block !important" )
				).appendTo( doc.documentElement );
	
				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
				doc.write("<!doctype html><html><body>");
				doc.close();
	
				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}
	
			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}
	
		return display;
	}
	
	// Called ONLY from within css_defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
			display = jQuery.css( elem[0], "display" );
		elem.remove();
		return display;
	}
	
	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
					// certain elements can have dimension info if we invisibly show them
					// however, it must have a current display style that would benefit from this
					return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});
	
	if ( !jQuery.support.opacity ) {
		jQuery.cssHooks.opacity = {
			get: function( elem, computed ) {
				// IE uses filters for opacity
				return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
					( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
					computed ? "1" : "";
			},
	
			set: function( elem, value ) {
				var style = elem.style,
					currentStyle = elem.currentStyle,
					opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
					filter = currentStyle && currentStyle.filter || style.filter || "";
	
				// IE has trouble with opacity if it does not have layout
				// Force it by setting the zoom level
				style.zoom = 1;
	
				// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
				// if value === "", then remove inline opacity #12685
				if ( ( value >= 1 || value === "" ) &&
						jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
						style.removeAttribute ) {
	
					// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
					// if "filter:" is present at all, clearType is disabled, we want to avoid this
					// style.removeAttribute is IE Only, but so apparently is this code path...
					style.removeAttribute( "filter" );
	
					// if there is no filter style applied in a css rule or unset inline opacity, we are done
					if ( value === "" || currentStyle && !currentStyle.filter ) {
						return;
					}
				}
	
				// otherwise, set new filter values
				style.filter = ralpha.test( filter ) ?
					filter.replace( ralpha, opacity ) :
					filter + " " + opacity;
			}
		};
	}
	
	// These hooks cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	jQuery(function() {
		if ( !jQuery.support.reliableMarginRight ) {
			jQuery.cssHooks.marginRight = {
				get: function( elem, computed ) {
					if ( computed ) {
						// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
						// Work around by temporarily setting element display to inline-block
						return jQuery.swap( elem, { "display": "inline-block" },
							curCSS, [ elem, "marginRight" ] );
					}
				}
			};
		}
	
		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
		// getComputedStyle returns percent when specified for top/left/bottom/right
		// rather than make the css module depend on the offset module, we just check for it here
		if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
			jQuery.each( [ "top", "left" ], function( i, prop ) {
				jQuery.cssHooks[ prop ] = {
					get: function( elem, computed ) {
						if ( computed ) {
							computed = curCSS( elem, prop );
							// if curCSS returns percentage, fallback to offset
							return rnumnonpx.test( computed ) ?
								jQuery( elem ).position()[ prop ] + "px" :
								computed;
						}
					}
				};
			});
		}
	
	});
	
	if ( jQuery.expr && jQuery.expr.filters ) {
		jQuery.expr.filters.hidden = function( elem ) {
			// Support: Opera <= 12.12
			// Opera reports offsetWidths and offsetHeights less than zero on some elements
			return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
				(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
		};
	
		jQuery.expr.filters.visible = function( elem ) {
			return !jQuery.expr.filters.hidden( elem );
		};
	}
	
	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});
	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function(){
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function(){
				var type = this.type;
				// Use .is(":disabled") so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !manipulation_rcheckableType.test( type ) );
			})
			.map(function( i, elem ){
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ){
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});
	
	//Serialize an array of form elements or a set of
	//key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};
	
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});
	
		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});
	
	jQuery.fn.hover = function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	};
	var
		// Document location
		ajaxLocParts,
		ajaxLocation,
		ajax_nonce = jQuery.now(),
	
		ajax_rquery = /\?/,
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
	
		// Keep a copy of the old load method
		_load = jQuery.fn.load,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat("*");
	
	// #8138, IE may throw an exception when accessing
	// a field from window.location if document.domain has been set
	try {
		ajaxLocation = location.href;
	} catch( e ) {
		// Use the href attribute of an A element
		// since IE will modify it given document.location
		ajaxLocation = document.createElement( "a" );
		ajaxLocation.href = "";
		ajaxLocation = ajaxLocation.href;
	}
	
	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType[0] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );
	
					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var deep, key,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}
	
		var selector, response, type,
			self = this,
			off = url.indexOf(" ");
	
		if ( off >= 0 ) {
			selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,
	
				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}
	
		return this;
	};
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
		jQuery.fn[ type ] = function( fn ){
			return this.on( type, fn );
		};
	});
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});
	
	jQuery.extend({
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": window.String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var // Cross-domain detection vars
				parts,
				// Loop variable
				i,
				// URL without anti-cache param
				cacheURL,
				// Response headers as string
				responseHeadersString,
				// timeout handle
				timeoutTimer,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				transport,
				// Response headers
				responseHeaders,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;
	
			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];
	
			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
				);
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			fireGlobals = s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?
	
						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :
	
						// Otherwise add one to the end
						cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
				}
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}
	
				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Called once
				if ( state === 2 ) {
					return;
				}
	
				// State is "done" now
				state = 2;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// If successful, handle type chaining
				if ( status >= 200 && status < 300 || status === 304 ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 ) {
						isSuccess = true;
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						isSuccess = true;
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						isSuccess = ajaxConvert( s, response );
						statusText = isSuccess.state;
						success = isSuccess.data;
						error = isSuccess.error;
						isSuccess = !error;
					}
				} else {
					// We extract error from statusText
					// then normalize statusText and status for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}
	
			return jqXHR;
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		}
	});
	
	/* Handles responses to an ajax request:
	 * - sets all responseXXX fields accordingly
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
		var firstDataType, ct, finalDataType, type,
			contents = s.contents,
			dataTypes = s.dataTypes,
			responseFields = s.responseFields;
	
		// Fill responseXXX fields
		for ( type in responseFields ) {
			if ( type in responses ) {
				jqXHR[ responseFields[type] ] = responses[ type ];
			}
		}
	
		// Remove auto dataType and get content-type in the process
		while( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	// Chain conversions given the request and the original response
	function ajaxConvert( s, response ) {
		var conv2, current, conv, tmp,
			converters = {},
			i = 0,
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice(),
			prev = dataTypes[ 0 ];
	
		// Apply the dataFilter if provided
		if ( s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		// Convert to each sequential dataType, tolerating list modification
		for ( ; (current = dataTypes[++i]); ) {
	
			// There's only work to do if current dataType is non-auto
			if ( current !== "*" ) {
	
				// Convert response if prev dataType is non-auto and differs from current
				if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split(" ");
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.splice( i--, 0, current );
									}
	
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s["throws"] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
	
				// Update prev for next iteration
				prev = current;
			}
		}
	
		return { state: "success", data: response };
	}
	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});
	
	// Handle cache's special case and global
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
			s.global = false;
		}
	});
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function(s) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
	
			var script,
				head = document.head || jQuery("head")[0] || document.documentElement;
	
			return {
	
				send: function( _, callback ) {
	
					script = document.createElement("script");
	
					script.async = true;
	
					if ( s.scriptCharset ) {
						script.charset = s.scriptCharset;
					}
	
					script.src = s.url;
	
					// Attach handlers for all browsers
					script.onload = script.onreadystatechange = function( _, isAbort ) {
	
						if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
	
							// Handle memory leak in IE
							script.onload = script.onreadystatechange = null;
	
							// Remove the script
							if ( script.parentNode ) {
								script.parentNode.removeChild( script );
							}
	
							// Dereference the script
							script = null;
	
							// Callback if not abort
							if ( !isAbort ) {
								callback( 200, "success" );
							}
						}
					};
	
					// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					head.insertBefore( script, head.firstChild );
				},
	
				abort: function() {
					if ( script ) {
						script.onload( undefined, true );
					}
				}
			};
		}
	});
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;
	
				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			});
	
			// Delegate to script
			return "script";
		}
	});
	var xhrCallbacks, xhrSupported,
		xhrId = 0,
		// #5280: Internet Explorer will keep connections alive if we don't abort on unload
		xhrOnUnloadAbort = window.ActiveXObject && function() {
			// Abort all pending requests
			var key;
			for ( key in xhrCallbacks ) {
				xhrCallbacks[ key ]( undefined, true );
			}
		};
	
	// Functions to create xhrs
	function createStandardXHR() {
		try {
			return new window.XMLHttpRequest();
		} catch( e ) {}
	}
	
	function createActiveXHR() {
		try {
			return new window.ActiveXObject("Microsoft.XMLHTTP");
		} catch( e ) {}
	}
	
	// Create the request object
	// (This is still attached to ajaxSettings for backward compatibility)
	jQuery.ajaxSettings.xhr = window.ActiveXObject ?
		/* Microsoft failed to properly
		 * implement the XMLHttpRequest in IE7 (can't request local files),
		 * so we use the ActiveXObject when it is available
		 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
		 * we need a fallback.
		 */
		function() {
			return !this.isLocal && createStandardXHR() || createActiveXHR();
		} :
		// For all other browsers, use the standard XMLHttpRequest object
		createStandardXHR;
	
	// Determine support properties
	xhrSupported = jQuery.ajaxSettings.xhr();
	jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	xhrSupported = jQuery.support.ajax = !!xhrSupported;
	
	// Create transport if the browser can provide an xhr
	if ( xhrSupported ) {
	
		jQuery.ajaxTransport(function( s ) {
			// Cross domain only allowed if supported through XMLHttpRequest
			if ( !s.crossDomain || jQuery.support.cors ) {
	
				var callback;
	
				return {
					send: function( headers, complete ) {
	
						// Get a new xhr
						var handle, i,
							xhr = s.xhr();
	
						// Open the socket
						// Passing null username, generates a login popup on Opera (#2865)
						if ( s.username ) {
							xhr.open( s.type, s.url, s.async, s.username, s.password );
						} else {
							xhr.open( s.type, s.url, s.async );
						}
	
						// Apply custom fields if provided
						if ( s.xhrFields ) {
							for ( i in s.xhrFields ) {
								xhr[ i ] = s.xhrFields[ i ];
							}
						}
	
						// Override mime type if needed
						if ( s.mimeType && xhr.overrideMimeType ) {
							xhr.overrideMimeType( s.mimeType );
						}
	
						// X-Requested-With header
						// For cross-domain requests, seeing as conditions for a preflight are
						// akin to a jigsaw puzzle, we simply never set it to be sure.
						// (it can always be set on a per-request basis or even using ajaxSetup)
						// For same-domain requests, won't change header if already provided.
						if ( !s.crossDomain && !headers["X-Requested-With"] ) {
							headers["X-Requested-With"] = "XMLHttpRequest";
						}
	
						// Need an extra try/catch for cross domain requests in Firefox 3
						try {
							for ( i in headers ) {
								xhr.setRequestHeader( i, headers[ i ] );
							}
						} catch( err ) {}
	
						// Do send the request
						// This may raise an exception which is actually
						// handled in jQuery.ajax (so no try/catch here)
						xhr.send( ( s.hasContent && s.data ) || null );
	
						// Listener
						callback = function( _, isAbort ) {
							var status, responseHeaders, statusText, responses;
	
							// Firefox throws exceptions when accessing properties
							// of an xhr when a network error occurred
							// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
							try {
	
								// Was never called and is aborted or complete
								if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
	
									// Only called once
									callback = undefined;
	
									// Do not keep as active anymore
									if ( handle ) {
										xhr.onreadystatechange = jQuery.noop;
										if ( xhrOnUnloadAbort ) {
											delete xhrCallbacks[ handle ];
										}
									}
	
									// If it's an abort
									if ( isAbort ) {
										// Abort it manually if needed
										if ( xhr.readyState !== 4 ) {
											xhr.abort();
										}
									} else {
										responses = {};
										status = xhr.status;
										responseHeaders = xhr.getAllResponseHeaders();
	
										// When requesting binary data, IE6-9 will throw an exception
										// on any attempt to access responseText (#11426)
										if ( typeof xhr.responseText === "string" ) {
											responses.text = xhr.responseText;
										}
	
										// Firefox throws an exception when accessing
										// statusText for faulty cross-domain requests
										try {
											statusText = xhr.statusText;
										} catch( e ) {
											// We normalize with Webkit giving an empty statusText
											statusText = "";
										}
	
										// Filter status for non standard behaviors
	
										// If the request is local and we have data: assume a success
										// (success with no data won't get notified, that's the best we
										// can do given current implementations)
										if ( !status && s.isLocal && !s.crossDomain ) {
											status = responses.text ? 200 : 404;
										// IE - #1450: sometimes returns 1223 when it should be 204
										} else if ( status === 1223 ) {
											status = 204;
										}
									}
								}
							} catch( firefoxAccessException ) {
								if ( !isAbort ) {
									complete( -1, firefoxAccessException );
								}
							}
	
							// Call complete if needed
							if ( responses ) {
								complete( status, statusText, responses, responseHeaders );
							}
						};
	
						if ( !s.async ) {
							// if we're in sync mode we fire the callback
							callback();
						} else if ( xhr.readyState === 4 ) {
							// (IE6 & IE7) if it's in cache and has been
							// retrieved directly we need to fire the callback
							setTimeout( callback );
						} else {
							handle = ++xhrId;
							if ( xhrOnUnloadAbort ) {
								// Create the active xhrs callbacks list if needed
								// and attach the unload handler
								if ( !xhrCallbacks ) {
									xhrCallbacks = {};
									jQuery( window ).unload( xhrOnUnloadAbort );
								}
								// Add to list of active xhrs callbacks
								xhrCallbacks[ handle ] = callback;
							}
							xhr.onreadystatechange = callback;
						}
					},
	
					abort: function() {
						if ( callback ) {
							callback( undefined, true );
						}
					}
				};
			}
		});
	}
	var fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [function( prop, value ) {
				var end, unit,
					tween = this.createTween( prop, value ),
					parts = rfxnum.exec( value ),
					target = tween.cur(),
					start = +target || 0,
					scale = 1,
					maxIterations = 20;
	
				if ( parts ) {
					end = +parts[2];
					unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	
					// We need to compute starting value
					if ( unit !== "px" && start ) {
						// Iteratively approximate from a nonzero starting point
						// Prefer the current property, because this process will be trivial if it uses the same units
						// Fallback to end or a simple constant
						start = jQuery.css( tween.elem, prop, true ) || end || 1;
	
						do {
							// If previous iteration zeroed out, double until we get *something*
							// Use a string for doubling factor so we don't accidentally see scale as unchanged below
							scale = scale || ".5";
	
							// Adjust and apply
							start = start / scale;
							jQuery.style( tween.elem, prop, start + unit );
	
						// Update scale, tolerating zero or NaN from tween.cur()
						// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
						} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
					}
	
					tween.unit = unit;
					tween.start = start;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
				}
				return tween;
			}]
		};
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}
	
	function createTweens( animation, props ) {
		jQuery.each( props, function( prop, value ) {
			var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
				index = 0,
				length = collection.length;
			for ( ; index < length; index++ ) {
				if ( collection[ index ].call( animation, prop, value ) ) {
	
					// we're done with this property
					return;
				}
			}
		});
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ]);
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// if we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// resolve when we played the last frame
					// otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}
	
		createTweens( animation, props );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	function propFilter( props, specialEasing ) {
		var value, name, index, easing, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// not quite $.extend, this wont overwrite keys already present.
				// also - reusing 'index' from above because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});
	
	function defaultPrefilter( elem, props, opts ) {
		/*jshint validthis:true */
		var prop, index, length,
			value, dataShow, toggle,
			tween, hooks, oldfire,
			anim = this,
			style = elem.style,
			orig = {},
			handled = [],
			hidden = elem.nodeType && isHidden( elem );
	
		// handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always(function() {
				// doing this makes sure that the complete handler will be called
				// before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}
	
		// height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE does not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			if ( jQuery.css( elem, "display" ) === "inline" &&
					jQuery.css( elem, "float" ) === "none" ) {
	
				// inline-level elements accept inline-block;
				// block-level elements need to be inline with layout
				if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
					style.display = "inline-block";
	
				} else {
					style.zoom = 1;
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			if ( !jQuery.support.shrinkWrapBlocks ) {
				anim.always(function() {
					style.overflow = opts.overflow[ 0 ];
					style.overflowX = opts.overflow[ 1 ];
					style.overflowY = opts.overflow[ 2 ];
				});
			}
		}
	
	
		// show/hide pass
		for ( index in props ) {
			value = props[ index ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ index ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
					continue;
				}
				handled.push( index );
			}
		}
	
		length = handled.length;
		if ( length ) {
			dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
	
			// store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;
				jQuery._removeData( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( index = 0 ; index < length ; index++ ) {
				prop = handled[ index ];
				tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
				orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );
	
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}
		}
	}
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}
	
				// passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails
				// so, simple values such as "10px" are parsed to Float.
				// complex values such as "rotate(1rad)" are returned as is.
				result = jQuery.css( tween.elem, tween.prop, "" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// use step hook for back compat - use cssHook if its there - use .style if its
				// available and use plain properties where available
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Remove in 2.0 - this supports IE8's panic based approach
	// to setting things on disconnected nodes
	
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});
	
	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {
	
			// show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()
	
				// animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
					doAnimation.finish = function() {
						anim.stop( true );
					};
					// Empty animations, or finishing resolves immediately
					if ( empty || jQuery._data( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = jQuery._data( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// start the next in the queue if the last step wasn't forced
				// timers currently will call their complete callbacks, which will dequeue
				// but only if they were gotoEnd
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = jQuery._data( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// enable finishing flag on private data
				data.finish = true;
	
				// empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.cur && hooks.cur.finish ) {
					hooks.cur.finish.call( this );
				}
	
				// look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// turn off finishing flag
				delete data.finish;
			});
		}
	});
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			attrs = { height: type },
			i = 0;
	
		// if we include width, step value is 1 to do all cssExpand values,
		// if we don't include width, step value is 2 to skip over Left and Right
		includeWidth = includeWidth? 1 : 0;
		for( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	
		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p*Math.PI ) / 2;
		}
	};
	
	jQuery.timers = [];
	jQuery.fx = Tween.prototype.init;
	jQuery.fx.tick = function() {
		var timer,
			timers = jQuery.timers,
			i = 0;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		if ( timer() && jQuery.timers.push( timer ) ) {
			jQuery.fx.start();
		}
	};
	
	jQuery.fx.interval = 13;
	
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};
	
	// Back Compat <1.8 extension point
	jQuery.fx.step = {};
	
	if ( jQuery.expr && jQuery.expr.filters ) {
		jQuery.expr.filters.animated = function( elem ) {
			return jQuery.grep(jQuery.timers, function( fn ) {
				return elem === fn.elem;
			}).length;
		};
	}
	jQuery.fn.offset = function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}
	
		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;
	
		if ( !doc ) {
			return;
		}
	
		docElem = doc.documentElement;
	
		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}
	
		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	};
	
	jQuery.offset = {
	
		setOffset: function( elem, options, i ) {
			var position = jQuery.css( elem, "position" );
	
			// set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			var curElem = jQuery( elem ),
				curOffset = curElem.offset(),
				curCSSTop = jQuery.css( elem, "top" ),
				curCSSLeft = jQuery.css( elem, "left" ),
				calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
				props = {}, curPosition = {}, curTop, curLeft;
	
			// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
			} else {
				curElem.css( props );
			}
		}
	};
	
	
	jQuery.fn.extend({
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				parentOffset = { top: 0, left: 0 },
				elem = this[ 0 ];
	
			// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// we assume that getBoundingClientRect is available when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}
	
			// Subtract parent offsets and element margins
			// note: when an element has margin: auto the offsetLeft and marginLeft
			// are the same in Safari causing offset.left to incorrectly be 0
			return {
				top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
			};
		},
	
		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || document.documentElement;
				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}
				return offsetParent || document.documentElement;
			});
		}
	});
	
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
		var top = /Y/.test( prop );
	
		jQuery.fn[ method ] = function( val ) {
			return jQuery.access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? (prop in win) ? win[ prop ] :
						win.document.documentElement[ method ] :
						elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : jQuery( win ).scrollLeft(),
						top ? val : jQuery( win ).scrollTop()
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});
	
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ?
			elem :
			elem.nodeType === 9 ?
				elem.defaultView || elem.parentWindow :
				false;
	}
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return jQuery.access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
						// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});
	// Limit scope pollution from any deprecated API
	// (function() {
	
	// })();
	// Expose jQuery to the global object
	window.jQuery = window.$ = jQuery;
	
	// Expose jQuery as an AMD module, but only for AMD loaders that
	// understand the issues with loading multiple versions of jQuery
	// in a page that all might call define(). The loader will indicate
	// they have special allowances for multiple jQuery versions by
	// specifying define.amd.jQuery = true. Register as a named module,
	// since jQuery can be concatenated with other files that may use define,
	// but not use a proper concatenation script that understands anonymous
	// AMD modules. A named AMD is safest and most robust way to register.
	// Lowercase jquery is used because AMD module names are derived from
	// file names, and jQuery is normally delivered in a lowercase file name.
	// Do this after creating the global so that if an AMD module wants to call
	// noConflict to hide this version of jQuery, it will work.
	if ( "function" === "function" && __webpack_require__(14) && __webpack_require__(14).jQuery ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return jQuery; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	})( window );


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var SourceMap = __webpack_require__(3);
	var escapeHTML = __webpack_require__(24);
	var LINESTYLES = 5;
	var MAX_LINES = 100000;
	
	function sanitize(text) {
		// Escape any <>'"\ during HTML serialization
		// https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
		return escapeHTML(text);
	}
	
	module.exports = function (map, generatedCode, sources) {
		var generatedSide = [];
		var originalSide = [];
		var mappingsSide = [];
	
		function addTo(side, line, html) {
			side[line] = (side[line] || "") + html;
		}
	
		function span(text, options) {
			var attrs = {};
			if (options) {
				if (options.generated) {
					attrs["class"] = "generated-item";
				} else if (options.mapping) {
					attrs["class"] = "mapping-item";
				} else {
					attrs["class"] = "original-item";
				}
				if (typeof options.source !== "undefined") {
					attrs["class"] += " item-" + options.source + "-" + options.line + "-" + options.column;
				}
				attrs["class"] += " style-" + (options.line % LINESTYLES);
				attrs["title"] = options.name;
				attrs["data-source"] = options.source;
				attrs["data-line"] = options.line;
				attrs["data-column"] = options.column;
			}
			return "<span " + Object.keys(attrs).filter(function (key) {
				return typeof attrs[key] !== "undefined";
			}).map(function (key) {
				return key + "=\"" + attrs[key] + "\"";
			}).join(" ") + ">" + sanitize(text) + "</span>";
		}
	
		var mapSources = map.sources;
	
		var generatedLine = 1;
		var nodes = SourceMap.SourceNode.fromStringWithSourceMap(generatedCode, map).children;
		nodes.forEach(function (item, idx) {
			if (generatedLine > MAX_LINES) return;
			if (typeof item === "string") {
				item.split("\n").forEach(function (line) {
					addTo(generatedSide, generatedLine, sanitize(line));
					generatedLine++;
				});
				generatedLine--;
			} else {
				var str = item.toString();
				var source = mapSources.indexOf(item.source);
				str.split("\n").forEach(function (line) {
					addTo(generatedSide, generatedLine, span(line, {
						generated: true,
						source: source,
						line: item.line,
						column: item.column,
						name: item.name
					}));
					generatedLine++
				});
				generatedLine--;
			}
		});
	
	
		var lastGenLine = 1;
		var lastOrgSource = "";
		var mappingsLine = 1;
		map.eachMapping(function (mapping) {
			if (mapping.generatedLine > MAX_LINES) return;
			while (lastGenLine < mapping.generatedLine) {
				mappingsLine++;
				lastGenLine++;
				addTo(mappingsSide, mappingsLine, sanitize(lastGenLine + ": "));
			}
			if (typeof mapping.originalLine == "number") {
				if (lastOrgSource !== mapping.source && mapSources.length > 1) {
					addTo(mappingsSide, mappingsLine, "[" + mapping.source + "] ");
					lastOrgSource = mapping.source;
				}
				var source = mapSources.indexOf(mapping.source);
				addTo(mappingsSide, mappingsLine, span(mapping.generatedColumn + "->" + mapping.originalLine + ":" + mapping.originalColumn, {
					mapping: true,
					source: source,
					line: mapping.originalLine,
					column: mapping.originalColumn
				}));
			} else {
				addTo(mappingsSide, mappingsLine, span(mapping.generatedColumn, {
					mapping: true
				}));
			}
			addTo(mappingsSide, mappingsLine, "  ");
		});
	
	
		var originalLine = 1;
		var line = 1, column = 0, currentOutputLine = 1, targetOutputLine = -1, limited = false;
		var lastMapping = null;
		var currentSource = null;
		var exampleLines;
		var mappingsBySource = {};
		map.eachMapping(function (mapping) {
			if (typeof mapping.originalLine !== "number") return;
			if (mapping.generatedLine > MAX_LINES) return limited = true;
			if (!mappingsBySource[mapping.source]) mappingsBySource[mapping.source] = [];
			mappingsBySource[mapping.source].push(mapping);
		}, undefined, SourceMap.SourceMapConsumer.ORIGINAL_ORDER);
		Object.keys(mappingsBySource).map(function (source) {
			return [source, mappingsBySource[source][0].generatedLine];
		}).sort(function (a, b) {
			if (a[0] === "?") return 1;
			if (b[0] === "?") return -1;
			return a[1] - b[1];
		}).forEach(function (arr) {
			var source = arr[0];
			var mappings = mappingsBySource[source];
	
			if (currentSource) endFile();
			lastMapping = null;
			line = 1;
			column = 0;
			targetOutputLine = -1;
			if (mapSources.length > 1) {
				currentOutputLine++;
			}
			var startLine = mappings.map(function (mapping) {
				return mapping.generatedLine - mapping.originalLine + 1;
			}).sort(function (a, b) { return a - b });
			startLine = startLine[0];
			while (currentOutputLine < startLine) {
				originalLine++;
				currentOutputLine++;
			}
			if (mapSources.length > 1) {
				addTo(originalSide, originalLine, "<h4 class='alert alert-info'>" + sanitize(source) + "</h4>");
				originalLine++;
			}
			var exampleSource = sources[mapSources.indexOf(source)];
			if (!exampleSource === null) throw new Error("Source '" + source + "' missing");
			exampleLines = exampleSource.split("\n");
			currentSource = source;
			mappings.forEach(function (mapping, idx) {
				if (lastMapping) {
					var source = mapSources.indexOf(lastMapping.source);
					if (line < mapping.originalLine) {
						addTo(originalSide, originalLine, span(exampleLines.shift() || '', {
							original: true,
							source: source,
							line: lastMapping.originalLine,
							column: lastMapping.originalColumn
						}));
						originalLine++;
						line++; column = 0;
						currentOutputLine++;
						while (line < mapping.originalLine) {
							addTo(originalSide, originalLine, sanitize(exampleLines.shift() || ''));
							originalLine++;
							line++; column = 0;
							currentOutputLine++;
						}
						startLine = [];
						for (var i = idx; i < mappings.length && mappings[i].originalLine <= mapping.originalLine + 1; i++) {
							startLine.push(mappings[i].generatedLine - mappings[i].originalLine + mapping.originalLine);
						}
						startLine.sort(function (a, b) { return a - b });
						startLine = startLine[0];
						while (typeof startLine !== "undefined" && currentOutputLine < startLine) {
							// addTo(originalSide, originalLine, "~");
							originalLine++;
							currentOutputLine++;
						}
						if (column < mapping.originalColumn) {
							addTo(originalSide, originalLine, sanitize(shiftColumns(mapping.originalColumn - column)));
						}
					}
					if (mapping.originalColumn > column) {
						addTo(originalSide, originalLine, span(shiftColumns(mapping.originalColumn - column), {
							original: true,
							source: source,
							line: lastMapping.originalLine,
							column: lastMapping.originalColumn
						}));
					}
				} else {
					while (line < mapping.originalLine) {
						addTo(originalSide, originalLine, sanitize(exampleLines.shift() || ''));
						originalLine++;
						line++; column = 0;
					}
					if (column < mapping.originalColumn) {
						addTo(originalSide, originalLine, sanitize(shiftColumns(mapping.originalColumn - column)));
					}
				}
				lastMapping = mapping;
			});
		});
		function endFile() {
			if (lastMapping) {
				var source = mapSources.indexOf(lastMapping.source);
				addTo(originalSide, originalLine, span(exampleLines.shift() || '', {
					original: true,
					source: source,
					line: lastMapping.originalLine,
					column: lastMapping.originalColumn
				}));
			}
			if (!limited) {
				exampleLines.forEach(function (line) {
					originalLine++;
					currentOutputLine++;
					addTo(originalSide, originalLine, sanitize(line));
				});
			}
		}
		endFile();
	
		function shiftColumns(count) {
			var nextLine = exampleLines[0] || '';
			exampleLines[0] = nextLine.substr(count);
			column += count;
			return nextLine.substr(0, count);
		}
	
		var length = Math.max(originalSide.length, generatedSide.length, mappingsSide.length);
	
		var tableRows = [];
	
		for (var i = 0; i < length; i++) {
			tableRows[i] = [
				originalSide[i] || "",
				generatedSide[i] || "",
				mappingsSide[i] || ""
			].map(function (cell) {
				return "<td>" + cell + "</td>";
			});
		}
	
		var originalSideElem = "<div class='origside codeblock'><h3>original</h3><pre><code><table><tbody>";
		var generatedSideElem = "<div class='genside codeblock'><h3>generated</h3><pre><code><table><tbody>";
		var mappingsSideElem = "<div class='genside codeblock'><h3>mappings</h3><pre><code><table><tbody>";
	
		tableRows.forEach(function (row) {
			originalSideElem += "<tr>" + row[0] + "</tr>",
				generatedSideElem += "<tr>" + row[1] + "</tr>",
				mappingsSideElem += "<tr>" + row[2] + "</tr>"
		});
	
		return {
			files: generatedSideElem + "</tbody></table></code></pre></div>" +
				originalSideElem + "</tbody></table></code></pre></div>",
			mappings: mappingsSideElem + "</tbody></table></code></pre></div>"
		};
	}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var UglifyJS = __webpack_require__(18);
	
	UglifyJS.minify = function (files, options) {
	    options = UglifyJS.defaults(options, {
	        outSourceMap: null,
	        sourceRoot: null,
	        warnings: false,
	        mangle: {},
	        output: null,
	        compress: {}
	    });
	    if (typeof files == "string")
	        files = [files];
	
	    // 1. parse
	    var toplevel = null;
	    files.forEach(function (file) {
	        var code = file;
	        toplevel = UglifyJS.parse(code, {
	            filename: "?",
	            toplevel: toplevel
	        });
	    });
	
	    // 2. compress
	    if (options.compress) {
	        var compress = { warnings: options.warnings };
	        UglifyJS.merge(compress, options.compress);
	        toplevel.figure_out_scope();
	        var sq = UglifyJS.Compressor(compress);
	        toplevel = toplevel.transform(sq);
	    }
	
	    // 3. mangle
	    if (options.mangle) {
	        toplevel.figure_out_scope();
	        toplevel.compute_char_frequency();
	        toplevel.mangle_names(options.mangle);
	    }
	
	    // 4. output
	    var map = null;
	    if (options.outSourceMap) map = UglifyJS.SourceMap({
	        file: options.outSourceMap,
	        root: options.sourceRoot
	    });
	    var output = { source_map: map };
	    if (options.output) {
	        UglifyJS.merge(output, options.output);
	    }
	    var stream = UglifyJS.OutputStream(output);
	    toplevel.print(stream);
	    return {
	        code: stream + "",
	        map: map + ""
	    };
	};
	
	module.exports = UglifyJS;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	"use scrict";
	var MOZ_SourceMap = __webpack_require__(3);
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	function array_to_hash(a) {
	    var ret = Object.create(null);
	    for (var i = 0; i < a.length; ++i)
	        ret[a[i]] = true;
	    return ret;
	};
	
	function slice(a, start) {
	    return Array.prototype.slice.call(a, start || 0);
	};
	
	function characters(str) {
	    return str.split("");
	};
	
	function member(name, array) {
	    return array.indexOf(name) >= 0;
	};
	
	function find_if(func, array) {
	    for (var i = 0, n = array.length; i < n; ++i) {
	        if (func(array[i]))
	            return array[i];
	    }
	};
	
	function repeat_string(str, i) {
	    if (i <= 0) return "";
	    if (i == 1) return str;
	    var d = repeat_string(str, i >> 1);
	    d += d;
	    if (i & 1) d += str;
	    return d;
	};
	
	function configure_error_stack(fn) {
	    Object.defineProperty(fn.prototype, "stack", {
	        get: function() {
	            var err = new Error(this.message);
	            err.name = this.name;
	            try {
	                throw err;
	            } catch(e) {
	                return e.stack;
	            }
	        }
	    });
	}
	
	function DefaultsError(msg, defs) {
	    this.message = msg;
	    this.defs = defs;
	};
	DefaultsError.prototype = Object.create(Error.prototype);
	DefaultsError.prototype.constructor = DefaultsError;
	DefaultsError.prototype.name = "DefaultsError";
	configure_error_stack(DefaultsError);
	
	DefaultsError.croak = function(msg, defs) {
	    throw new DefaultsError(msg, defs);
	};
	
	function defaults(args, defs, croak) {
	    if (args === true)
	        args = {};
	    var ret = args || {};
	    if (croak) for (var i in ret) if (HOP(ret, i) && !HOP(defs, i))
	        DefaultsError.croak("`" + i + "` is not a supported option", defs);
	    for (var i in defs) if (HOP(defs, i)) {
	        ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];
	    }
	    return ret;
	};
	
	function merge(obj, ext) {
	    var count = 0;
	    for (var i in ext) if (HOP(ext, i)) {
	        obj[i] = ext[i];
	        count++;
	    }
	    return count;
	};
	
	function noop() {}
	function return_false() { return false; }
	function return_true() { return true; }
	function return_this() { return this; }
	function return_null() { return null; }
	
	var MAP = (function(){
	    function MAP(a, f, backwards) {
	        var ret = [], top = [], i;
	        function doit() {
	            var val = f(a[i], i);
	            var is_last = val instanceof Last;
	            if (is_last) val = val.v;
	            if (val instanceof AtTop) {
	                val = val.v;
	                if (val instanceof Splice) {
	                    top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);
	                } else {
	                    top.push(val);
	                }
	            }
	            else if (val !== skip) {
	                if (val instanceof Splice) {
	                    ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);
	                } else {
	                    ret.push(val);
	                }
	            }
	            return is_last;
	        };
	        if (a instanceof Array) {
	            if (backwards) {
	                for (i = a.length; --i >= 0;) if (doit()) break;
	                ret.reverse();
	                top.reverse();
	            } else {
	                for (i = 0; i < a.length; ++i) if (doit()) break;
	            }
	        }
	        else {
	            for (i in a) if (HOP(a, i)) if (doit()) break;
	        }
	        return top.concat(ret);
	    };
	    MAP.at_top = function(val) { return new AtTop(val) };
	    MAP.splice = function(val) { return new Splice(val) };
	    MAP.last = function(val) { return new Last(val) };
	    var skip = MAP.skip = {};
	    function AtTop(val) { this.v = val };
	    function Splice(val) { this.v = val };
	    function Last(val) { this.v = val };
	    return MAP;
	})();
	
	function push_uniq(array, el) {
	    if (array.indexOf(el) < 0)
	        array.push(el);
	};
	
	function string_template(text, props) {
	    return text.replace(/\{(.+?)\}/g, function(str, p){
	        return props && props[p];
	    });
	};
	
	function remove(array, el) {
	    for (var i = array.length; --i >= 0;) {
	        if (array[i] === el) array.splice(i, 1);
	    }
	};
	
	function mergeSort(array, cmp) {
	    if (array.length < 2) return array.slice();
	    function merge(a, b) {
	        var r = [], ai = 0, bi = 0, i = 0;
	        while (ai < a.length && bi < b.length) {
	            cmp(a[ai], b[bi]) <= 0
	                ? r[i++] = a[ai++]
	                : r[i++] = b[bi++];
	        }
	        if (ai < a.length) r.push.apply(r, a.slice(ai));
	        if (bi < b.length) r.push.apply(r, b.slice(bi));
	        return r;
	    };
	    function _ms(a) {
	        if (a.length <= 1)
	            return a;
	        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
	        left = _ms(left);
	        right = _ms(right);
	        return merge(left, right);
	    };
	    return _ms(array);
	};
	
	function set_difference(a, b) {
	    return a.filter(function(el){
	        return b.indexOf(el) < 0;
	    });
	};
	
	function set_intersection(a, b) {
	    return a.filter(function(el){
	        return b.indexOf(el) >= 0;
	    });
	};
	
	// this function is taken from Acorn [1], written by Marijn Haverbeke
	// [1] https://github.com/marijnh/acorn
	function makePredicate(words) {
	    if (!(words instanceof Array)) words = words.split(" ");
	    var f = "", cats = [];
	    out: for (var i = 0; i < words.length; ++i) {
	        for (var j = 0; j < cats.length; ++j)
	            if (cats[j][0].length == words[i].length) {
	                cats[j].push(words[i]);
	                continue out;
	            }
	        cats.push([words[i]]);
	    }
	    function quote(word) {
	        return JSON.stringify(word).replace(/[\u2028\u2029]/g, function(s) {
	            switch (s) {
	                case "\u2028": return "\\u2028";
	                case "\u2029": return "\\u2029";
	            }
	            return s;
	        });
	    }
	    function compareTo(arr) {
	        if (arr.length == 1) return f += "return str === " + quote(arr[0]) + ";";
	        f += "switch(str){";
	        for (var i = 0; i < arr.length; ++i) f += "case " + quote(arr[i]) + ":";
	        f += "return true}return false;";
	    }
	    // When there are more than three length categories, an outer
	    // switch first dispatches on the lengths, to save on comparisons.
	    if (cats.length > 3) {
	        cats.sort(function(a, b) {return b.length - a.length;});
	        f += "switch(str.length){";
	        for (var i = 0; i < cats.length; ++i) {
	            var cat = cats[i];
	            f += "case " + cat[0].length + ":";
	            compareTo(cat);
	        }
	        f += "}";
	        // Otherwise, simply generate a flat `switch` statement.
	    } else {
	        compareTo(words);
	    }
	    return new Function("str", f);
	};
	
	function all(array, predicate) {
	    for (var i = array.length; --i >= 0;)
	        if (!predicate(array[i]))
	            return false;
	    return true;
	};
	
	function Dictionary() {
	    this._values = Object.create(null);
	    this._size = 0;
	};
	Dictionary.prototype = {
	    set: function(key, val) {
	        if (!this.has(key)) ++this._size;
	        this._values["$" + key] = val;
	        return this;
	    },
	    add: function(key, val) {
	        if (this.has(key)) {
	            this.get(key).push(val);
	        } else {
	            this.set(key, [ val ]);
	        }
	        return this;
	    },
	    get: function(key) { return this._values["$" + key] },
	    del: function(key) {
	        if (this.has(key)) {
	            --this._size;
	            delete this._values["$" + key];
	        }
	        return this;
	    },
	    has: function(key) { return ("$" + key) in this._values },
	    each: function(f) {
	        for (var i in this._values)
	            f(this._values[i], i.substr(1));
	    },
	    size: function() {
	        return this._size;
	    },
	    map: function(f) {
	        var ret = [];
	        for (var i in this._values)
	            ret.push(f(this._values[i], i.substr(1)));
	        return ret;
	    },
	    toObject: function() { return this._values }
	};
	Dictionary.fromObject = function(obj) {
	    var dict = new Dictionary();
	    dict._size = merge(dict._values, obj);
	    return dict;
	};
	
	function HOP(obj, prop) {
	    return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	// return true if the node at the top of the stack (that means the
	// innermost node in the current output) is lexically the first in
	// a statement.
	function first_in_statement(stack) {
	    var node = stack.parent(-1);
	    for (var i = 0, p; p = stack.parent(i); i++) {
	        if (p instanceof AST_Statement && p.body === node)
	            return true;
	        if ((p instanceof AST_Seq           && p.car === node        ) ||
	            (p instanceof AST_Call          && p.expression === node && !(p instanceof AST_New) ) ||
	            (p instanceof AST_Dot           && p.expression === node ) ||
	            (p instanceof AST_Sub           && p.expression === node ) ||
	            (p instanceof AST_Conditional   && p.condition === node  ) ||
	            (p instanceof AST_Binary        && p.left === node       ) ||
	            (p instanceof AST_UnaryPostfix  && p.expression === node ))
	        {
	            node = p;
	        } else {
	            return false;
	        }
	    }
	}
	
	
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	function DEFNODE(type, props, methods, base) {
	    if (arguments.length < 4) base = AST_Node;
	    if (!props) props = [];
	    else props = props.split(/\s+/);
	    var self_props = props;
	    if (base && base.PROPS)
	        props = props.concat(base.PROPS);
	    var code = "return function AST_" + type + "(props){ if (props) { ";
	    for (var i = props.length; --i >= 0;) {
	        code += "this." + props[i] + " = props." + props[i] + ";";
	    }
	    var proto = base && new base;
	    if (proto && proto.initialize || (methods && methods.initialize))
	        code += "this.initialize();";
	    code += "}}";
	    var ctor = new Function(code)();
	    if (proto) {
	        ctor.prototype = proto;
	        ctor.BASE = base;
	    }
	    if (base) base.SUBCLASSES.push(ctor);
	    ctor.prototype.CTOR = ctor;
	    ctor.PROPS = props || null;
	    ctor.SELF_PROPS = self_props;
	    ctor.SUBCLASSES = [];
	    if (type) {
	        ctor.prototype.TYPE = ctor.TYPE = type;
	    }
	    if (methods) for (i in methods) if (HOP(methods, i)) {
	        if (/^\$/.test(i)) {
	            ctor[i.substr(1)] = methods[i];
	        } else {
	            ctor.prototype[i] = methods[i];
	        }
	    }
	    ctor.DEFMETHOD = function(name, method) {
	        this.prototype[name] = method;
	    };
	    if (true) {
	        exports["AST_" + type] = ctor;
	    }
	    return ctor;
	};
	
	var AST_Token = DEFNODE("Token", "type value line col pos endline endcol endpos nlb comments_before file raw", {
	}, null);
	
	var AST_Node = DEFNODE("Node", "start end", {
	    _clone: function(deep) {
	        if (deep) {
	            var self = this.clone();
	            return self.transform(new TreeTransformer(function(node) {
	                if (node !== self) {
	                    return node.clone(true);
	                }
	            }));
	        }
	        return new this.CTOR(this);
	    },
	    clone: function(deep) {
	        return this._clone(deep);
	    },
	    $documentation: "Base class of all AST nodes",
	    $propdoc: {
	        start: "[AST_Token] The first token of this node",
	        end: "[AST_Token] The last token of this node"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this);
	    },
	    walk: function(visitor) {
	        return this._walk(visitor); // not sure the indirection will be any help
	    }
	}, null);
	
	AST_Node.warn_function = null;
	AST_Node.warn = function(txt, props) {
	    if (AST_Node.warn_function)
	        AST_Node.warn_function(string_template(txt, props));
	};
	
	/* -----[ statements ]----- */
	
	var AST_Statement = DEFNODE("Statement", null, {
	    $documentation: "Base class of all statements",
	});
	
	var AST_Debugger = DEFNODE("Debugger", null, {
	    $documentation: "Represents a debugger statement",
	}, AST_Statement);
	
	var AST_Directive = DEFNODE("Directive", "value scope quote", {
	    $documentation: "Represents a directive, like \"use strict\";",
	    $propdoc: {
	        value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
	        scope: "[AST_Scope/S] The scope that this directive affects",
	        quote: "[string] the original quote character"
	    },
	}, AST_Statement);
	
	var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
	    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
	    $propdoc: {
	        body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.body._walk(visitor);
	        });
	    }
	}, AST_Statement);
	
	function walk_body(node, visitor) {
	    var body = node.body;
	    if (body instanceof AST_Statement) {
	        body._walk(visitor);
	    }
	    else for (var i = 0, len = body.length; i < len; i++) {
	        body[i]._walk(visitor);
	    }
	};
	
	var AST_Block = DEFNODE("Block", "body", {
	    $documentation: "A body of statements (usually bracketed)",
	    $propdoc: {
	        body: "[AST_Statement*] an array of statements"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            walk_body(this, visitor);
	        });
	    }
	}, AST_Statement);
	
	var AST_BlockStatement = DEFNODE("BlockStatement", null, {
	    $documentation: "A block statement",
	}, AST_Block);
	
	var AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
	    $documentation: "The empty statement (empty block or simply a semicolon)",
	    _walk: function(visitor) {
	        return visitor._visit(this);
	    }
	}, AST_Statement);
	
	var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
	    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
	    $propdoc: {
	        body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.body._walk(visitor);
	        });
	    }
	}, AST_Statement);
	
	var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
	    $documentation: "Statement with a label",
	    $propdoc: {
	        label: "[AST_Label] a label definition"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.label._walk(visitor);
	            this.body._walk(visitor);
	        });
	    },
	    clone: function(deep) {
	        var node = this._clone(deep);
	        if (deep) {
	            var label = node.label;
	            var def = this.label;
	            node.walk(new TreeWalker(function(node) {
	                if (node instanceof AST_LoopControl
	                    && node.label && node.label.thedef === def) {
	                    node.label.thedef = label;
	                    label.references.push(node);
	                }
	            }));
	        }
	        return node;
	    }
	}, AST_StatementWithBody);
	
	var AST_IterationStatement = DEFNODE("IterationStatement", null, {
	    $documentation: "Internal class.  All loops inherit from it."
	}, AST_StatementWithBody);
	
	var AST_DWLoop = DEFNODE("DWLoop", "condition", {
	    $documentation: "Base class for do/while statements",
	    $propdoc: {
	        condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
	    }
	}, AST_IterationStatement);
	
	var AST_Do = DEFNODE("Do", null, {
	    $documentation: "A `do` statement",
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.body._walk(visitor);
	            this.condition._walk(visitor);
	        });
	    }
	}, AST_DWLoop);
	
	var AST_While = DEFNODE("While", null, {
	    $documentation: "A `while` statement",
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.condition._walk(visitor);
	            this.body._walk(visitor);
	        });
	    }
	}, AST_DWLoop);
	
	var AST_For = DEFNODE("For", "init condition step", {
	    $documentation: "A `for` statement",
	    $propdoc: {
	        init: "[AST_Node?] the `for` initialization code, or null if empty",
	        condition: "[AST_Node?] the `for` termination clause, or null if empty",
	        step: "[AST_Node?] the `for` update clause, or null if empty"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            if (this.init) this.init._walk(visitor);
	            if (this.condition) this.condition._walk(visitor);
	            if (this.step) this.step._walk(visitor);
	            this.body._walk(visitor);
	        });
	    }
	}, AST_IterationStatement);
	
	var AST_ForIn = DEFNODE("ForIn", "init name object", {
	    $documentation: "A `for ... in` statement",
	    $propdoc: {
	        init: "[AST_Node] the `for/in` initialization code",
	        name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
	        object: "[AST_Node] the object that we're looping through"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.init._walk(visitor);
	            this.object._walk(visitor);
	            this.body._walk(visitor);
	        });
	    }
	}, AST_IterationStatement);
	
	var AST_With = DEFNODE("With", "expression", {
	    $documentation: "A `with` statement",
	    $propdoc: {
	        expression: "[AST_Node] the `with` expression"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.expression._walk(visitor);
	            this.body._walk(visitor);
	        });
	    }
	}, AST_StatementWithBody);
	
	/* -----[ scope and functions ]----- */
	
	var AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
	    $documentation: "Base class for all statements introducing a lexical scope",
	    $propdoc: {
	        directives: "[string*/S] an array of directives declared in this scope",
	        variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
	        functions: "[Object/S] like `variables`, but only lists function declarations",
	        uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
	        uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
	        parent_scope: "[AST_Scope?/S] link to the parent scope",
	        enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
	        cname: "[integer/S] current index for mangling variables (used internally by the mangler)",
	    },
	}, AST_Block);
	
	var AST_Toplevel = DEFNODE("Toplevel", "globals", {
	    $documentation: "The toplevel scope",
	    $propdoc: {
	        globals: "[Object/S] a map of name -> SymbolDef for all undeclared names",
	    },
	    wrap_enclose: function(arg_parameter_pairs) {
	        var self = this;
	        var args = [];
	        var parameters = [];
	
	        arg_parameter_pairs.forEach(function(pair) {
	            var splitAt = pair.lastIndexOf(":");
	
	            args.push(pair.substr(0, splitAt));
	            parameters.push(pair.substr(splitAt + 1));
	        });
	
	        var wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")";
	        wrapped_tl = parse(wrapped_tl);
	        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
	            if (node instanceof AST_Directive && node.value == "$ORIG") {
	                return MAP.splice(self.body);
	            }
	        }));
	        return wrapped_tl;
	    },
	    wrap_commonjs: function(name, export_all) {
	        var self = this;
	        var to_export = [];
	        if (export_all) {
	            self.figure_out_scope();
	            self.walk(new TreeWalker(function(node){
	                if (node instanceof AST_SymbolDeclaration && node.definition().global) {
	                    if (!find_if(function(n){ return n.name == node.name }, to_export))
	                        to_export.push(node);
	                }
	            }));
	        }
	        var wrapped_tl = "(function(exports, global){ '$ORIG'; '$EXPORTS'; global['" + name + "'] = exports; }({}, (function(){return this}())))";
	        wrapped_tl = parse(wrapped_tl);
	        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){
	            if (node instanceof AST_Directive) {
	                switch (node.value) {
	                  case "$ORIG":
	                    return MAP.splice(self.body);
	                  case "$EXPORTS":
	                    var body = [];
	                    to_export.forEach(function(sym){
	                        body.push(new AST_SimpleStatement({
	                            body: new AST_Assign({
	                                left: new AST_Sub({
	                                    expression: new AST_SymbolRef({ name: "exports" }),
	                                    property: new AST_String({ value: sym.name }),
	                                }),
	                                operator: "=",
	                                right: new AST_SymbolRef(sym),
	                            }),
	                        }));
	                    });
	                    return MAP.splice(body);
	                }
	            }
	        }));
	        return wrapped_tl;
	    }
	}, AST_Scope);
	
	var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
	    $documentation: "Base class for functions",
	    $propdoc: {
	        name: "[AST_SymbolDeclaration?] the name of this function",
	        argnames: "[AST_SymbolFunarg*] array of function arguments",
	        uses_arguments: "[boolean/S] tells whether this function accesses the arguments array"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            if (this.name) this.name._walk(visitor);
	            var argnames = this.argnames;
	            for (var i = 0, len = argnames.length; i < len; i++) {
	                argnames[i]._walk(visitor);
	            }
	            walk_body(this, visitor);
	        });
	    }
	}, AST_Scope);
	
	var AST_Accessor = DEFNODE("Accessor", null, {
	    $documentation: "A setter/getter function.  The `name` property is always null."
	}, AST_Lambda);
	
	var AST_Function = DEFNODE("Function", null, {
	    $documentation: "A function expression"
	}, AST_Lambda);
	
	var AST_Defun = DEFNODE("Defun", null, {
	    $documentation: "A function definition"
	}, AST_Lambda);
	
	/* -----[ JUMPS ]----- */
	
	var AST_Jump = DEFNODE("Jump", null, {
	    $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
	}, AST_Statement);
	
	var AST_Exit = DEFNODE("Exit", "value", {
	    $documentation: "Base class for “exits” (`return` and `throw`)",
	    $propdoc: {
	        value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, this.value && function(){
	            this.value._walk(visitor);
	        });
	    }
	}, AST_Jump);
	
	var AST_Return = DEFNODE("Return", null, {
	    $documentation: "A `return` statement"
	}, AST_Exit);
	
	var AST_Throw = DEFNODE("Throw", null, {
	    $documentation: "A `throw` statement"
	}, AST_Exit);
	
	var AST_LoopControl = DEFNODE("LoopControl", "label", {
	    $documentation: "Base class for loop control statements (`break` and `continue`)",
	    $propdoc: {
	        label: "[AST_LabelRef?] the label, or null if none",
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, this.label && function(){
	            this.label._walk(visitor);
	        });
	    }
	}, AST_Jump);
	
	var AST_Break = DEFNODE("Break", null, {
	    $documentation: "A `break` statement"
	}, AST_LoopControl);
	
	var AST_Continue = DEFNODE("Continue", null, {
	    $documentation: "A `continue` statement"
	}, AST_LoopControl);
	
	/* -----[ IF ]----- */
	
	var AST_If = DEFNODE("If", "condition alternative", {
	    $documentation: "A `if` statement",
	    $propdoc: {
	        condition: "[AST_Node] the `if` condition",
	        alternative: "[AST_Statement?] the `else` part, or null if not present"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.condition._walk(visitor);
	            this.body._walk(visitor);
	            if (this.alternative) this.alternative._walk(visitor);
	        });
	    }
	}, AST_StatementWithBody);
	
	/* -----[ SWITCH ]----- */
	
	var AST_Switch = DEFNODE("Switch", "expression", {
	    $documentation: "A `switch` statement",
	    $propdoc: {
	        expression: "[AST_Node] the `switch` “discriminant”"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.expression._walk(visitor);
	            walk_body(this, visitor);
	        });
	    }
	}, AST_Block);
	
	var AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
	    $documentation: "Base class for `switch` branches",
	}, AST_Block);
	
	var AST_Default = DEFNODE("Default", null, {
	    $documentation: "A `default` switch branch",
	}, AST_SwitchBranch);
	
	var AST_Case = DEFNODE("Case", "expression", {
	    $documentation: "A `case` switch branch",
	    $propdoc: {
	        expression: "[AST_Node] the `case` expression"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.expression._walk(visitor);
	            walk_body(this, visitor);
	        });
	    }
	}, AST_SwitchBranch);
	
	/* -----[ EXCEPTIONS ]----- */
	
	var AST_Try = DEFNODE("Try", "bcatch bfinally", {
	    $documentation: "A `try` statement",
	    $propdoc: {
	        bcatch: "[AST_Catch?] the catch block, or null if not present",
	        bfinally: "[AST_Finally?] the finally block, or null if not present"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            walk_body(this, visitor);
	            if (this.bcatch) this.bcatch._walk(visitor);
	            if (this.bfinally) this.bfinally._walk(visitor);
	        });
	    }
	}, AST_Block);
	
	var AST_Catch = DEFNODE("Catch", "argname", {
	    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
	    $propdoc: {
	        argname: "[AST_SymbolCatch] symbol for the exception"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.argname._walk(visitor);
	            walk_body(this, visitor);
	        });
	    }
	}, AST_Block);
	
	var AST_Finally = DEFNODE("Finally", null, {
	    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
	}, AST_Block);
	
	/* -----[ VAR/CONST ]----- */
	
	var AST_Definitions = DEFNODE("Definitions", "definitions", {
	    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
	    $propdoc: {
	        definitions: "[AST_VarDef*] array of variable definitions"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            var definitions = this.definitions;
	            for (var i = 0, len = definitions.length; i < len; i++) {
	                definitions[i]._walk(visitor);
	            }
	        });
	    }
	}, AST_Statement);
	
	var AST_Var = DEFNODE("Var", null, {
	    $documentation: "A `var` statement"
	}, AST_Definitions);
	
	var AST_Const = DEFNODE("Const", null, {
	    $documentation: "A `const` statement"
	}, AST_Definitions);
	
	var AST_VarDef = DEFNODE("VarDef", "name value", {
	    $documentation: "A variable declaration; only appears in a AST_Definitions node",
	    $propdoc: {
	        name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
	        value: "[AST_Node?] initializer, or null of there's no initializer"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.name._walk(visitor);
	            if (this.value) this.value._walk(visitor);
	        });
	    }
	});
	
	/* -----[ OTHER ]----- */
	
	var AST_Call = DEFNODE("Call", "expression args", {
	    $documentation: "A function call expression",
	    $propdoc: {
	        expression: "[AST_Node] expression to invoke as function",
	        args: "[AST_Node*] array of arguments"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.expression._walk(visitor);
	            var args = this.args;
	            for (var i = 0, len = args.length; i < len; i++) {
	                args[i]._walk(visitor);
	            }
	        });
	    }
	});
	
	var AST_New = DEFNODE("New", null, {
	    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
	}, AST_Call);
	
	var AST_Seq = DEFNODE("Seq", "car cdr", {
	    $documentation: "A sequence expression (two comma-separated expressions)",
	    $propdoc: {
	        car: "[AST_Node] first element in sequence",
	        cdr: "[AST_Node] second element in sequence"
	    },
	    $cons: function(x, y) {
	        var seq = new AST_Seq(x);
	        seq.car = x;
	        seq.cdr = y;
	        return seq;
	    },
	    $from_array: function(array) {
	        if (array.length == 0) return null;
	        if (array.length == 1) return array[0].clone();
	        var list = null;
	        for (var i = array.length; --i >= 0;) {
	            list = AST_Seq.cons(array[i], list);
	        }
	        var p = list;
	        while (p) {
	            if (p.cdr && !p.cdr.cdr) {
	                p.cdr = p.cdr.car;
	                break;
	            }
	            p = p.cdr;
	        }
	        return list;
	    },
	    to_array: function() {
	        var p = this, a = [];
	        while (p) {
	            a.push(p.car);
	            if (p.cdr && !(p.cdr instanceof AST_Seq)) {
	                a.push(p.cdr);
	                break;
	            }
	            p = p.cdr;
	        }
	        return a;
	    },
	    add: function(node) {
	        var p = this;
	        while (p) {
	            if (!(p.cdr instanceof AST_Seq)) {
	                var cell = AST_Seq.cons(p.cdr, node);
	                return p.cdr = cell;
	            }
	            p = p.cdr;
	        }
	    },
	    len: function() {
	        if (this.cdr instanceof AST_Seq) {
	            return this.cdr.len() + 1;
	        } else {
	            return 2;
	        }
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.car._walk(visitor);
	            if (this.cdr) this.cdr._walk(visitor);
	        });
	    }
	});
	
	var AST_PropAccess = DEFNODE("PropAccess", "expression property", {
	    $documentation: "Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",
	    $propdoc: {
	        expression: "[AST_Node] the “container” expression",
	        property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
	    }
	});
	
	var AST_Dot = DEFNODE("Dot", null, {
	    $documentation: "A dotted property access expression",
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.expression._walk(visitor);
	        });
	    }
	}, AST_PropAccess);
	
	var AST_Sub = DEFNODE("Sub", null, {
	    $documentation: "Index-style property access, i.e. `a[\"foo\"]`",
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.expression._walk(visitor);
	            this.property._walk(visitor);
	        });
	    }
	}, AST_PropAccess);
	
	var AST_Unary = DEFNODE("Unary", "operator expression", {
	    $documentation: "Base class for unary expressions",
	    $propdoc: {
	        operator: "[string] the operator",
	        expression: "[AST_Node] expression that this unary operator applies to"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.expression._walk(visitor);
	        });
	    }
	});
	
	var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
	    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
	}, AST_Unary);
	
	var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
	    $documentation: "Unary postfix expression, i.e. `i++`"
	}, AST_Unary);
	
	var AST_Binary = DEFNODE("Binary", "left operator right", {
	    $documentation: "Binary expression, i.e. `a + b`",
	    $propdoc: {
	        left: "[AST_Node] left-hand side expression",
	        operator: "[string] the operator",
	        right: "[AST_Node] right-hand side expression"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.left._walk(visitor);
	            this.right._walk(visitor);
	        });
	    }
	});
	
	var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
	    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
	    $propdoc: {
	        condition: "[AST_Node]",
	        consequent: "[AST_Node]",
	        alternative: "[AST_Node]"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.condition._walk(visitor);
	            this.consequent._walk(visitor);
	            this.alternative._walk(visitor);
	        });
	    }
	});
	
	var AST_Assign = DEFNODE("Assign", null, {
	    $documentation: "An assignment expression — `a = b + 5`",
	}, AST_Binary);
	
	/* -----[ LITERALS ]----- */
	
	var AST_Array = DEFNODE("Array", "elements", {
	    $documentation: "An array literal",
	    $propdoc: {
	        elements: "[AST_Node*] array of elements"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            var elements = this.elements;
	            for (var i = 0, len = elements.length; i < len; i++) {
	                elements[i]._walk(visitor);
	            }
	        });
	    }
	});
	
	var AST_Object = DEFNODE("Object", "properties", {
	    $documentation: "An object literal",
	    $propdoc: {
	        properties: "[AST_ObjectProperty*] array of properties"
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            var properties = this.properties;
	            for (var i = 0, len = properties.length; i < len; i++) {
	                properties[i]._walk(visitor);
	            }
	        });
	    }
	});
	
	var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
	    $documentation: "Base class for literal object properties",
	    $propdoc: {
	        key: "[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an AST_SymbolAccessor.",
	        value: "[AST_Node] property value.  For setters and getters this is an AST_Accessor."
	    },
	    _walk: function(visitor) {
	        return visitor._visit(this, function(){
	            this.value._walk(visitor);
	        });
	    }
	});
	
	var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", "quote", {
	    $documentation: "A key: value object property",
	    $propdoc: {
	        quote: "[string] the original quote character"
	    }
	}, AST_ObjectProperty);
	
	var AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
	    $documentation: "An object setter property",
	}, AST_ObjectProperty);
	
	var AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
	    $documentation: "An object getter property",
	}, AST_ObjectProperty);
	
	var AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
	    $propdoc: {
	        name: "[string] name of this symbol",
	        scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
	        thedef: "[SymbolDef/S] the definition of this symbol"
	    },
	    $documentation: "Base class for all symbols",
	});
	
	var AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
	    $documentation: "The name of a property accessor (setter/getter function)"
	}, AST_Symbol);
	
	var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
	    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
	}, AST_Symbol);
	
	var AST_SymbolVar = DEFNODE("SymbolVar", null, {
	    $documentation: "Symbol defining a variable",
	}, AST_SymbolDeclaration);
	
	var AST_SymbolConst = DEFNODE("SymbolConst", null, {
	    $documentation: "A constant declaration"
	}, AST_SymbolDeclaration);
	
	var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
	    $documentation: "Symbol naming a function argument",
	}, AST_SymbolVar);
	
	var AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
	    $documentation: "Symbol defining a function",
	}, AST_SymbolDeclaration);
	
	var AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
	    $documentation: "Symbol naming a function expression",
	}, AST_SymbolDeclaration);
	
	var AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
	    $documentation: "Symbol naming the exception in catch",
	}, AST_SymbolDeclaration);
	
	var AST_Label = DEFNODE("Label", "references", {
	    $documentation: "Symbol naming a label (declaration)",
	    $propdoc: {
	        references: "[AST_LoopControl*] a list of nodes referring to this label"
	    },
	    initialize: function() {
	        this.references = [];
	        this.thedef = this;
	    }
	}, AST_Symbol);
	
	var AST_SymbolRef = DEFNODE("SymbolRef", null, {
	    $documentation: "Reference to some symbol (not definition/declaration)",
	}, AST_Symbol);
	
	var AST_LabelRef = DEFNODE("LabelRef", null, {
	    $documentation: "Reference to a label symbol",
	}, AST_Symbol);
	
	var AST_This = DEFNODE("This", null, {
	    $documentation: "The `this` symbol",
	}, AST_Symbol);
	
	var AST_Constant = DEFNODE("Constant", null, {
	    $documentation: "Base class for all constants",
	    getValue: function() {
	        return this.value;
	    }
	});
	
	var AST_String = DEFNODE("String", "value quote", {
	    $documentation: "A string literal",
	    $propdoc: {
	        value: "[string] the contents of this string",
	        quote: "[string] the original quote character"
	    }
	}, AST_Constant);
	
	var AST_Number = DEFNODE("Number", "value literal", {
	    $documentation: "A number literal",
	    $propdoc: {
	        value: "[number] the numeric value",
	        literal: "[string] numeric value as string (optional)"
	    }
	}, AST_Constant);
	
	var AST_RegExp = DEFNODE("RegExp", "value", {
	    $documentation: "A regexp literal",
	    $propdoc: {
	        value: "[RegExp] the actual regexp"
	    }
	}, AST_Constant);
	
	var AST_Atom = DEFNODE("Atom", null, {
	    $documentation: "Base class for atoms",
	}, AST_Constant);
	
	var AST_Null = DEFNODE("Null", null, {
	    $documentation: "The `null` atom",
	    value: null
	}, AST_Atom);
	
	var AST_NaN = DEFNODE("NaN", null, {
	    $documentation: "The impossible value",
	    value: 0/0
	}, AST_Atom);
	
	var AST_Undefined = DEFNODE("Undefined", null, {
	    $documentation: "The `undefined` value",
	    value: (function(){}())
	}, AST_Atom);
	
	var AST_Hole = DEFNODE("Hole", null, {
	    $documentation: "A hole in an array",
	    value: (function(){}())
	}, AST_Atom);
	
	var AST_Infinity = DEFNODE("Infinity", null, {
	    $documentation: "The `Infinity` value",
	    value: 1/0
	}, AST_Atom);
	
	var AST_Boolean = DEFNODE("Boolean", null, {
	    $documentation: "Base class for booleans",
	}, AST_Atom);
	
	var AST_False = DEFNODE("False", null, {
	    $documentation: "The `false` atom",
	    value: false
	}, AST_Boolean);
	
	var AST_True = DEFNODE("True", null, {
	    $documentation: "The `true` atom",
	    value: true
	}, AST_Boolean);
	
	/* -----[ TreeWalker ]----- */
	
	function TreeWalker(callback) {
	    this.visit = callback;
	    this.stack = [];
	    this.directives = Object.create(null);
	};
	TreeWalker.prototype = {
	    _visit: function(node, descend) {
	        this.push(node);
	        var ret = this.visit(node, descend ? function(){
	            descend.call(node);
	        } : noop);
	        if (!ret && descend) {
	            descend.call(node);
	        }
	        this.pop(node);
	        return ret;
	    },
	    parent: function(n) {
	        return this.stack[this.stack.length - 2 - (n || 0)];
	    },
	    push: function (node) {
	        if (node instanceof AST_Lambda) {
	            this.directives = Object.create(this.directives);
	        } else if (node instanceof AST_Directive && !this.directives[node.value]) {
	            this.directives[node.value] = node;
	        }
	        this.stack.push(node);
	    },
	    pop: function(node) {
	        this.stack.pop();
	        if (node instanceof AST_Lambda) {
	            this.directives = Object.getPrototypeOf(this.directives);
	        }
	    },
	    self: function() {
	        return this.stack[this.stack.length - 1];
	    },
	    find_parent: function(type) {
	        var stack = this.stack;
	        for (var i = stack.length; --i >= 0;) {
	            var x = stack[i];
	            if (x instanceof type) return x;
	        }
	    },
	    has_directive: function(type) {
	        var dir = this.directives[type];
	        if (dir) return dir;
	        var node = this.stack[this.stack.length - 1];
	        if (node instanceof AST_Scope) {
	            for (var i = 0; i < node.body.length; ++i) {
	                var st = node.body[i];
	                if (!(st instanceof AST_Directive)) break;
	                if (st.value == type) return st;
	            }
	        }
	    },
	    in_boolean_context: function() {
	        var stack = this.stack;
	        var i = stack.length, self = stack[--i];
	        while (i > 0) {
	            var p = stack[--i];
	            if ((p instanceof AST_If           && p.condition === self) ||
	                (p instanceof AST_Conditional  && p.condition === self) ||
	                (p instanceof AST_DWLoop       && p.condition === self) ||
	                (p instanceof AST_For          && p.condition === self) ||
	                (p instanceof AST_UnaryPrefix  && p.operator == "!" && p.expression === self))
	            {
	                return true;
	            }
	            if (!(p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||")))
	                return false;
	            self = p;
	        }
	    },
	    loopcontrol_target: function(node) {
	        var stack = this.stack;
	        if (node.label) for (var i = stack.length; --i >= 0;) {
	            var x = stack[i];
	            if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)
	                return x.body;
	        } else for (var i = stack.length; --i >= 0;) {
	            var x = stack[i];
	            if (x instanceof AST_IterationStatement
	                || node instanceof AST_Break && x instanceof AST_Switch)
	                return x;
	        }
	    }
	};
	
	
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	var KEYWORDS = 'break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with';
	var KEYWORDS_ATOM = 'false null true';
	var RESERVED_WORDS = 'abstract boolean byte char class double enum export extends final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield'
	    + " " + KEYWORDS_ATOM + " " + KEYWORDS;
	var KEYWORDS_BEFORE_EXPRESSION = 'return new delete throw else case';
	
	KEYWORDS = makePredicate(KEYWORDS);
	RESERVED_WORDS = makePredicate(RESERVED_WORDS);
	KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
	KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
	
	var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));
	
	var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
	var RE_OCT_NUMBER = /^0[0-7]+$/;
	
	var OPERATORS = makePredicate([
	    "in",
	    "instanceof",
	    "typeof",
	    "new",
	    "void",
	    "delete",
	    "++",
	    "--",
	    "+",
	    "-",
	    "!",
	    "~",
	    "&",
	    "|",
	    "^",
	    "*",
	    "/",
	    "%",
	    ">>",
	    "<<",
	    ">>>",
	    "<",
	    ">",
	    "<=",
	    ">=",
	    "==",
	    "===",
	    "!=",
	    "!==",
	    "?",
	    "=",
	    "+=",
	    "-=",
	    "/=",
	    "*=",
	    "%=",
	    ">>=",
	    "<<=",
	    ">>>=",
	    "|=",
	    "^=",
	    "&=",
	    "&&",
	    "||"
	]);
	
	var WHITESPACE_CHARS = makePredicate(characters(" \u00a0\n\r\t\f\u000b\u200b\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\uFEFF"));
	
	var NEWLINE_CHARS = makePredicate(characters("\n\r\u2028\u2029"));
	
	var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,;:"));
	
	var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
	
	var REGEXP_MODIFIERS = makePredicate(characters("gmsiy"));
	
	/* -----[ Tokenizer ]----- */
	
	// regexps adapted from http://xregexp.com/plugins/#unicode
	var UNICODE = {
	    letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
	    digit: new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]"),
	    non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
	    space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
	    connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
	};
	
	function is_letter(code) {
	    return (code >= 97 && code <= 122)
	        || (code >= 65 && code <= 90)
	        || (code >= 0xaa && UNICODE.letter.test(String.fromCharCode(code)));
	};
	
	function is_digit(code) {
	    return code >= 48 && code <= 57;
	};
	
	function is_alphanumeric_char(code) {
	    return is_digit(code) || is_letter(code);
	};
	
	function is_unicode_digit(code) {
	    return UNICODE.digit.test(String.fromCharCode(code));
	}
	
	function is_unicode_combining_mark(ch) {
	    return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);
	};
	
	function is_unicode_connector_punctuation(ch) {
	    return UNICODE.connector_punctuation.test(ch);
	};
	
	function is_identifier(name) {
	    return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);
	};
	
	function is_identifier_start(code) {
	    return code == 36 || code == 95 || is_letter(code);
	};
	
	function is_identifier_char(ch) {
	    var code = ch.charCodeAt(0);
	    return is_identifier_start(code)
	        || is_digit(code)
	        || code == 8204 // \u200c: zero-width non-joiner <ZWNJ>
	        || code == 8205 // \u200d: zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)
	        || is_unicode_combining_mark(ch)
	        || is_unicode_connector_punctuation(ch)
	        || is_unicode_digit(code)
	    ;
	};
	
	function is_identifier_string(str){
	    return /^[a-z_$][a-z0-9_$]*$/i.test(str);
	};
	
	function parse_js_number(num) {
	    if (RE_HEX_NUMBER.test(num)) {
	        return parseInt(num.substr(2), 16);
	    } else if (RE_OCT_NUMBER.test(num)) {
	        return parseInt(num.substr(1), 8);
	    } else {
	        var val = parseFloat(num);
	        if (val == num) return val;
	    }
	};
	
	function JS_Parse_Error(message, filename, line, col, pos) {
	    this.message = message;
	    this.filename = filename;
	    this.line = line;
	    this.col = col;
	    this.pos = pos;
	};
	JS_Parse_Error.prototype = Object.create(Error.prototype);
	JS_Parse_Error.prototype.constructor = JS_Parse_Error;
	JS_Parse_Error.prototype.name = "SyntaxError";
	configure_error_stack(JS_Parse_Error);
	
	function js_error(message, filename, line, col, pos) {
	    throw new JS_Parse_Error(message, filename, line, col, pos);
	};
	
	function is_token(token, type, val) {
	    return token.type == type && (val == null || token.value == val);
	};
	
	var EX_EOF = {};
	
	function tokenizer($TEXT, filename, html5_comments, shebang) {
	
	    var S = {
	        text            : $TEXT,
	        filename        : filename,
	        pos             : 0,
	        tokpos          : 0,
	        line            : 1,
	        tokline         : 0,
	        col             : 0,
	        tokcol          : 0,
	        newline_before  : false,
	        regex_allowed   : false,
	        comments_before : [],
	        directives      : {},
	        directive_stack : []
	    };
	
	    function peek() { return S.text.charAt(S.pos); };
	
	    function next(signal_eof, in_string) {
	        var ch = S.text.charAt(S.pos++);
	        if (signal_eof && !ch)
	            throw EX_EOF;
	        if (NEWLINE_CHARS(ch)) {
	            S.newline_before = S.newline_before || !in_string;
	            ++S.line;
	            S.col = 0;
	            if (!in_string && ch == "\r" && peek() == "\n") {
	                // treat a \r\n sequence as a single \n
	                ++S.pos;
	                ch = "\n";
	            }
	        } else {
	            ++S.col;
	        }
	        return ch;
	    };
	
	    function forward(i) {
	        while (i-- > 0) next();
	    };
	
	    function looking_at(str) {
	        return S.text.substr(S.pos, str.length) == str;
	    };
	
	    function find_eol() {
	        var text = S.text;
	        for (var i = S.pos, n = S.text.length; i < n; ++i) {
	            var ch = text[i];
	            if (NEWLINE_CHARS(ch))
	                return i;
	        }
	        return -1;
	    };
	
	    function find(what, signal_eof) {
	        var pos = S.text.indexOf(what, S.pos);
	        if (signal_eof && pos == -1) throw EX_EOF;
	        return pos;
	    };
	
	    function start_token() {
	        S.tokline = S.line;
	        S.tokcol = S.col;
	        S.tokpos = S.pos;
	    };
	
	    var prev_was_dot = false;
	    function token(type, value, is_comment) {
	        S.regex_allowed = ((type == "operator" && !UNARY_POSTFIX(value)) ||
	                           (type == "keyword" && KEYWORDS_BEFORE_EXPRESSION(value)) ||
	                           (type == "punc" && PUNC_BEFORE_EXPRESSION(value)));
	        if (type == "punc" && value == ".") {
	            prev_was_dot = true;
	        } else if (!is_comment) {
	            prev_was_dot = false;
	        }
	        var ret = {
	            type    : type,
	            value   : value,
	            line    : S.tokline,
	            col     : S.tokcol,
	            pos     : S.tokpos,
	            endline : S.line,
	            endcol  : S.col,
	            endpos  : S.pos,
	            nlb     : S.newline_before,
	            file    : filename
	        };
	        if (/^(?:num|string|regexp)$/i.test(type)) {
	            ret.raw = $TEXT.substring(ret.pos, ret.endpos);
	        }
	        if (!is_comment) {
	            ret.comments_before = S.comments_before;
	            S.comments_before = [];
	            // make note of any newlines in the comments that came before
	            for (var i = 0, len = ret.comments_before.length; i < len; i++) {
	                ret.nlb = ret.nlb || ret.comments_before[i].nlb;
	            }
	        }
	        S.newline_before = false;
	        return new AST_Token(ret);
	    };
	
	    function skip_whitespace() {
	        while (WHITESPACE_CHARS(peek()))
	            next();
	    };
	
	    function read_while(pred) {
	        var ret = "", ch, i = 0;
	        while ((ch = peek()) && pred(ch, i++))
	            ret += next();
	        return ret;
	    };
	
	    function parse_error(err) {
	        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
	    };
	
	    function read_num(prefix) {
	        var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".";
	        var num = read_while(function(ch, i){
	            var code = ch.charCodeAt(0);
	            switch (code) {
	              case 120: case 88: // xX
	                return has_x ? false : (has_x = true);
	              case 101: case 69: // eE
	                return has_x ? true : has_e ? false : (has_e = after_e = true);
	              case 45: // -
	                return after_e || (i == 0 && !prefix);
	              case 43: // +
	                return after_e;
	              case (after_e = false, 46): // .
	                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;
	            }
	            return is_alphanumeric_char(code);
	        });
	        if (prefix) num = prefix + num;
	        if (RE_OCT_NUMBER.test(num) && next_token.has_directive("use strict")) {
	            parse_error("Legacy octal literals are not allowed in strict mode");
	        }
	        var valid = parse_js_number(num);
	        if (!isNaN(valid)) {
	            return token("num", valid);
	        } else {
	            parse_error("Invalid syntax: " + num);
	        }
	    };
	
	    function read_escaped_char(in_string) {
	        var ch = next(true, in_string);
	        switch (ch.charCodeAt(0)) {
	          case 110 : return "\n";
	          case 114 : return "\r";
	          case 116 : return "\t";
	          case 98  : return "\b";
	          case 118 : return "\u000b"; // \v
	          case 102 : return "\f";
	          case 120 : return String.fromCharCode(hex_bytes(2)); // \x
	          case 117 : return String.fromCharCode(hex_bytes(4)); // \u
	          case 10  : return ""; // newline
	          case 13  :            // \r
	            if (peek() == "\n") { // DOS newline
	                next(true, in_string);
	                return "";
	            }
	        }
	        if (ch >= "0" && ch <= "7")
	            return read_octal_escape_sequence(ch);
	        return ch;
	    };
	
	    function read_octal_escape_sequence(ch) {
	        // Read
	        var p = peek();
	        if (p >= "0" && p <= "7") {
	            ch += next(true);
	            if (ch[0] <= "3" && (p = peek()) >= "0" && p <= "7")
	                ch += next(true);
	        }
	
	        // Parse
	        if (ch === "0") return "\0";
	        if (ch.length > 0 && next_token.has_directive("use strict"))
	            parse_error("Legacy octal escape sequences are not allowed in strict mode");
	        return String.fromCharCode(parseInt(ch, 8));
	    }
	
	    function hex_bytes(n) {
	        var num = 0;
	        for (; n > 0; --n) {
	            var digit = parseInt(next(true), 16);
	            if (isNaN(digit))
	                parse_error("Invalid hex-character pattern in string");
	            num = (num << 4) | digit;
	        }
	        return num;
	    };
	
	    var read_string = with_eof_error("Unterminated string constant", function(quote_char){
	        var quote = next(), ret = "";
	        for (;;) {
	            var ch = next(true, true);
	            if (ch == "\\") ch = read_escaped_char(true);
	            else if (NEWLINE_CHARS(ch)) parse_error("Unterminated string constant");
	            else if (ch == quote) break;
	            ret += ch;
	        }
	        var tok = token("string", ret);
	        tok.quote = quote_char;
	        return tok;
	    });
	
	    function skip_line_comment(type) {
	        var regex_allowed = S.regex_allowed;
	        var i = find_eol(), ret;
	        if (i == -1) {
	            ret = S.text.substr(S.pos);
	            S.pos = S.text.length;
	        } else {
	            ret = S.text.substring(S.pos, i);
	            S.pos = i;
	        }
	        S.col = S.tokcol + (S.pos - S.tokpos);
	        S.comments_before.push(token(type, ret, true));
	        S.regex_allowed = regex_allowed;
	        return next_token;
	    };
	
	    var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function(){
	        var regex_allowed = S.regex_allowed;
	        var i = find("*/", true);
	        var text = S.text.substring(S.pos, i).replace(/\r\n|\r|\u2028|\u2029/g, '\n');
	        // update stream position
	        forward(text.length /* doesn't count \r\n as 2 char while S.pos - i does */ + 2);
	        S.comments_before.push(token("comment2", text, true));
	        S.regex_allowed = regex_allowed;
	        return next_token;
	    });
	
	    function read_name() {
	        var backslash = false, name = "", ch, escaped = false, hex;
	        while ((ch = peek()) != null) {
	            if (!backslash) {
	                if (ch == "\\") escaped = backslash = true, next();
	                else if (is_identifier_char(ch)) name += next();
	                else break;
	            }
	            else {
	                if (ch != "u") parse_error("Expecting UnicodeEscapeSequence -- uXXXX");
	                ch = read_escaped_char();
	                if (!is_identifier_char(ch)) parse_error("Unicode char: " + ch.charCodeAt(0) + " is not valid in identifier");
	                name += ch;
	                backslash = false;
	            }
	        }
	        if (KEYWORDS(name) && escaped) {
	            hex = name.charCodeAt(0).toString(16).toUpperCase();
	            name = "\\u" + "0000".substr(hex.length) + hex + name.slice(1);
	        }
	        return name;
	    };
	
	    var read_regexp = with_eof_error("Unterminated regular expression", function(regexp){
	        var prev_backslash = false, ch, in_class = false;
	        while ((ch = next(true))) if (NEWLINE_CHARS(ch)) {
	            parse_error("Unexpected line terminator");
	        } else if (prev_backslash) {
	            regexp += "\\" + ch;
	            prev_backslash = false;
	        } else if (ch == "[") {
	            in_class = true;
	            regexp += ch;
	        } else if (ch == "]" && in_class) {
	            in_class = false;
	            regexp += ch;
	        } else if (ch == "/" && !in_class) {
	            break;
	        } else if (ch == "\\") {
	            prev_backslash = true;
	        } else {
	            regexp += ch;
	        }
	        var mods = read_name();
	        try {
	          return token("regexp", new RegExp(regexp, mods));
	        } catch(e) {
	          parse_error(e.message);
	        }
	    });
	
	    function read_operator(prefix) {
	        function grow(op) {
	            if (!peek()) return op;
	            var bigger = op + peek();
	            if (OPERATORS(bigger)) {
	                next();
	                return grow(bigger);
	            } else {
	                return op;
	            }
	        };
	        return token("operator", grow(prefix || next()));
	    };
	
	    function handle_slash() {
	        next();
	        switch (peek()) {
	          case "/":
	            next();
	            return skip_line_comment("comment1");
	          case "*":
	            next();
	            return skip_multiline_comment();
	        }
	        return S.regex_allowed ? read_regexp("") : read_operator("/");
	    };
	
	    function handle_dot() {
	        next();
	        return is_digit(peek().charCodeAt(0))
	            ? read_num(".")
	            : token("punc", ".");
	    };
	
	    function read_word() {
	        var word = read_name();
	        if (prev_was_dot) return token("name", word);
	        return KEYWORDS_ATOM(word) ? token("atom", word)
	            : !KEYWORDS(word) ? token("name", word)
	            : OPERATORS(word) ? token("operator", word)
	            : token("keyword", word);
	    };
	
	    function with_eof_error(eof_error, cont) {
	        return function(x) {
	            try {
	                return cont(x);
	            } catch(ex) {
	                if (ex === EX_EOF) parse_error(eof_error);
	                else throw ex;
	            }
	        };
	    };
	
	    function next_token(force_regexp) {
	        if (force_regexp != null)
	            return read_regexp(force_regexp);
	        if (shebang && S.pos == 0 && looking_at("#!")) {
	            start_token();
	            forward(2);
	            skip_line_comment("comment5");
	        }
	        for (;;) {
	            skip_whitespace();
	            start_token();
	            if (html5_comments) {
	                if (looking_at("<!--")) {
	                    forward(4);
	                    skip_line_comment("comment3");
	                    continue;
	                }
	                if (looking_at("-->") && S.newline_before) {
	                    forward(3);
	                    skip_line_comment("comment4");
	                    continue;
	                }
	            }
	            var ch = peek();
	            if (!ch) return token("eof");
	            var code = ch.charCodeAt(0);
	            switch (code) {
	              case 34: case 39: return read_string(ch);
	              case 46: return handle_dot();
	              case 47: {
	                  var tok = handle_slash();
	                  if (tok === next_token) continue;
	                  return tok;
	              }
	            }
	            if (is_digit(code)) return read_num();
	            if (PUNC_CHARS(ch)) return token("punc", next());
	            if (OPERATOR_CHARS(ch)) return read_operator();
	            if (code == 92 || is_identifier_start(code)) return read_word();
	            break;
	        }
	        parse_error("Unexpected character '" + ch + "'");
	    };
	
	    next_token.context = function(nc) {
	        if (nc) S = nc;
	        return S;
	    };
	
	    next_token.add_directive = function(directive) {
	        S.directive_stack[S.directive_stack.length - 1].push(directive);
	
	        if (S.directives[directive] === undefined) {
	            S.directives[directive] = 1;
	        } else {
	            S.directives[directive]++;
	        }
	    }
	
	    next_token.push_directives_stack = function() {
	        S.directive_stack.push([]);
	    }
	
	    next_token.pop_directives_stack = function() {
	        var directives = S.directive_stack[S.directive_stack.length - 1];
	
	        for (var i = 0; i < directives.length; i++) {
	            S.directives[directives[i]]--;
	        }
	
	        S.directive_stack.pop();
	    }
	
	    next_token.has_directive = function(directive) {
	        return S.directives[directive] !== undefined &&
	            S.directives[directive] > 0;
	    }
	
	    return next_token;
	
	};
	
	/* -----[ Parser (constants) ]----- */
	
	var UNARY_PREFIX = makePredicate([
	    "typeof",
	    "void",
	    "delete",
	    "--",
	    "++",
	    "!",
	    "~",
	    "-",
	    "+"
	]);
	
	var UNARY_POSTFIX = makePredicate([ "--", "++" ]);
	
	var ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);
	
	var PRECEDENCE = (function(a, ret){
	    for (var i = 0; i < a.length; ++i) {
	        var b = a[i];
	        for (var j = 0; j < b.length; ++j) {
	            ret[b[j]] = i + 1;
	        }
	    }
	    return ret;
	})(
	    [
	        ["||"],
	        ["&&"],
	        ["|"],
	        ["^"],
	        ["&"],
	        ["==", "===", "!=", "!=="],
	        ["<", ">", "<=", ">=", "in", "instanceof"],
	        [">>", "<<", ">>>"],
	        ["+", "-"],
	        ["*", "/", "%"]
	    ],
	    {}
	);
	
	var STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);
	
	var ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);
	
	/* -----[ Parser ]----- */
	
	function parse($TEXT, options) {
	
	    options = defaults(options, {
	        bare_returns   : false,
	        cli            : false,
	        expression     : false,
	        filename       : null,
	        html5_comments : true,
	        shebang        : true,
	        strict         : false,
	        toplevel       : null,
	    });
	
	    var S = {
	        input         : (typeof $TEXT == "string"
	                         ? tokenizer($TEXT, options.filename,
	                                     options.html5_comments, options.shebang)
	                         : $TEXT),
	        token         : null,
	        prev          : null,
	        peeked        : null,
	        in_function   : 0,
	        in_directives : true,
	        in_loop       : 0,
	        labels        : []
	    };
	
	    S.token = next();
	
	    function is(type, value) {
	        return is_token(S.token, type, value);
	    };
	
	    function peek() { return S.peeked || (S.peeked = S.input()); };
	
	    function next() {
	        S.prev = S.token;
	        if (S.peeked) {
	            S.token = S.peeked;
	            S.peeked = null;
	        } else {
	            S.token = S.input();
	        }
	        S.in_directives = S.in_directives && (
	            S.token.type == "string" || is("punc", ";")
	        );
	        return S.token;
	    };
	
	    function prev() {
	        return S.prev;
	    };
	
	    function croak(msg, line, col, pos) {
	        var ctx = S.input.context();
	        js_error(msg,
	                 ctx.filename,
	                 line != null ? line : ctx.tokline,
	                 col != null ? col : ctx.tokcol,
	                 pos != null ? pos : ctx.tokpos);
	    };
	
	    function token_error(token, msg) {
	        croak(msg, token.line, token.col);
	    };
	
	    function unexpected(token) {
	        if (token == null)
	            token = S.token;
	        token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
	    };
	
	    function expect_token(type, val) {
	        if (is(type, val)) {
	            return next();
	        }
	        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" + ", expected " + type + " «" + val + "»");
	    };
	
	    function expect(punc) { return expect_token("punc", punc); };
	
	    function can_insert_semicolon() {
	        return !options.strict && (
	            S.token.nlb || is("eof") || is("punc", "}")
	        );
	    };
	
	    function semicolon(optional) {
	        if (is("punc", ";")) next();
	        else if (!optional && !can_insert_semicolon()) unexpected();
	    };
	
	    function parenthesised() {
	        expect("(");
	        var exp = expression(true);
	        expect(")");
	        return exp;
	    };
	
	    function embed_tokens(parser) {
	        return function() {
	            var start = S.token;
	            var expr = parser();
	            var end = prev();
	            expr.start = start;
	            expr.end = end;
	            return expr;
	        };
	    };
	
	    function handle_regexp() {
	        if (is("operator", "/") || is("operator", "/=")) {
	            S.peeked = null;
	            S.token = S.input(S.token.value.substr(1)); // force regexp
	        }
	    };
	
	    var statement = embed_tokens(function() {
	        handle_regexp();
	        switch (S.token.type) {
	          case "string":
	            if (S.in_directives) {
	                var token = peek();
	                if (S.token.raw.indexOf("\\") == -1
	                    && (token.nlb
	                        || is_token(token, "eof")
	                        || is_token(token, "punc", ";")
	                        || is_token(token, "punc", "}"))) {
	                    S.input.add_directive(S.token.value);
	                } else {
	                    S.in_directives = false;
	                }
	            }
	            var dir = S.in_directives, stat = simple_statement();
	            return dir ? new AST_Directive(stat.body) : stat;
	          case "num":
	          case "regexp":
	          case "operator":
	          case "atom":
	            return simple_statement();
	
	          case "name":
	            return is_token(peek(), "punc", ":")
	                ? labeled_statement()
	                : simple_statement();
	
	          case "punc":
	            switch (S.token.value) {
	              case "{":
	                return new AST_BlockStatement({
	                    start : S.token,
	                    body  : block_(),
	                    end   : prev()
	                });
	              case "[":
	              case "(":
	                return simple_statement();
	              case ";":
	                S.in_directives = false;
	                next();
	                return new AST_EmptyStatement();
	              default:
	                unexpected();
	            }
	
	          case "keyword":
	            switch (S.token.value) {
	              case "break":
	                next();
	                return break_cont(AST_Break);
	
	              case "continue":
	                next();
	                return break_cont(AST_Continue);
	
	              case "debugger":
	                next();
	                semicolon();
	                return new AST_Debugger();
	
	              case "do":
	                next();
	                var body = in_loop(statement);
	                expect_token("keyword", "while");
	                var condition = parenthesised();
	                semicolon(true);
	                return new AST_Do({
	                    body      : body,
	                    condition : condition
	                });
	
	              case "while":
	                next();
	                return new AST_While({
	                    condition : parenthesised(),
	                    body      : in_loop(statement)
	                });
	
	              case "for":
	                next();
	                return for_();
	
	              case "function":
	                next();
	                return function_(AST_Defun);
	
	              case "if":
	                next();
	                return if_();
	
	              case "return":
	                if (S.in_function == 0 && !options.bare_returns)
	                    croak("'return' outside of function");
	                next();
	                var value = null;
	                if (is("punc", ";")) {
	                    next();
	                } else if (!can_insert_semicolon()) {
	                    value = expression(true);
	                    semicolon();
	                }
	                return new AST_Return({
	                    value: value
	                });
	
	              case "switch":
	                next();
	                return new AST_Switch({
	                    expression : parenthesised(),
	                    body       : in_loop(switch_body_)
	                });
	
	              case "throw":
	                next();
	                if (S.token.nlb)
	                    croak("Illegal newline after 'throw'");
	                var value = expression(true);
	                semicolon();
	                return new AST_Throw({
	                    value: value
	                });
	
	              case "try":
	                next();
	                return try_();
	
	              case "var":
	                next();
	                var node = var_();
	                semicolon();
	                return node;
	
	              case "const":
	                next();
	                var node = const_();
	                semicolon();
	                return node;
	
	              case "with":
	                if (S.input.has_directive("use strict")) {
	                    croak("Strict mode may not include a with statement");
	                }
	                next();
	                return new AST_With({
	                    expression : parenthesised(),
	                    body       : statement()
	                });
	            }
	        }
	        unexpected();
	    });
	
	    function labeled_statement() {
	        var label = as_symbol(AST_Label);
	        if (find_if(function(l){ return l.name == label.name }, S.labels)) {
	            // ECMA-262, 12.12: An ECMAScript program is considered
	            // syntactically incorrect if it contains a
	            // LabelledStatement that is enclosed by a
	            // LabelledStatement with the same Identifier as label.
	            croak("Label " + label.name + " defined twice");
	        }
	        expect(":");
	        S.labels.push(label);
	        var stat = statement();
	        S.labels.pop();
	        if (!(stat instanceof AST_IterationStatement)) {
	            // check for `continue` that refers to this label.
	            // those should be reported as syntax errors.
	            // https://github.com/mishoo/UglifyJS2/issues/287
	            label.references.forEach(function(ref){
	                if (ref instanceof AST_Continue) {
	                    ref = ref.label.start;
	                    croak("Continue label `" + label.name + "` refers to non-IterationStatement.",
	                          ref.line, ref.col, ref.pos);
	                }
	            });
	        }
	        return new AST_LabeledStatement({ body: stat, label: label });
	    };
	
	    function simple_statement(tmp) {
	        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });
	    };
	
	    function break_cont(type) {
	        var label = null, ldef;
	        if (!can_insert_semicolon()) {
	            label = as_symbol(AST_LabelRef, true);
	        }
	        if (label != null) {
	            ldef = find_if(function(l){ return l.name == label.name }, S.labels);
	            if (!ldef)
	                croak("Undefined label " + label.name);
	            label.thedef = ldef;
	        }
	        else if (S.in_loop == 0)
	            croak(type.TYPE + " not inside a loop or switch");
	        semicolon();
	        var stat = new type({ label: label });
	        if (ldef) ldef.references.push(stat);
	        return stat;
	    };
	
	    function for_() {
	        expect("(");
	        var init = null;
	        if (!is("punc", ";")) {
	            init = is("keyword", "var")
	                ? (next(), var_(true))
	                : expression(true, true);
	            if (is("operator", "in")) {
	                if (init instanceof AST_Var && init.definitions.length > 1)
	                    croak("Only one variable declaration allowed in for..in loop");
	                next();
	                return for_in(init);
	            }
	        }
	        return regular_for(init);
	    };
	
	    function regular_for(init) {
	        expect(";");
	        var test = is("punc", ";") ? null : expression(true);
	        expect(";");
	        var step = is("punc", ")") ? null : expression(true);
	        expect(")");
	        return new AST_For({
	            init      : init,
	            condition : test,
	            step      : step,
	            body      : in_loop(statement)
	        });
	    };
	
	    function for_in(init) {
	        var lhs = init instanceof AST_Var ? init.definitions[0].name : null;
	        var obj = expression(true);
	        expect(")");
	        return new AST_ForIn({
	            init   : init,
	            name   : lhs,
	            object : obj,
	            body   : in_loop(statement)
	        });
	    };
	
	    var function_ = function(ctor) {
	        var in_statement = ctor === AST_Defun;
	        var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
	        if (in_statement && !name)
	            unexpected();
	        expect("(");
	        return new ctor({
	            name: name,
	            argnames: (function(first, a){
	                while (!is("punc", ")")) {
	                    if (first) first = false; else expect(",");
	                    a.push(as_symbol(AST_SymbolFunarg));
	                }
	                next();
	                return a;
	            })(true, []),
	            body: (function(loop, labels){
	                ++S.in_function;
	                S.in_directives = true;
	                S.input.push_directives_stack();
	                S.in_loop = 0;
	                S.labels = [];
	                var a = block_();
	                S.input.pop_directives_stack();
	                --S.in_function;
	                S.in_loop = loop;
	                S.labels = labels;
	                return a;
	            })(S.in_loop, S.labels)
	        });
	    };
	
	    function if_() {
	        var cond = parenthesised(), body = statement(), belse = null;
	        if (is("keyword", "else")) {
	            next();
	            belse = statement();
	        }
	        return new AST_If({
	            condition   : cond,
	            body        : body,
	            alternative : belse
	        });
	    };
	
	    function block_() {
	        expect("{");
	        var a = [];
	        while (!is("punc", "}")) {
	            if (is("eof")) unexpected();
	            a.push(statement());
	        }
	        next();
	        return a;
	    };
	
	    function switch_body_() {
	        expect("{");
	        var a = [], cur = null, branch = null, tmp;
	        while (!is("punc", "}")) {
	            if (is("eof")) unexpected();
	            if (is("keyword", "case")) {
	                if (branch) branch.end = prev();
	                cur = [];
	                branch = new AST_Case({
	                    start      : (tmp = S.token, next(), tmp),
	                    expression : expression(true),
	                    body       : cur
	                });
	                a.push(branch);
	                expect(":");
	            }
	            else if (is("keyword", "default")) {
	                if (branch) branch.end = prev();
	                cur = [];
	                branch = new AST_Default({
	                    start : (tmp = S.token, next(), expect(":"), tmp),
	                    body  : cur
	                });
	                a.push(branch);
	            }
	            else {
	                if (!cur) unexpected();
	                cur.push(statement());
	            }
	        }
	        if (branch) branch.end = prev();
	        next();
	        return a;
	    };
	
	    function try_() {
	        var body = block_(), bcatch = null, bfinally = null;
	        if (is("keyword", "catch")) {
	            var start = S.token;
	            next();
	            expect("(");
	            var name = as_symbol(AST_SymbolCatch);
	            expect(")");
	            bcatch = new AST_Catch({
	                start   : start,
	                argname : name,
	                body    : block_(),
	                end     : prev()
	            });
	        }
	        if (is("keyword", "finally")) {
	            var start = S.token;
	            next();
	            bfinally = new AST_Finally({
	                start : start,
	                body  : block_(),
	                end   : prev()
	            });
	        }
	        if (!bcatch && !bfinally)
	            croak("Missing catch/finally blocks");
	        return new AST_Try({
	            body     : body,
	            bcatch   : bcatch,
	            bfinally : bfinally
	        });
	    };
	
	    function vardefs(no_in, in_const) {
	        var a = [];
	        for (;;) {
	            a.push(new AST_VarDef({
	                start : S.token,
	                name  : as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),
	                value : is("operator", "=") ? (next(), expression(false, no_in)) : null,
	                end   : prev()
	            }));
	            if (!is("punc", ","))
	                break;
	            next();
	        }
	        return a;
	    };
	
	    var var_ = function(no_in) {
	        return new AST_Var({
	            start       : prev(),
	            definitions : vardefs(no_in, false),
	            end         : prev()
	        });
	    };
	
	    var const_ = function() {
	        return new AST_Const({
	            start       : prev(),
	            definitions : vardefs(false, true),
	            end         : prev()
	        });
	    };
	
	    var new_ = function(allow_calls) {
	        var start = S.token;
	        expect_token("operator", "new");
	        var newexp = expr_atom(false), args;
	        if (is("punc", "(")) {
	            next();
	            args = expr_list(")");
	        } else {
	            args = [];
	        }
	        return subscripts(new AST_New({
	            start      : start,
	            expression : newexp,
	            args       : args,
	            end        : prev()
	        }), allow_calls);
	    };
	
	    function as_atom_node() {
	        var tok = S.token, ret;
	        switch (tok.type) {
	          case "name":
	          case "keyword":
	            ret = _make_symbol(AST_SymbolRef);
	            break;
	          case "num":
	            ret = new AST_Number({ start: tok, end: tok, value: tok.value });
	            break;
	          case "string":
	            ret = new AST_String({
	                start : tok,
	                end   : tok,
	                value : tok.value,
	                quote : tok.quote
	            });
	            break;
	          case "regexp":
	            ret = new AST_RegExp({ start: tok, end: tok, value: tok.value });
	            break;
	          case "atom":
	            switch (tok.value) {
	              case "false":
	                ret = new AST_False({ start: tok, end: tok });
	                break;
	              case "true":
	                ret = new AST_True({ start: tok, end: tok });
	                break;
	              case "null":
	                ret = new AST_Null({ start: tok, end: tok });
	                break;
	            }
	            break;
	          case "operator":
	            if (!is_identifier_string(tok.value)) {
	                croak("Invalid getter/setter name: " + tok.value,
	                    tok.line, tok.col, tok.pos);
	            }
	            ret = _make_symbol(AST_SymbolRef);
	            break;
	        }
	        next();
	        return ret;
	    };
	
	    var expr_atom = function(allow_calls) {
	        if (is("operator", "new")) {
	            return new_(allow_calls);
	        }
	        var start = S.token;
	        if (is("punc")) {
	            switch (start.value) {
	              case "(":
	                next();
	                var ex = expression(true);
	                ex.start = start;
	                ex.end = S.token;
	                expect(")");
	                return subscripts(ex, allow_calls);
	              case "[":
	                return subscripts(array_(), allow_calls);
	              case "{":
	                return subscripts(object_(), allow_calls);
	            }
	            unexpected();
	        }
	        if (is("keyword", "function")) {
	            next();
	            var func = function_(AST_Function);
	            func.start = start;
	            func.end = prev();
	            return subscripts(func, allow_calls);
	        }
	        if (ATOMIC_START_TOKEN[S.token.type]) {
	            return subscripts(as_atom_node(), allow_calls);
	        }
	        unexpected();
	    };
	
	    function expr_list(closing, allow_trailing_comma, allow_empty) {
	        var first = true, a = [];
	        while (!is("punc", closing)) {
	            if (first) first = false; else expect(",");
	            if (allow_trailing_comma && is("punc", closing)) break;
	            if (is("punc", ",") && allow_empty) {
	                a.push(new AST_Hole({ start: S.token, end: S.token }));
	            } else {
	                a.push(expression(false));
	            }
	        }
	        next();
	        return a;
	    };
	
	    var array_ = embed_tokens(function() {
	        expect("[");
	        return new AST_Array({
	            elements: expr_list("]", !options.strict, true)
	        });
	    });
	
	    var create_accessor = embed_tokens(function() {
	        return function_(AST_Accessor);
	    });
	
	    var object_ = embed_tokens(function() {
	        expect("{");
	        var first = true, a = [];
	        while (!is("punc", "}")) {
	            if (first) first = false; else expect(",");
	            if (!options.strict && is("punc", "}"))
	                // allow trailing comma
	                break;
	            var start = S.token;
	            var type = start.type;
	            var name = as_property_name();
	            if (type == "name" && !is("punc", ":")) {
	                var key = new AST_SymbolAccessor({
	                    start: S.token,
	                    name: as_property_name(),
	                    end: prev()
	                });
	                if (name == "get") {
	                    a.push(new AST_ObjectGetter({
	                        start : start,
	                        key   : key,
	                        value : create_accessor(),
	                        end   : prev()
	                    }));
	                    continue;
	                }
	                if (name == "set") {
	                    a.push(new AST_ObjectSetter({
	                        start : start,
	                        key   : key,
	                        value : create_accessor(),
	                        end   : prev()
	                    }));
	                    continue;
	                }
	            }
	            expect(":");
	            a.push(new AST_ObjectKeyVal({
	                start : start,
	                quote : start.quote,
	                key   : name,
	                value : expression(false),
	                end   : prev()
	            }));
	        }
	        next();
	        return new AST_Object({ properties: a });
	    });
	
	    function as_property_name() {
	        var tmp = S.token;
	        switch (tmp.type) {
	          case "operator":
	            if (!KEYWORDS(tmp.value)) unexpected();
	          case "num":
	          case "string":
	          case "name":
	          case "keyword":
	          case "atom":
	            next();
	            return tmp.value;
	          default:
	            unexpected();
	        }
	    };
	
	    function as_name() {
	        var tmp = S.token;
	        if (tmp.type != "name") unexpected();
	        next();
	        return tmp.value;
	    };
	
	    function _make_symbol(type) {
	        var name = S.token.value;
	        return new (name == "this" ? AST_This : type)({
	            name  : String(name),
	            start : S.token,
	            end   : S.token
	        });
	    };
	
	    function as_symbol(type, noerror) {
	        if (!is("name")) {
	            if (!noerror) croak("Name expected");
	            return null;
	        }
	        var sym = _make_symbol(type);
	        next();
	        return sym;
	    };
	
	    var subscripts = function(expr, allow_calls) {
	        var start = expr.start;
	        if (is("punc", ".")) {
	            next();
	            return subscripts(new AST_Dot({
	                start      : start,
	                expression : expr,
	                property   : as_name(),
	                end        : prev()
	            }), allow_calls);
	        }
	        if (is("punc", "[")) {
	            next();
	            var prop = expression(true);
	            expect("]");
	            return subscripts(new AST_Sub({
	                start      : start,
	                expression : expr,
	                property   : prop,
	                end        : prev()
	            }), allow_calls);
	        }
	        if (allow_calls && is("punc", "(")) {
	            next();
	            return subscripts(new AST_Call({
	                start      : start,
	                expression : expr,
	                args       : expr_list(")"),
	                end        : prev()
	            }), true);
	        }
	        return expr;
	    };
	
	    var maybe_unary = function(allow_calls) {
	        var start = S.token;
	        if (is("operator") && UNARY_PREFIX(start.value)) {
	            next();
	            handle_regexp();
	            var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));
	            ex.start = start;
	            ex.end = prev();
	            return ex;
	        }
	        var val = expr_atom(allow_calls);
	        while (is("operator") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {
	            val = make_unary(AST_UnaryPostfix, S.token, val);
	            val.start = start;
	            val.end = S.token;
	            next();
	        }
	        return val;
	    };
	
	    function make_unary(ctor, token, expr) {
	        var op = token.value;
	        if ((op == "++" || op == "--") && !is_assignable(expr))
	            croak("Invalid use of " + op + " operator", token.line, token.col, token.pos);
	        return new ctor({ operator: op, expression: expr });
	    };
	
	    var expr_op = function(left, min_prec, no_in) {
	        var op = is("operator") ? S.token.value : null;
	        if (op == "in" && no_in) op = null;
	        var prec = op != null ? PRECEDENCE[op] : null;
	        if (prec != null && prec > min_prec) {
	            next();
	            var right = expr_op(maybe_unary(true), prec, no_in);
	            return expr_op(new AST_Binary({
	                start    : left.start,
	                left     : left,
	                operator : op,
	                right    : right,
	                end      : right.end
	            }), min_prec, no_in);
	        }
	        return left;
	    };
	
	    function expr_ops(no_in) {
	        return expr_op(maybe_unary(true), 0, no_in);
	    };
	
	    var maybe_conditional = function(no_in) {
	        var start = S.token;
	        var expr = expr_ops(no_in);
	        if (is("operator", "?")) {
	            next();
	            var yes = expression(false);
	            expect(":");
	            return new AST_Conditional({
	                start       : start,
	                condition   : expr,
	                consequent  : yes,
	                alternative : expression(false, no_in),
	                end         : prev()
	            });
	        }
	        return expr;
	    };
	
	    function is_assignable(expr) {
	        if (options.cli) return true;
	        return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;
	    };
	
	    var maybe_assign = function(no_in) {
	        var start = S.token;
	        var left = maybe_conditional(no_in), val = S.token.value;
	        if (is("operator") && ASSIGNMENT(val)) {
	            if (is_assignable(left)) {
	                next();
	                return new AST_Assign({
	                    start    : start,
	                    left     : left,
	                    operator : val,
	                    right    : maybe_assign(no_in),
	                    end      : prev()
	                });
	            }
	            croak("Invalid assignment");
	        }
	        return left;
	    };
	
	    var expression = function(commas, no_in) {
	        var start = S.token;
	        var expr = maybe_assign(no_in);
	        if (commas && is("punc", ",")) {
	            next();
	            return new AST_Seq({
	                start  : start,
	                car    : expr,
	                cdr    : expression(true, no_in),
	                end    : peek()
	            });
	        }
	        return expr;
	    };
	
	    function in_loop(cont) {
	        ++S.in_loop;
	        var ret = cont();
	        --S.in_loop;
	        return ret;
	    };
	
	    if (options.expression) {
	        return expression(true);
	    }
	
	    return (function(){
	        var start = S.token;
	        var body = [];
	        S.input.push_directives_stack();
	        while (!is("eof"))
	            body.push(statement());
	        S.input.pop_directives_stack();
	        var end = prev();
	        var toplevel = options.toplevel;
	        if (toplevel) {
	            toplevel.body = toplevel.body.concat(body);
	            toplevel.end = end;
	        } else {
	            toplevel = new AST_Toplevel({ start: start, body: body, end: end });
	        }
	        return toplevel;
	    })();
	
	};
	
	
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	// Tree transformer helpers.
	
	function TreeTransformer(before, after) {
	    TreeWalker.call(this);
	    this.before = before;
	    this.after = after;
	}
	TreeTransformer.prototype = new TreeWalker;
	
	(function(undefined){
	
	    function _(node, descend) {
	        node.DEFMETHOD("transform", function(tw, in_list){
	            var x, y;
	            tw.push(this);
	            if (tw.before) x = tw.before(this, descend, in_list);
	            if (x === undefined) {
	                if (!tw.after) {
	                    x = this;
	                    descend(x, tw);
	                } else {
	                    tw.stack[tw.stack.length - 1] = x = this;
	                    descend(x, tw);
	                    y = tw.after(x, in_list);
	                    if (y !== undefined) x = y;
	                }
	            }
	            tw.pop(this);
	            return x;
	        });
	    };
	
	    function do_list(list, tw) {
	        return MAP(list, function(node){
	            return node.transform(tw, true);
	        });
	    };
	
	    _(AST_Node, noop);
	
	    _(AST_LabeledStatement, function(self, tw){
	        self.label = self.label.transform(tw);
	        self.body = self.body.transform(tw);
	    });
	
	    _(AST_SimpleStatement, function(self, tw){
	        self.body = self.body.transform(tw);
	    });
	
	    _(AST_Block, function(self, tw){
	        self.body = do_list(self.body, tw);
	    });
	
	    _(AST_DWLoop, function(self, tw){
	        self.condition = self.condition.transform(tw);
	        self.body = self.body.transform(tw);
	    });
	
	    _(AST_For, function(self, tw){
	        if (self.init) self.init = self.init.transform(tw);
	        if (self.condition) self.condition = self.condition.transform(tw);
	        if (self.step) self.step = self.step.transform(tw);
	        self.body = self.body.transform(tw);
	    });
	
	    _(AST_ForIn, function(self, tw){
	        self.init = self.init.transform(tw);
	        self.object = self.object.transform(tw);
	        self.body = self.body.transform(tw);
	    });
	
	    _(AST_With, function(self, tw){
	        self.expression = self.expression.transform(tw);
	        self.body = self.body.transform(tw);
	    });
	
	    _(AST_Exit, function(self, tw){
	        if (self.value) self.value = self.value.transform(tw);
	    });
	
	    _(AST_LoopControl, function(self, tw){
	        if (self.label) self.label = self.label.transform(tw);
	    });
	
	    _(AST_If, function(self, tw){
	        self.condition = self.condition.transform(tw);
	        self.body = self.body.transform(tw);
	        if (self.alternative) self.alternative = self.alternative.transform(tw);
	    });
	
	    _(AST_Switch, function(self, tw){
	        self.expression = self.expression.transform(tw);
	        self.body = do_list(self.body, tw);
	    });
	
	    _(AST_Case, function(self, tw){
	        self.expression = self.expression.transform(tw);
	        self.body = do_list(self.body, tw);
	    });
	
	    _(AST_Try, function(self, tw){
	        self.body = do_list(self.body, tw);
	        if (self.bcatch) self.bcatch = self.bcatch.transform(tw);
	        if (self.bfinally) self.bfinally = self.bfinally.transform(tw);
	    });
	
	    _(AST_Catch, function(self, tw){
	        self.argname = self.argname.transform(tw);
	        self.body = do_list(self.body, tw);
	    });
	
	    _(AST_Definitions, function(self, tw){
	        self.definitions = do_list(self.definitions, tw);
	    });
	
	    _(AST_VarDef, function(self, tw){
	        self.name = self.name.transform(tw);
	        if (self.value) self.value = self.value.transform(tw);
	    });
	
	    _(AST_Lambda, function(self, tw){
	        if (self.name) self.name = self.name.transform(tw);
	        self.argnames = do_list(self.argnames, tw);
	        self.body = do_list(self.body, tw);
	    });
	
	    _(AST_Call, function(self, tw){
	        self.expression = self.expression.transform(tw);
	        self.args = do_list(self.args, tw);
	    });
	
	    _(AST_Seq, function(self, tw){
	        self.car = self.car.transform(tw);
	        self.cdr = self.cdr.transform(tw);
	    });
	
	    _(AST_Dot, function(self, tw){
	        self.expression = self.expression.transform(tw);
	    });
	
	    _(AST_Sub, function(self, tw){
	        self.expression = self.expression.transform(tw);
	        self.property = self.property.transform(tw);
	    });
	
	    _(AST_Unary, function(self, tw){
	        self.expression = self.expression.transform(tw);
	    });
	
	    _(AST_Binary, function(self, tw){
	        self.left = self.left.transform(tw);
	        self.right = self.right.transform(tw);
	    });
	
	    _(AST_Conditional, function(self, tw){
	        self.condition = self.condition.transform(tw);
	        self.consequent = self.consequent.transform(tw);
	        self.alternative = self.alternative.transform(tw);
	    });
	
	    _(AST_Array, function(self, tw){
	        self.elements = do_list(self.elements, tw);
	    });
	
	    _(AST_Object, function(self, tw){
	        self.properties = do_list(self.properties, tw);
	    });
	
	    _(AST_ObjectProperty, function(self, tw){
	        self.value = self.value.transform(tw);
	    });
	
	})();
	
	
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	function SymbolDef(scope, index, orig) {
	    this.name = orig.name;
	    this.orig = [ orig ];
	    this.scope = scope;
	    this.references = [];
	    this.global = false;
	    this.mangled_name = null;
	    this.undeclared = false;
	    this.index = index;
	    this.id = SymbolDef.next_id++;
	};
	
	SymbolDef.next_id = 1;
	
	SymbolDef.prototype = {
	    unmangleable: function(options) {
	        if (!options) options = {};
	
	        return (this.global && !options.toplevel)
	            || this.undeclared
	            || (!options.eval && (this.scope.uses_eval || this.scope.uses_with))
	            || (options.keep_fnames
	                && (this.orig[0] instanceof AST_SymbolLambda
	                    || this.orig[0] instanceof AST_SymbolDefun));
	    },
	    mangle: function(options) {
	        var cache = options.cache && options.cache.props;
	        if (this.global && cache && cache.has(this.name)) {
	            this.mangled_name = cache.get(this.name);
	        }
	        else if (!this.mangled_name && !this.unmangleable(options)) {
	            var s = this.scope;
	            var sym = this.orig[0];
	            if (!options.screw_ie8 && sym instanceof AST_SymbolLambda)
	                s = s.parent_scope;
	            var def;
	            if (this.defun && (def = this.defun.variables.get(this.name))) {
	                this.mangled_name = def.mangled_name || def.name;
	            } else
	                this.mangled_name = s.next_mangled(options, this);
	            if (this.global && cache) {
	                cache.set(this.name, this.mangled_name);
	            }
	        }
	    }
	};
	
	AST_Toplevel.DEFMETHOD("figure_out_scope", function(options){
	    options = defaults(options, {
	        cache: null,
	        screw_ie8: true,
	    });
	
	    // pass 1: setup scope chaining and handle definitions
	    var self = this;
	    var scope = self.parent_scope = null;
	    var labels = new Dictionary();
	    var defun = null;
	    var tw = new TreeWalker(function(node, descend){
	        if (node instanceof AST_Catch) {
	            var save_scope = scope;
	            scope = new AST_Scope(node);
	            scope.init_scope_vars(save_scope);
	            descend();
	            scope = save_scope;
	            return true;
	        }
	        if (node instanceof AST_Scope) {
	            node.init_scope_vars(scope);
	            var save_scope = scope;
	            var save_defun = defun;
	            var save_labels = labels;
	            defun = scope = node;
	            labels = new Dictionary();
	            descend();
	            scope = save_scope;
	            defun = save_defun;
	            labels = save_labels;
	            return true;        // don't descend again in TreeWalker
	        }
	        if (node instanceof AST_LabeledStatement) {
	            var l = node.label;
	            if (labels.has(l.name)) {
	                throw new Error(string_template("Label {name} defined twice", l));
	            }
	            labels.set(l.name, l);
	            descend();
	            labels.del(l.name);
	            return true;        // no descend again
	        }
	        if (node instanceof AST_With) {
	            for (var s = scope; s; s = s.parent_scope)
	                s.uses_with = true;
	            return;
	        }
	        if (node instanceof AST_Symbol) {
	            node.scope = scope;
	        }
	        if (node instanceof AST_Label) {
	            node.thedef = node;
	            node.references = [];
	        }
	        if (node instanceof AST_SymbolLambda) {
	            defun.def_function(node);
	        }
	        else if (node instanceof AST_SymbolDefun) {
	            // Careful here, the scope where this should be defined is
	            // the parent scope.  The reason is that we enter a new
	            // scope when we encounter the AST_Defun node (which is
	            // instanceof AST_Scope) but we get to the symbol a bit
	            // later.
	            (node.scope = defun.parent_scope).def_function(node);
	        }
	        else if (node instanceof AST_SymbolVar
	            || node instanceof AST_SymbolConst) {
	            defun.def_variable(node);
	            if (defun !== scope) {
	                node.mark_enclosed(options);
	                var def = scope.find_variable(node);
	                if (node.thedef !== def) {
	                    node.thedef = def;
	                    node.reference(options);
	                }
	            }
	        }
	        else if (node instanceof AST_SymbolCatch) {
	            scope.def_variable(node).defun = defun;
	        }
	        else if (node instanceof AST_LabelRef) {
	            var sym = labels.get(node.name);
	            if (!sym) throw new Error(string_template("Undefined label {name} [{line},{col}]", {
	                name: node.name,
	                line: node.start.line,
	                col: node.start.col
	            }));
	            node.thedef = sym;
	        }
	    });
	    self.walk(tw);
	
	    // pass 2: find back references and eval
	    var func = null;
	    var globals = self.globals = new Dictionary();
	    var tw = new TreeWalker(function(node, descend){
	        if (node instanceof AST_Lambda) {
	            var prev_func = func;
	            func = node;
	            descend();
	            func = prev_func;
	            return true;
	        }
	        if (node instanceof AST_LoopControl && node.label) {
	            node.label.thedef.references.push(node);
	            return true;
	        }
	        if (node instanceof AST_SymbolRef) {
	            var name = node.name;
	            if (name == "eval" && tw.parent() instanceof AST_Call) {
	                for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {
	                    s.uses_eval = true;
	                }
	            }
	            var sym = node.scope.find_variable(name);
	            if (node.scope instanceof AST_Lambda && name == "arguments") {
	                node.scope.uses_arguments = true;
	            }
	            if (!sym) {
	                sym = self.def_global(node);
	            }
	            node.thedef = sym;
	            node.reference(options);
	            return true;
	        }
	    });
	    self.walk(tw);
	
	    // pass 3: fix up any scoping issue with IE8
	    if (!options.screw_ie8) {
	        self.walk(new TreeWalker(function(node, descend) {
	            if (node instanceof AST_SymbolCatch) {
	                var name = node.name;
	                var refs = node.thedef.references;
	                var scope = node.thedef.defun;
	                var def = scope.find_variable(name) || self.globals.get(name) || scope.def_variable(node);
	                refs.forEach(function(ref) {
	                    ref.thedef = def;
	                    ref.reference(options);
	                });
	                node.thedef = def;
	                return true;
	            }
	        }));
	    }
	
	    if (options.cache) {
	        this.cname = options.cache.cname;
	    }
	});
	
	AST_Toplevel.DEFMETHOD("def_global", function(node){
	    var globals = this.globals, name = node.name;
	    if (globals.has(name)) {
	        return globals.get(name);
	    } else {
	        var g = new SymbolDef(this, globals.size(), node);
	        g.undeclared = true;
	        g.global = true;
	        globals.set(name, g);
	        return g;
	    }
	});
	
	AST_Scope.DEFMETHOD("init_scope_vars", function(parent_scope){
	    this.variables = new Dictionary();  // map name to AST_SymbolVar (variables defined in this scope; includes functions)
	    this.functions = new Dictionary();  // map name to AST_SymbolDefun (functions defined in this scope)
	    this.uses_with = false;             // will be set to true if this or some nested scope uses the `with` statement
	    this.uses_eval = false;             // will be set to true if this or nested scope uses the global `eval`
	    this.parent_scope = parent_scope;   // the parent scope
	    this.enclosed = [];                 // a list of variables from this or outer scope(s) that are referenced from this or inner scopes
	    this.cname = -1;                    // the current index for mangling functions/variables
	});
	
	AST_Lambda.DEFMETHOD("init_scope_vars", function(){
	    AST_Scope.prototype.init_scope_vars.apply(this, arguments);
	    this.uses_arguments = false;
	    this.def_variable(new AST_SymbolVar({
	        name: "arguments",
	        start: this.start,
	        end: this.end
	    }));
	});
	
	AST_Symbol.DEFMETHOD("mark_enclosed", function(options) {
	    var def = this.definition();
	    var s = this.scope;
	    while (s) {
	        push_uniq(s.enclosed, def);
	        if (options.keep_fnames) {
	            s.functions.each(function(d) {
	                push_uniq(def.scope.enclosed, d);
	            });
	        }
	        if (s === def.scope) break;
	        s = s.parent_scope;
	    }
	});
	
	AST_Symbol.DEFMETHOD("reference", function(options) {
	    this.definition().references.push(this);
	    this.mark_enclosed(options);
	});
	
	AST_Scope.DEFMETHOD("find_variable", function(name){
	    if (name instanceof AST_Symbol) name = name.name;
	    return this.variables.get(name)
	        || (this.parent_scope && this.parent_scope.find_variable(name));
	});
	
	AST_Scope.DEFMETHOD("def_function", function(symbol){
	    this.functions.set(symbol.name, this.def_variable(symbol));
	});
	
	AST_Scope.DEFMETHOD("def_variable", function(symbol){
	    var def;
	    if (!this.variables.has(symbol.name)) {
	        def = new SymbolDef(this, this.variables.size(), symbol);
	        this.variables.set(symbol.name, def);
	        def.global = !this.parent_scope;
	    } else {
	        def = this.variables.get(symbol.name);
	        def.orig.push(symbol);
	    }
	    return symbol.thedef = def;
	});
	
	AST_Scope.DEFMETHOD("next_mangled", function(options){
	    var ext = this.enclosed;
	    out: while (true) {
	        var m = base54(++this.cname);
	        if (!is_identifier(m)) continue; // skip over "do"
	
	        // https://github.com/mishoo/UglifyJS2/issues/242 -- do not
	        // shadow a name excepted from mangling.
	        if (options.except.indexOf(m) >= 0) continue;
	
	        // we must ensure that the mangled name does not shadow a name
	        // from some parent scope that is referenced in this or in
	        // inner scopes.
	        for (var i = ext.length; --i >= 0;) {
	            var sym = ext[i];
	            var name = sym.mangled_name || (sym.unmangleable(options) && sym.name);
	            if (m == name) continue out;
	        }
	        return m;
	    }
	});
	
	AST_Function.DEFMETHOD("next_mangled", function(options, def){
	    // #179, #326
	    // in Safari strict mode, something like (function x(x){...}) is a syntax error;
	    // a function expression's argument cannot shadow the function expression's name
	
	    var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
	
	    // the function's mangled_name is null when keep_fnames is true
	    var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;
	
	    while (true) {
	        var name = AST_Lambda.prototype.next_mangled.call(this, options, def);
	        if (!tricky_name || tricky_name != name)
	            return name;
	    }
	});
	
	AST_Symbol.DEFMETHOD("unmangleable", function(options){
	    return this.definition().unmangleable(options);
	});
	
	// labels are always mangleable
	AST_Label.DEFMETHOD("unmangleable", function(){
	    return false;
	});
	
	AST_Symbol.DEFMETHOD("unreferenced", function(){
	    return this.definition().references.length == 0
	        && !(this.scope.uses_eval || this.scope.uses_with);
	});
	
	AST_Symbol.DEFMETHOD("undeclared", function(){
	    return this.definition().undeclared;
	});
	
	AST_LabelRef.DEFMETHOD("undeclared", function(){
	    return false;
	});
	
	AST_Label.DEFMETHOD("undeclared", function(){
	    return false;
	});
	
	AST_Symbol.DEFMETHOD("definition", function(){
	    return this.thedef;
	});
	
	AST_Symbol.DEFMETHOD("global", function(){
	    return this.definition().global;
	});
	
	AST_Toplevel.DEFMETHOD("_default_mangler_options", function(options){
	    return defaults(options, {
	        eval        : false,
	        except      : [],
	        keep_fnames : false,
	        screw_ie8   : true,
	        sort        : false, // Ignored. Flag retained for backwards compatibility.
	        toplevel    : false,
	    });
	});
	
	AST_Toplevel.DEFMETHOD("mangle_names", function(options){
	    options = this._default_mangler_options(options);
	
	    // Never mangle arguments
	    options.except.push('arguments');
	
	    // We only need to mangle declaration nodes.  Special logic wired
	    // into the code generator will display the mangled name if it's
	    // present (and for AST_SymbolRef-s it'll use the mangled name of
	    // the AST_SymbolDeclaration that it points to).
	    var lname = -1;
	    var to_mangle = [];
	
	    if (options.cache) {
	        this.globals.each(function(symbol){
	            if (options.except.indexOf(symbol.name) < 0) {
	                to_mangle.push(symbol);
	            }
	        });
	    }
	
	    var tw = new TreeWalker(function(node, descend){
	        if (node instanceof AST_LabeledStatement) {
	            // lname is incremented when we get to the AST_Label
	            var save_nesting = lname;
	            descend();
	            lname = save_nesting;
	            return true;        // don't descend again in TreeWalker
	        }
	        if (node instanceof AST_Scope) {
	            var p = tw.parent(), a = [];
	            node.variables.each(function(symbol){
	                if (options.except.indexOf(symbol.name) < 0) {
	                    a.push(symbol);
	                }
	            });
	            to_mangle.push.apply(to_mangle, a);
	            return;
	        }
	        if (node instanceof AST_Label) {
	            var name;
	            do name = base54(++lname); while (!is_identifier(name));
	            node.mangled_name = name;
	            return true;
	        }
	        if (options.screw_ie8 && node instanceof AST_SymbolCatch) {
	            to_mangle.push(node.definition());
	            return;
	        }
	    });
	    this.walk(tw);
	    to_mangle.forEach(function(def){ def.mangle(options) });
	
	    if (options.cache) {
	        options.cache.cname = this.cname;
	    }
	});
	
	AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options){
	    options = this._default_mangler_options(options);
	    var tw = new TreeWalker(function(node){
	        if (node instanceof AST_Constant)
	            base54.consider(node.print_to_string());
	        else if (node instanceof AST_Return)
	            base54.consider("return");
	        else if (node instanceof AST_Throw)
	            base54.consider("throw");
	        else if (node instanceof AST_Continue)
	            base54.consider("continue");
	        else if (node instanceof AST_Break)
	            base54.consider("break");
	        else if (node instanceof AST_Debugger)
	            base54.consider("debugger");
	        else if (node instanceof AST_Directive)
	            base54.consider(node.value);
	        else if (node instanceof AST_While)
	            base54.consider("while");
	        else if (node instanceof AST_Do)
	            base54.consider("do while");
	        else if (node instanceof AST_If) {
	            base54.consider("if");
	            if (node.alternative) base54.consider("else");
	        }
	        else if (node instanceof AST_Var)
	            base54.consider("var");
	        else if (node instanceof AST_Const)
	            base54.consider("const");
	        else if (node instanceof AST_Lambda)
	            base54.consider("function");
	        else if (node instanceof AST_For)
	            base54.consider("for");
	        else if (node instanceof AST_ForIn)
	            base54.consider("for in");
	        else if (node instanceof AST_Switch)
	            base54.consider("switch");
	        else if (node instanceof AST_Case)
	            base54.consider("case");
	        else if (node instanceof AST_Default)
	            base54.consider("default");
	        else if (node instanceof AST_With)
	            base54.consider("with");
	        else if (node instanceof AST_ObjectSetter)
	            base54.consider("set" + node.key);
	        else if (node instanceof AST_ObjectGetter)
	            base54.consider("get" + node.key);
	        else if (node instanceof AST_ObjectKeyVal)
	            base54.consider(node.key);
	        else if (node instanceof AST_New)
	            base54.consider("new");
	        else if (node instanceof AST_This)
	            base54.consider("this");
	        else if (node instanceof AST_Try)
	            base54.consider("try");
	        else if (node instanceof AST_Catch)
	            base54.consider("catch");
	        else if (node instanceof AST_Finally)
	            base54.consider("finally");
	        else if (node instanceof AST_Symbol && node.unmangleable(options))
	            base54.consider(node.name);
	        else if (node instanceof AST_Unary || node instanceof AST_Binary)
	            base54.consider(node.operator);
	        else if (node instanceof AST_Dot)
	            base54.consider(node.property);
	    });
	    this.walk(tw);
	    base54.sort();
	});
	
	var base54 = (function() {
	    var string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
	    var chars, frequency;
	    function reset() {
	        frequency = Object.create(null);
	        chars = string.split("").map(function(ch){ return ch.charCodeAt(0) });
	        chars.forEach(function(ch){ frequency[ch] = 0 });
	    }
	    base54.consider = function(str){
	        for (var i = str.length; --i >= 0;) {
	            var code = str.charCodeAt(i);
	            if (code in frequency) ++frequency[code];
	        }
	    };
	    base54.sort = function() {
	        chars = mergeSort(chars, function(a, b){
	            if (is_digit(a) && !is_digit(b)) return 1;
	            if (is_digit(b) && !is_digit(a)) return -1;
	            return frequency[b] - frequency[a];
	        });
	    };
	    base54.reset = reset;
	    reset();
	    base54.get = function(){ return chars };
	    base54.freq = function(){ return frequency };
	    function base54(num) {
	        var ret = "", base = 54;
	        num++;
	        do {
	            num--;
	            ret += String.fromCharCode(chars[num % base]);
	            num = Math.floor(num / base);
	            base = 64;
	        } while (num > 0);
	        return ret;
	    };
	    return base54;
	})();
	
	AST_Toplevel.DEFMETHOD("scope_warnings", function(options){
	    options = defaults(options, {
	        assign_to_global : true,
	        eval             : true,
	        func_arguments   : true,
	        nested_defuns    : true,
	        undeclared       : false, // this makes a lot of noise
	        unreferenced     : true,
	    });
	    var tw = new TreeWalker(function(node){
	        if (options.undeclared
	            && node instanceof AST_SymbolRef
	            && node.undeclared())
	        {
	            // XXX: this also warns about JS standard names,
	            // i.e. Object, Array, parseInt etc.  Should add a list of
	            // exceptions.
	            AST_Node.warn("Undeclared symbol: {name} [{file}:{line},{col}]", {
	                name: node.name,
	                file: node.start.file,
	                line: node.start.line,
	                col: node.start.col
	            });
	        }
	        if (options.assign_to_global)
	        {
	            var sym = null;
	            if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef)
	                sym = node.left;
	            else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef)
	                sym = node.init;
	            if (sym
	                && (sym.undeclared()
	                    || (sym.global() && sym.scope !== sym.definition().scope))) {
	                AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
	                    msg: sym.undeclared() ? "Accidental global?" : "Assignment to global",
	                    name: sym.name,
	                    file: sym.start.file,
	                    line: sym.start.line,
	                    col: sym.start.col
	                });
	            }
	        }
	        if (options.eval
	            && node instanceof AST_SymbolRef
	            && node.undeclared()
	            && node.name == "eval") {
	            AST_Node.warn("Eval is used [{file}:{line},{col}]", node.start);
	        }
	        if (options.unreferenced
	            && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label)
	            && !(node instanceof AST_SymbolCatch)
	            && node.unreferenced()) {
	            AST_Node.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", {
	                type: node instanceof AST_Label ? "Label" : "Symbol",
	                name: node.name,
	                file: node.start.file,
	                line: node.start.line,
	                col: node.start.col
	            });
	        }
	        if (options.func_arguments
	            && node instanceof AST_Lambda
	            && node.uses_arguments) {
	            AST_Node.warn("arguments used in function {name} [{file}:{line},{col}]", {
	                name: node.name ? node.name.name : "anonymous",
	                file: node.start.file,
	                line: node.start.line,
	                col: node.start.col
	            });
	        }
	        if (options.nested_defuns
	            && node instanceof AST_Defun
	            && !(tw.parent() instanceof AST_Scope)) {
	            AST_Node.warn("Function {name} declared in nested statement \"{type}\" [{file}:{line},{col}]", {
	                name: node.name.name,
	                type: tw.parent().TYPE,
	                file: node.start.file,
	                line: node.start.line,
	                col: node.start.col
	            });
	        }
	    });
	    this.walk(tw);
	});
	
	
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	var EXPECT_DIRECTIVE = /^$|[;{][\s\n]*$/;
	
	function is_some_comments(comment) {
	    // multiline comment
	    return comment.type == "comment2" && /@preserve|@license|@cc_on/i.test(comment.value);
	}
	
	function OutputStream(options) {
	
	    options = defaults(options, {
	        ascii_only       : false,
	        beautify         : false,
	        bracketize       : false,
	        comments         : false,
	        indent_level     : 4,
	        indent_start     : 0,
	        inline_script    : true,
	        keep_quoted_props: false,
	        max_line_len     : false,
	        preamble         : null,
	        preserve_line    : false,
	        quote_keys       : false,
	        quote_style      : 0,
	        screw_ie8        : true,
	        semicolons       : true,
	        shebang          : true,
	        source_map       : null,
	        space_colon      : true,
	        unescape_regexps : false,
	        width            : 80,
	        wrap_iife        : false,
	    }, true);
	
	    // Convert comment option to RegExp if neccessary and set up comments filter
	    var comment_filter = return_false; // Default case, throw all comments away
	    if (options.comments) {
	        var comments = options.comments;
	        if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
	            var regex_pos = options.comments.lastIndexOf("/");
	            comments = new RegExp(
	                options.comments.substr(1, regex_pos - 1),
	                options.comments.substr(regex_pos + 1)
	            );
	        }
	        if (comments instanceof RegExp) {
	            comment_filter = function(comment) {
	                return comment.type != "comment5" && comments.test(comment.value);
	            };
	        }
	        else if (typeof comments === "function") {
	            comment_filter = function(comment) {
	                return comment.type != "comment5" && comments(this, comment);
	            };
	        }
	        else if (comments === "some") {
	            comment_filter = is_some_comments;
	        } else { // NOTE includes "all" option
	            comment_filter = return_true;
	        }
	    }
	
	    var indentation = 0;
	    var current_col = 0;
	    var current_line = 1;
	    var current_pos = 0;
	    var OUTPUT = "";
	
	    function to_ascii(str, identifier) {
	        return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
	            var code = ch.charCodeAt(0).toString(16);
	            if (code.length <= 2 && !identifier) {
	                while (code.length < 2) code = "0" + code;
	                return "\\x" + code;
	            } else {
	                while (code.length < 4) code = "0" + code;
	                return "\\u" + code;
	            }
	        });
	    };
	
	    function make_string(str, quote) {
	        var dq = 0, sq = 0;
	        str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,
	          function(s, i){
	            switch (s) {
	              case '"': ++dq; return '"';
	              case "'": ++sq; return "'";
	              case "\\": return "\\\\";
	              case "\n": return "\\n";
	              case "\r": return "\\r";
	              case "\t": return "\\t";
	              case "\b": return "\\b";
	              case "\f": return "\\f";
	              case "\x0B": return options.screw_ie8 ? "\\v" : "\\x0B";
	              case "\u2028": return "\\u2028";
	              case "\u2029": return "\\u2029";
	              case "\ufeff": return "\\ufeff";
	              case "\0":
	                  return /[0-7]/.test(str.charAt(i+1)) ? "\\x00" : "\\0";
	            }
	            return s;
	        });
	        function quote_single() {
	            return "'" + str.replace(/\x27/g, "\\'") + "'";
	        }
	        function quote_double() {
	            return '"' + str.replace(/\x22/g, '\\"') + '"';
	        }
	        if (options.ascii_only) str = to_ascii(str);
	        switch (options.quote_style) {
	          case 1:
	            return quote_single();
	          case 2:
	            return quote_double();
	          case 3:
	            return quote == "'" ? quote_single() : quote_double();
	          default:
	            return dq > sq ? quote_single() : quote_double();
	        }
	    };
	
	    function encode_string(str, quote) {
	        var ret = make_string(str, quote);
	        if (options.inline_script) {
	            ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1");
	            ret = ret.replace(/\x3c!--/g, "\\x3c!--");
	            ret = ret.replace(/--\x3e/g, "--\\x3e");
	        }
	        return ret;
	    };
	
	    function make_name(name) {
	        name = name.toString();
	        if (options.ascii_only)
	            name = to_ascii(name, true);
	        return name;
	    };
	
	    function make_indent(back) {
	        return repeat_string(" ", options.indent_start + indentation - back * options.indent_level);
	    };
	
	    /* -----[ beautification/minification ]----- */
	
	    var might_need_space = false;
	    var might_need_semicolon = false;
	    var might_add_newline = 0;
	    var last = "";
	
	    var ensure_line_len = options.max_line_len ? function() {
	        if (current_col > options.max_line_len) {
	            if (might_add_newline) {
	                var left = OUTPUT.slice(0, might_add_newline);
	                var right = OUTPUT.slice(might_add_newline);
	                OUTPUT = left + "\n" + right;
	                current_line++;
	                current_pos++;
	                current_col = right.length;
	            }
	            if (current_col > options.max_line_len) {
	                AST_Node.warn("Output exceeds {max_line_len} characters", options);
	            }
	        }
	        might_add_newline = 0;
	    } : noop;
	
	    var requireSemicolonChars = makePredicate("( [ + * / - , .");
	
	    function print(str) {
	        str = String(str);
	        var ch = str.charAt(0);
	        var prev = last.charAt(last.length - 1);
	        if (might_need_semicolon) {
	            might_need_semicolon = false;
	
	            if (prev == ":" && ch == "}" || (!ch || ";}".indexOf(ch) < 0) && prev != ";") {
	                if (options.semicolons || requireSemicolonChars(ch)) {
	                    OUTPUT += ";";
	                    current_col++;
	                    current_pos++;
	                } else {
	                    ensure_line_len();
	                    OUTPUT += "\n";
	                    current_pos++;
	                    current_line++;
	                    current_col = 0;
	
	                    if (/^\s+$/.test(str)) {
	                        // reset the semicolon flag, since we didn't print one
	                        // now and might still have to later
	                        might_need_semicolon = true;
	                    }
	                }
	
	                if (!options.beautify)
	                    might_need_space = false;
	            }
	        }
	
	        if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {
	            var target_line = stack[stack.length - 1].start.line;
	            while (current_line < target_line) {
	                ensure_line_len();
	                OUTPUT += "\n";
	                current_pos++;
	                current_line++;
	                current_col = 0;
	                might_need_space = false;
	            }
	        }
	
	        if (might_need_space) {
	            if ((is_identifier_char(prev)
	                    && (is_identifier_char(ch) || ch == "\\"))
	                || (ch == "/" && ch == prev)
	                || ((ch == "+" || ch == "-") && ch == last))
	            {
	                OUTPUT += " ";
	                current_col++;
	                current_pos++;
	            }
	            might_need_space = false;
	        }
	        OUTPUT += str;
	        current_pos += str.length;
	        var a = str.split(/\r?\n/), n = a.length - 1;
	        current_line += n;
	        current_col += a[0].length;
	        if (n > 0) {
	            ensure_line_len();
	            current_col = a[n].length;
	        }
	        last = str;
	    };
	
	    var space = options.beautify ? function() {
	        print(" ");
	    } : function() {
	        might_need_space = true;
	    };
	
	    var indent = options.beautify ? function(half) {
	        if (options.beautify) {
	            print(make_indent(half ? 0.5 : 0));
	        }
	    } : noop;
	
	    var with_indent = options.beautify ? function(col, cont) {
	        if (col === true) col = next_indent();
	        var save_indentation = indentation;
	        indentation = col;
	        var ret = cont();
	        indentation = save_indentation;
	        return ret;
	    } : function(col, cont) { return cont() };
	
	    var newline = options.beautify ? function() {
	        print("\n");
	    } : options.max_line_len ? function() {
	        ensure_line_len();
	        might_add_newline = OUTPUT.length;
	    } : noop;
	
	    var semicolon = options.beautify ? function() {
	        print(";");
	    } : function() {
	        might_need_semicolon = true;
	    };
	
	    function force_semicolon() {
	        might_need_semicolon = false;
	        print(";");
	    };
	
	    function next_indent() {
	        return indentation + options.indent_level;
	    };
	
	    function with_block(cont) {
	        var ret;
	        print("{");
	        newline();
	        with_indent(next_indent(), function(){
	            ret = cont();
	        });
	        indent();
	        print("}");
	        return ret;
	    };
	
	    function with_parens(cont) {
	        print("(");
	        //XXX: still nice to have that for argument lists
	        //var ret = with_indent(current_col, cont);
	        var ret = cont();
	        print(")");
	        return ret;
	    };
	
	    function with_square(cont) {
	        print("[");
	        //var ret = with_indent(current_col, cont);
	        var ret = cont();
	        print("]");
	        return ret;
	    };
	
	    function comma() {
	        print(",");
	        space();
	    };
	
	    function colon() {
	        print(":");
	        if (options.space_colon) space();
	    };
	
	    var add_mapping = options.source_map ? function(token, name) {
	        try {
	            if (token) options.source_map.add(
	                token.file || "?",
	                current_line, current_col,
	                token.line, token.col,
	                (!name && token.type == "name") ? token.value : name
	            );
	        } catch(ex) {
	            AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
	                file: token.file,
	                line: token.line,
	                col: token.col,
	                cline: current_line,
	                ccol: current_col,
	                name: name || ""
	            })
	        }
	    } : noop;
	
	    function get() {
	        if (might_add_newline) {
	            ensure_line_len();
	        }
	        return OUTPUT;
	    };
	
	    var stack = [];
	    return {
	        get             : get,
	        toString        : get,
	        indent          : indent,
	        indentation     : function() { return indentation },
	        current_width   : function() { return current_col - indentation },
	        should_break    : function() { return options.width && this.current_width() >= options.width },
	        newline         : newline,
	        print           : print,
	        space           : space,
	        comma           : comma,
	        colon           : colon,
	        last            : function() { return last },
	        semicolon       : semicolon,
	        force_semicolon : force_semicolon,
	        to_ascii        : to_ascii,
	        print_name      : function(name) { print(make_name(name)) },
	        print_string    : function(str, quote, escape_directive) {
	            var encoded = encode_string(str, quote);
	            if (escape_directive === true && encoded.indexOf("\\") === -1) {
	                // Insert semicolons to break directive prologue
	                if (!EXPECT_DIRECTIVE.test(OUTPUT)) {
	                    force_semicolon();
	                }
	                force_semicolon();
	            }
	            print(encoded);
	        },
	        encode_string   : encode_string,
	        next_indent     : next_indent,
	        with_indent     : with_indent,
	        with_block      : with_block,
	        with_parens     : with_parens,
	        with_square     : with_square,
	        add_mapping     : add_mapping,
	        option          : function(opt) { return options[opt] },
	        comment_filter  : comment_filter,
	        line            : function() { return current_line },
	        col             : function() { return current_col },
	        pos             : function() { return current_pos },
	        push_node       : function(node) { stack.push(node) },
	        pop_node        : function() { return stack.pop() },
	        parent          : function(n) {
	            return stack[stack.length - 2 - (n || 0)];
	        }
	    };
	
	};
	
	/* -----[ code generators ]----- */
	
	(function(){
	
	    /* -----[ utils ]----- */
	
	    function DEFPRINT(nodetype, generator) {
	        nodetype.DEFMETHOD("_codegen", generator);
	    };
	
	    var use_asm = false;
	    var in_directive = false;
	
	    AST_Node.DEFMETHOD("print", function(stream, force_parens){
	        var self = this, generator = self._codegen, prev_use_asm = use_asm;
	        if (self instanceof AST_Directive && self.value == "use asm" && stream.parent() instanceof AST_Scope) {
	            use_asm = true;
	        }
	        function doit() {
	            self.add_comments(stream);
	            self.add_source_map(stream);
	            generator(self, stream);
	        }
	        stream.push_node(self);
	        if (force_parens || self.needs_parens(stream)) {
	            stream.with_parens(doit);
	        } else {
	            doit();
	        }
	        stream.pop_node();
	        if (self instanceof AST_Scope) {
	            use_asm = prev_use_asm;
	        }
	    });
	
	    AST_Node.DEFMETHOD("print_to_string", function(options){
	        var s = OutputStream(options);
	        if (!options) s._readonly = true;
	        this.print(s);
	        return s.get();
	    });
	
	    /* -----[ comments ]----- */
	
	    AST_Node.DEFMETHOD("add_comments", function(output){
	        if (output._readonly) return;
	        var self = this;
	        var start = self.start;
	        if (start && !start._comments_dumped) {
	            start._comments_dumped = true;
	            var comments = start.comments_before || [];
	
	            // XXX: ugly fix for https://github.com/mishoo/UglifyJS2/issues/112
	            //               and https://github.com/mishoo/UglifyJS2/issues/372
	            if (self instanceof AST_Exit && self.value) {
	                self.value.walk(new TreeWalker(function(node){
	                    if (node.start && node.start.comments_before) {
	                        comments = comments.concat(node.start.comments_before);
	                        node.start.comments_before = [];
	                    }
	                    if (node instanceof AST_Function ||
	                        node instanceof AST_Array ||
	                        node instanceof AST_Object)
	                    {
	                        return true; // don't go inside.
	                    }
	                }));
	            }
	
	            if (output.pos() == 0) {
	                if (comments.length > 0 && output.option("shebang") && comments[0].type == "comment5") {
	                    output.print("#!" + comments.shift().value + "\n");
	                    output.indent();
	                }
	                var preamble = output.option("preamble");
	                if (preamble) {
	                    output.print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
	                }
	            }
	
	            comments = comments.filter(output.comment_filter, self);
	
	            // Keep single line comments after nlb, after nlb
	            if (!output.option("beautify") && comments.length > 0 &&
	                /comment[134]/.test(comments[0].type) &&
	                output.col() !== 0 && comments[0].nlb)
	            {
	                output.print("\n");
	            }
	
	            comments.forEach(function(c){
	                if (/comment[134]/.test(c.type)) {
	                    output.print("//" + c.value + "\n");
	                    output.indent();
	                }
	                else if (c.type == "comment2") {
	                    output.print("/*" + c.value + "*/");
	                    if (start.nlb) {
	                        output.print("\n");
	                        output.indent();
	                    } else {
	                        output.space();
	                    }
	                }
	            });
	        }
	    });
	
	    /* -----[ PARENTHESES ]----- */
	
	    function PARENS(nodetype, func) {
	        if (Array.isArray(nodetype)) {
	            nodetype.forEach(function(nodetype){
	                PARENS(nodetype, func);
	            });
	        } else {
	            nodetype.DEFMETHOD("needs_parens", func);
	        }
	    };
	
	    PARENS(AST_Node, function(){
	        return false;
	    });
	
	    // a function expression needs parens around it when it's provably
	    // the first token to appear in a statement.
	    PARENS(AST_Function, function(output){
	        if (first_in_statement(output)) {
	            return true;
	        }
	
	        if (output.option('wrap_iife')) {
	            var p = output.parent();
	            return p instanceof AST_Call && p.expression === this;
	        }
	
	        return false;
	    });
	
	    // same goes for an object literal, because otherwise it would be
	    // interpreted as a block of code.
	    PARENS(AST_Object, function(output){
	        return first_in_statement(output);
	    });
	
	    PARENS(AST_Unary, function(output){
	        var p = output.parent();
	        return p instanceof AST_PropAccess && p.expression === this
	            || p instanceof AST_Call && p.expression === this;
	    });
	
	    PARENS(AST_Seq, function(output){
	        var p = output.parent();
	        return p instanceof AST_Call             // (foo, bar)() or foo(1, (2, 3), 4)
	            || p instanceof AST_Unary            // !(foo, bar, baz)
	            || p instanceof AST_Binary           // 1 + (2, 3) + 4 ==> 8
	            || p instanceof AST_VarDef           // var a = (1, 2), b = a + a; ==> b == 4
	            || p instanceof AST_PropAccess       // (1, {foo:2}).foo or (1, {foo:2})["foo"] ==> 2
	            || p instanceof AST_Array            // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
	            || p instanceof AST_ObjectProperty   // { foo: (1, 2) }.foo ==> 2
	            || p instanceof AST_Conditional      /* (false, true) ? (a = 10, b = 20) : (c = 30)
	                                                  * ==> 20 (side effect, set a := 10 and b := 20) */
	        ;
	    });
	
	    PARENS(AST_Binary, function(output){
	        var p = output.parent();
	        // (foo && bar)()
	        if (p instanceof AST_Call && p.expression === this)
	            return true;
	        // typeof (foo && bar)
	        if (p instanceof AST_Unary)
	            return true;
	        // (foo && bar)["prop"], (foo && bar).prop
	        if (p instanceof AST_PropAccess && p.expression === this)
	            return true;
	        // this deals with precedence: 3 * (2 + 1)
	        if (p instanceof AST_Binary) {
	            var po = p.operator, pp = PRECEDENCE[po];
	            var so = this.operator, sp = PRECEDENCE[so];
	            if (pp > sp
	                || (pp == sp
	                    && this === p.right)) {
	                return true;
	            }
	        }
	    });
	
	    PARENS(AST_PropAccess, function(output){
	        var p = output.parent();
	        if (p instanceof AST_New && p.expression === this) {
	            // i.e. new (foo.bar().baz)
	            //
	            // if there's one call into this subtree, then we need
	            // parens around it too, otherwise the call will be
	            // interpreted as passing the arguments to the upper New
	            // expression.
	            try {
	                this.walk(new TreeWalker(function(node){
	                    if (node instanceof AST_Call) throw p;
	                }));
	            } catch(ex) {
	                if (ex !== p) throw ex;
	                return true;
	            }
	        }
	    });
	
	    PARENS(AST_Call, function(output){
	        var p = output.parent(), p1;
	        if (p instanceof AST_New && p.expression === this)
	            return true;
	
	        // workaround for Safari bug.
	        // https://bugs.webkit.org/show_bug.cgi?id=123506
	        return this.expression instanceof AST_Function
	            && p instanceof AST_PropAccess
	            && p.expression === this
	            && (p1 = output.parent(1)) instanceof AST_Assign
	            && p1.left === p;
	    });
	
	    PARENS(AST_New, function(output){
	        var p = output.parent();
	        if (!need_constructor_parens(this, output)
	            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)["getTime"]()
	                || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)
	            return true;
	    });
	
	    PARENS(AST_Number, function(output){
	        var p = output.parent();
	        if (p instanceof AST_PropAccess && p.expression === this) {
	            var value = this.getValue();
	            if (value < 0 || /^0/.test(make_num(value))) {
	                return true;
	            }
	        }
	    });
	
	    PARENS([ AST_Assign, AST_Conditional ], function (output){
	        var p = output.parent();
	        // !(a = false) → true
	        if (p instanceof AST_Unary)
	            return true;
	        // 1 + (a = 2) + 3 → 6, side effect setting a = 2
	        if (p instanceof AST_Binary && !(p instanceof AST_Assign))
	            return true;
	        // (a = func)() —or— new (a = Object)()
	        if (p instanceof AST_Call && p.expression === this)
	            return true;
	        // (a = foo) ? bar : baz
	        if (p instanceof AST_Conditional && p.condition === this)
	            return true;
	        // (a = foo)["prop"] —or— (a = foo).prop
	        if (p instanceof AST_PropAccess && p.expression === this)
	            return true;
	    });
	
	    /* -----[ PRINTERS ]----- */
	
	    DEFPRINT(AST_Directive, function(self, output){
	        output.print_string(self.value, self.quote);
	        output.semicolon();
	    });
	    DEFPRINT(AST_Debugger, function(self, output){
	        output.print("debugger");
	        output.semicolon();
	    });
	
	    /* -----[ statements ]----- */
	
	    function display_body(body, is_toplevel, output, allow_directives) {
	        var last = body.length - 1;
	        in_directive = allow_directives;
	        body.forEach(function(stmt, i){
	            if (in_directive === true && !(stmt instanceof AST_Directive ||
	                stmt instanceof AST_EmptyStatement ||
	                (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String)
	            )) {
	                in_directive = false;
	            }
	            if (!(stmt instanceof AST_EmptyStatement)) {
	                output.indent();
	                stmt.print(output);
	                if (!(i == last && is_toplevel)) {
	                    output.newline();
	                    if (is_toplevel) output.newline();
	                }
	            }
	            if (in_directive === true &&
	                stmt instanceof AST_SimpleStatement &&
	                stmt.body instanceof AST_String
	            ) {
	                in_directive = false;
	            }
	        });
	        in_directive = false;
	    };
	
	    AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output){
	        force_statement(this.body, output);
	    });
	
	    DEFPRINT(AST_Statement, function(self, output){
	        self.body.print(output);
	        output.semicolon();
	    });
	    DEFPRINT(AST_Toplevel, function(self, output){
	        display_body(self.body, true, output, true);
	        output.print("");
	    });
	    DEFPRINT(AST_LabeledStatement, function(self, output){
	        self.label.print(output);
	        output.colon();
	        self.body.print(output);
	    });
	    DEFPRINT(AST_SimpleStatement, function(self, output){
	        self.body.print(output);
	        output.semicolon();
	    });
	    function print_bracketed(body, output, allow_directives) {
	        if (body.length > 0) output.with_block(function(){
	            display_body(body, false, output, allow_directives);
	        });
	        else output.print("{}");
	    };
	    DEFPRINT(AST_BlockStatement, function(self, output){
	        print_bracketed(self.body, output);
	    });
	    DEFPRINT(AST_EmptyStatement, function(self, output){
	        output.semicolon();
	    });
	    DEFPRINT(AST_Do, function(self, output){
	        output.print("do");
	        output.space();
	        make_block(self.body, output);
	        output.space();
	        output.print("while");
	        output.space();
	        output.with_parens(function(){
	            self.condition.print(output);
	        });
	        output.semicolon();
	    });
	    DEFPRINT(AST_While, function(self, output){
	        output.print("while");
	        output.space();
	        output.with_parens(function(){
	            self.condition.print(output);
	        });
	        output.space();
	        self._do_print_body(output);
	    });
	    DEFPRINT(AST_For, function(self, output){
	        output.print("for");
	        output.space();
	        output.with_parens(function(){
	            if (self.init) {
	                if (self.init instanceof AST_Definitions) {
	                    self.init.print(output);
	                } else {
	                    parenthesize_for_noin(self.init, output, true);
	                }
	                output.print(";");
	                output.space();
	            } else {
	                output.print(";");
	            }
	            if (self.condition) {
	                self.condition.print(output);
	                output.print(";");
	                output.space();
	            } else {
	                output.print(";");
	            }
	            if (self.step) {
	                self.step.print(output);
	            }
	        });
	        output.space();
	        self._do_print_body(output);
	    });
	    DEFPRINT(AST_ForIn, function(self, output){
	        output.print("for");
	        output.space();
	        output.with_parens(function(){
	            self.init.print(output);
	            output.space();
	            output.print("in");
	            output.space();
	            self.object.print(output);
	        });
	        output.space();
	        self._do_print_body(output);
	    });
	    DEFPRINT(AST_With, function(self, output){
	        output.print("with");
	        output.space();
	        output.with_parens(function(){
	            self.expression.print(output);
	        });
	        output.space();
	        self._do_print_body(output);
	    });
	
	    /* -----[ functions ]----- */
	    AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword){
	        var self = this;
	        if (!nokeyword) {
	            output.print("function");
	        }
	        if (self.name) {
	            output.space();
	            self.name.print(output);
	        }
	        output.with_parens(function(){
	            self.argnames.forEach(function(arg, i){
	                if (i) output.comma();
	                arg.print(output);
	            });
	        });
	        output.space();
	        print_bracketed(self.body, output, true);
	    });
	    DEFPRINT(AST_Lambda, function(self, output){
	        self._do_print(output);
	    });
	
	    /* -----[ exits ]----- */
	    AST_Exit.DEFMETHOD("_do_print", function(output, kind){
	        output.print(kind);
	        if (this.value) {
	            output.space();
	            this.value.print(output);
	        }
	        output.semicolon();
	    });
	    DEFPRINT(AST_Return, function(self, output){
	        self._do_print(output, "return");
	    });
	    DEFPRINT(AST_Throw, function(self, output){
	        self._do_print(output, "throw");
	    });
	
	    /* -----[ loop control ]----- */
	    AST_LoopControl.DEFMETHOD("_do_print", function(output, kind){
	        output.print(kind);
	        if (this.label) {
	            output.space();
	            this.label.print(output);
	        }
	        output.semicolon();
	    });
	    DEFPRINT(AST_Break, function(self, output){
	        self._do_print(output, "break");
	    });
	    DEFPRINT(AST_Continue, function(self, output){
	        self._do_print(output, "continue");
	    });
	
	    /* -----[ if ]----- */
	    function make_then(self, output) {
	        var b = self.body;
	        if (output.option("bracketize")
	            || !output.option("screw_ie8") && b instanceof AST_Do)
	            return make_block(b, output);
	        // The squeezer replaces "block"-s that contain only a single
	        // statement with the statement itself; technically, the AST
	        // is correct, but this can create problems when we output an
	        // IF having an ELSE clause where the THEN clause ends in an
	        // IF *without* an ELSE block (then the outer ELSE would refer
	        // to the inner IF).  This function checks for this case and
	        // adds the block brackets if needed.
	        if (!b) return output.force_semicolon();
	        while (true) {
	            if (b instanceof AST_If) {
	                if (!b.alternative) {
	                    make_block(self.body, output);
	                    return;
	                }
	                b = b.alternative;
	            }
	            else if (b instanceof AST_StatementWithBody) {
	                b = b.body;
	            }
	            else break;
	        }
	        force_statement(self.body, output);
	    };
	    DEFPRINT(AST_If, function(self, output){
	        output.print("if");
	        output.space();
	        output.with_parens(function(){
	            self.condition.print(output);
	        });
	        output.space();
	        if (self.alternative) {
	            make_then(self, output);
	            output.space();
	            output.print("else");
	            output.space();
	            if (self.alternative instanceof AST_If)
	                self.alternative.print(output);
	            else
	                force_statement(self.alternative, output);
	        } else {
	            self._do_print_body(output);
	        }
	    });
	
	    /* -----[ switch ]----- */
	    DEFPRINT(AST_Switch, function(self, output){
	        output.print("switch");
	        output.space();
	        output.with_parens(function(){
	            self.expression.print(output);
	        });
	        output.space();
	        var last = self.body.length - 1;
	        if (last < 0) output.print("{}");
	        else output.with_block(function(){
	            self.body.forEach(function(branch, i){
	                output.indent(true);
	                branch.print(output);
	                if (i < last && branch.body.length > 0)
	                    output.newline();
	            });
	        });
	    });
	    AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output){
	        output.newline();
	        this.body.forEach(function(stmt){
	            output.indent();
	            stmt.print(output);
	            output.newline();
	        });
	    });
	    DEFPRINT(AST_Default, function(self, output){
	        output.print("default:");
	        self._do_print_body(output);
	    });
	    DEFPRINT(AST_Case, function(self, output){
	        output.print("case");
	        output.space();
	        self.expression.print(output);
	        output.print(":");
	        self._do_print_body(output);
	    });
	
	    /* -----[ exceptions ]----- */
	    DEFPRINT(AST_Try, function(self, output){
	        output.print("try");
	        output.space();
	        print_bracketed(self.body, output);
	        if (self.bcatch) {
	            output.space();
	            self.bcatch.print(output);
	        }
	        if (self.bfinally) {
	            output.space();
	            self.bfinally.print(output);
	        }
	    });
	    DEFPRINT(AST_Catch, function(self, output){
	        output.print("catch");
	        output.space();
	        output.with_parens(function(){
	            self.argname.print(output);
	        });
	        output.space();
	        print_bracketed(self.body, output);
	    });
	    DEFPRINT(AST_Finally, function(self, output){
	        output.print("finally");
	        output.space();
	        print_bracketed(self.body, output);
	    });
	
	    /* -----[ var/const ]----- */
	    AST_Definitions.DEFMETHOD("_do_print", function(output, kind){
	        output.print(kind);
	        output.space();
	        this.definitions.forEach(function(def, i){
	            if (i) output.comma();
	            def.print(output);
	        });
	        var p = output.parent();
	        var in_for = p instanceof AST_For || p instanceof AST_ForIn;
	        var avoid_semicolon = in_for && p.init === this;
	        if (!avoid_semicolon)
	            output.semicolon();
	    });
	    DEFPRINT(AST_Var, function(self, output){
	        self._do_print(output, "var");
	    });
	    DEFPRINT(AST_Const, function(self, output){
	        self._do_print(output, "const");
	    });
	
	    function parenthesize_for_noin(node, output, noin) {
	        if (!noin) node.print(output);
	        else try {
	            // need to take some precautions here:
	            //    https://github.com/mishoo/UglifyJS2/issues/60
	            node.walk(new TreeWalker(function(node){
	                if (node instanceof AST_Binary && node.operator == "in")
	                    throw output;
	            }));
	            node.print(output);
	        } catch(ex) {
	            if (ex !== output) throw ex;
	            node.print(output, true);
	        }
	    };
	
	    DEFPRINT(AST_VarDef, function(self, output){
	        self.name.print(output);
	        if (self.value) {
	            output.space();
	            output.print("=");
	            output.space();
	            var p = output.parent(1);
	            var noin = p instanceof AST_For || p instanceof AST_ForIn;
	            parenthesize_for_noin(self.value, output, noin);
	        }
	    });
	
	    /* -----[ other expressions ]----- */
	    DEFPRINT(AST_Call, function(self, output){
	        self.expression.print(output);
	        if (self instanceof AST_New && !need_constructor_parens(self, output))
	            return;
	        output.with_parens(function(){
	            self.args.forEach(function(expr, i){
	                if (i) output.comma();
	                expr.print(output);
	            });
	        });
	    });
	    DEFPRINT(AST_New, function(self, output){
	        output.print("new");
	        output.space();
	        AST_Call.prototype._codegen(self, output);
	    });
	
	    AST_Seq.DEFMETHOD("_do_print", function(output){
	        this.car.print(output);
	        if (this.cdr) {
	            output.comma();
	            if (output.should_break()) {
	                output.newline();
	                output.indent();
	            }
	            this.cdr.print(output);
	        }
	    });
	    DEFPRINT(AST_Seq, function(self, output){
	        self._do_print(output);
	        // var p = output.parent();
	        // if (p instanceof AST_Statement) {
	        //     output.with_indent(output.next_indent(), function(){
	        //         self._do_print(output);
	        //     });
	        // } else {
	        //     self._do_print(output);
	        // }
	    });
	    DEFPRINT(AST_Dot, function(self, output){
	        var expr = self.expression;
	        expr.print(output);
	        if (expr instanceof AST_Number && expr.getValue() >= 0) {
	            if (!/[xa-f.)]/i.test(output.last())) {
	                output.print(".");
	            }
	        }
	        output.print(".");
	        // the name after dot would be mapped about here.
	        output.add_mapping(self.end);
	        output.print_name(self.property);
	    });
	    DEFPRINT(AST_Sub, function(self, output){
	        self.expression.print(output);
	        output.print("[");
	        self.property.print(output);
	        output.print("]");
	    });
	    DEFPRINT(AST_UnaryPrefix, function(self, output){
	        var op = self.operator;
	        output.print(op);
	        if (/^[a-z]/i.test(op)
	            || (/[+-]$/.test(op)
	                && self.expression instanceof AST_UnaryPrefix
	                && /^[+-]/.test(self.expression.operator))) {
	            output.space();
	        }
	        self.expression.print(output);
	    });
	    DEFPRINT(AST_UnaryPostfix, function(self, output){
	        self.expression.print(output);
	        output.print(self.operator);
	    });
	    DEFPRINT(AST_Binary, function(self, output){
	        var op = self.operator;
	        self.left.print(output);
	        if (op[0] == ">" /* ">>" ">>>" ">" ">=" */
	            && self.left instanceof AST_UnaryPostfix
	            && self.left.operator == "--") {
	            // space is mandatory to avoid outputting -->
	            output.print(" ");
	        } else {
	            // the space is optional depending on "beautify"
	            output.space();
	        }
	        output.print(op);
	        if ((op == "<" || op == "<<")
	            && self.right instanceof AST_UnaryPrefix
	            && self.right.operator == "!"
	            && self.right.expression instanceof AST_UnaryPrefix
	            && self.right.expression.operator == "--") {
	            // space is mandatory to avoid outputting <!--
	            output.print(" ");
	        } else {
	            // the space is optional depending on "beautify"
	            output.space();
	        }
	        self.right.print(output);
	    });
	    DEFPRINT(AST_Conditional, function(self, output){
	        self.condition.print(output);
	        output.space();
	        output.print("?");
	        output.space();
	        self.consequent.print(output);
	        output.space();
	        output.colon();
	        self.alternative.print(output);
	    });
	
	    /* -----[ literals ]----- */
	    DEFPRINT(AST_Array, function(self, output){
	        output.with_square(function(){
	            var a = self.elements, len = a.length;
	            if (len > 0) output.space();
	            a.forEach(function(exp, i){
	                if (i) output.comma();
	                exp.print(output);
	                // If the final element is a hole, we need to make sure it
	                // doesn't look like a trailing comma, by inserting an actual
	                // trailing comma.
	                if (i === len - 1 && exp instanceof AST_Hole)
	                  output.comma();
	            });
	            if (len > 0) output.space();
	        });
	    });
	    DEFPRINT(AST_Object, function(self, output){
	        if (self.properties.length > 0) output.with_block(function(){
	            self.properties.forEach(function(prop, i){
	                if (i) {
	                    output.print(",");
	                    output.newline();
	                }
	                output.indent();
	                prop.print(output);
	            });
	            output.newline();
	        });
	        else output.print("{}");
	    });
	
	    function print_property_name(key, quote, output) {
	        if (output.option("quote_keys")) {
	            output.print_string(key + "");
	        } else if ((typeof key == "number"
	                    || !output.option("beautify")
	                    && +key + "" == key)
	                   && parseFloat(key) >= 0) {
	            output.print(make_num(key));
	        } else if (RESERVED_WORDS(key) ? output.option("screw_ie8") : is_identifier_string(key)) {
	            if (quote && output.option("keep_quoted_props")) {
	                output.print_string(key, quote);
	            } else {
	                output.print_name(key);
	            }
	        } else {
	            output.print_string(key, quote);
	        }
	    }
	
	    DEFPRINT(AST_ObjectKeyVal, function(self, output){
	        print_property_name(self.key, self.quote, output);
	        output.colon();
	        self.value.print(output);
	    });
	    AST_ObjectProperty.DEFMETHOD("_print_getter_setter", function(type, output) {
	        output.print(type);
	        output.space();
	        print_property_name(this.key.name, this.quote, output);
	        this.value._do_print(output, true);
	    });
	    DEFPRINT(AST_ObjectSetter, function(self, output){
	        self._print_getter_setter("set", output);
	    });
	    DEFPRINT(AST_ObjectGetter, function(self, output){
	        self._print_getter_setter("get", output);
	    });
	    DEFPRINT(AST_Symbol, function(self, output){
	        var def = self.definition();
	        output.print_name(def ? def.mangled_name || def.name : self.name);
	    });
	    DEFPRINT(AST_Hole, noop);
	    DEFPRINT(AST_This, function(self, output){
	        output.print("this");
	    });
	    DEFPRINT(AST_Constant, function(self, output){
	        output.print(self.getValue());
	    });
	    DEFPRINT(AST_String, function(self, output){
	        output.print_string(self.getValue(), self.quote, in_directive);
	    });
	    DEFPRINT(AST_Number, function(self, output){
	        if (use_asm && self.start && self.start.raw != null) {
	            output.print(self.start.raw);
	        } else {
	            output.print(make_num(self.getValue()));
	        }
	    });
	
	    function regexp_safe_literal(code) {
	        return [
	            0x5c   , // \
	            0x2f   , // /
	            0x2e   , // .
	            0x2b   , // +
	            0x2a   , // *
	            0x3f   , // ?
	            0x28   , // (
	            0x29   , // )
	            0x5b   , // [
	            0x5d   , // ]
	            0x7b   , // {
	            0x7d   , // }
	            0x24   , // $
	            0x5e   , // ^
	            0x3a   , // :
	            0x7c   , // |
	            0x21   , // !
	            0x0a   , // \n
	            0x0d   , // \r
	            0x00   , // \0
	            0xfeff , // Unicode BOM
	            0x2028 , // unicode "line separator"
	            0x2029 , // unicode "paragraph separator"
	        ].indexOf(code) < 0;
	    };
	
	    DEFPRINT(AST_RegExp, function(self, output){
	        var str = self.getValue().toString();
	        if (output.option("ascii_only")) {
	            str = output.to_ascii(str);
	        } else if (output.option("unescape_regexps")) {
	            str = str.split("\\\\").map(function(str){
	                return str.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, function(s){
	                    var code = parseInt(s.substr(2), 16);
	                    return regexp_safe_literal(code) ? String.fromCharCode(code) : s;
	                });
	            }).join("\\\\");
	        }
	        output.print(str);
	        var p = output.parent();
	        if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self)
	            output.print(" ");
	    });
	
	    function force_statement(stat, output) {
	        if (output.option("bracketize")) {
	            make_block(stat, output);
	        } else {
	            if (!stat || stat instanceof AST_EmptyStatement)
	                output.force_semicolon();
	            else
	                stat.print(output);
	        }
	    };
	
	    // self should be AST_New.  decide if we want to show parens or not.
	    function need_constructor_parens(self, output) {
	        // Always print parentheses with arguments
	        if (self.args.length > 0) return true;
	
	        return output.option("beautify");
	    };
	
	    function best_of(a) {
	        var best = a[0], len = best.length;
	        for (var i = 1; i < a.length; ++i) {
	            if (a[i].length < len) {
	                best = a[i];
	                len = best.length;
	            }
	        }
	        return best;
	    };
	
	    function make_num(num) {
	        var str = num.toString(10), a = [ str.replace(/^0\./, ".").replace('e+', 'e') ], m;
	        if (Math.floor(num) === num) {
	            if (num >= 0) {
	                a.push("0x" + num.toString(16).toLowerCase(), // probably pointless
	                       "0" + num.toString(8)); // same.
	            } else {
	                a.push("-0x" + (-num).toString(16).toLowerCase(), // probably pointless
	                       "-0" + (-num).toString(8)); // same.
	            }
	            if ((m = /^(.*?)(0+)$/.exec(num))) {
	                a.push(m[1] + "e" + m[2].length);
	            }
	        } else if ((m = /^0?\.(0+)(.*)$/.exec(num))) {
	            a.push(m[2] + "e-" + (m[1].length + m[2].length),
	                   str.substr(str.indexOf(".")));
	        }
	        return best_of(a);
	    };
	
	    function make_block(stmt, output) {
	        if (!stmt || stmt instanceof AST_EmptyStatement)
	            output.print("{}");
	        else if (stmt instanceof AST_BlockStatement)
	            stmt.print(output);
	        else output.with_block(function(){
	            output.indent();
	            stmt.print(output);
	            output.newline();
	        });
	    };
	
	    /* -----[ source map generators ]----- */
	
	    function DEFMAP(nodetype, generator) {
	        nodetype.DEFMETHOD("add_source_map", function(stream){
	            generator(this, stream);
	        });
	    };
	
	    // We could easily add info for ALL nodes, but it seems to me that
	    // would be quite wasteful, hence this noop in the base class.
	    DEFMAP(AST_Node, noop);
	
	    function basic_sourcemap_gen(self, output) {
	        output.add_mapping(self.start);
	    };
	
	    // XXX: I'm not exactly sure if we need it for all of these nodes,
	    // or if we should add even more.
	
	    DEFMAP(AST_Directive, basic_sourcemap_gen);
	    DEFMAP(AST_Debugger, basic_sourcemap_gen);
	    DEFMAP(AST_Symbol, basic_sourcemap_gen);
	    DEFMAP(AST_Jump, basic_sourcemap_gen);
	    DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);
	    DEFMAP(AST_LabeledStatement, noop); // since the label symbol will mark it
	    DEFMAP(AST_Lambda, basic_sourcemap_gen);
	    DEFMAP(AST_Switch, basic_sourcemap_gen);
	    DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);
	    DEFMAP(AST_BlockStatement, basic_sourcemap_gen);
	    DEFMAP(AST_Toplevel, noop);
	    DEFMAP(AST_New, basic_sourcemap_gen);
	    DEFMAP(AST_Try, basic_sourcemap_gen);
	    DEFMAP(AST_Catch, basic_sourcemap_gen);
	    DEFMAP(AST_Finally, basic_sourcemap_gen);
	    DEFMAP(AST_Definitions, basic_sourcemap_gen);
	    DEFMAP(AST_Constant, basic_sourcemap_gen);
	    DEFMAP(AST_ObjectSetter, function(self, output){
	        output.add_mapping(self.start, self.key.name);
	    });
	    DEFMAP(AST_ObjectGetter, function(self, output){
	        output.add_mapping(self.start, self.key.name);
	    });
	    DEFMAP(AST_ObjectProperty, function(self, output){
	        output.add_mapping(self.start, self.key);
	    });
	
	})();
	
	
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	function Compressor(options, false_by_default) {
	    if (!(this instanceof Compressor))
	        return new Compressor(options, false_by_default);
	    TreeTransformer.call(this, this.before, this.after);
	    this.options = defaults(options, {
	        angular       : false,
	        booleans      : !false_by_default,
	        cascade       : !false_by_default,
	        collapse_vars : !false_by_default,
	        comparisons   : !false_by_default,
	        conditionals  : !false_by_default,
	        dead_code     : !false_by_default,
	        drop_console  : false,
	        drop_debugger : !false_by_default,
	        evaluate      : !false_by_default,
	        expression    : false,
	        global_defs   : {},
	        hoist_funs    : !false_by_default,
	        hoist_vars    : false,
	        if_return     : !false_by_default,
	        join_vars     : !false_by_default,
	        keep_fargs    : true,
	        keep_fnames   : false,
	        keep_infinity : false,
	        loops         : !false_by_default,
	        negate_iife   : !false_by_default,
	        passes        : 1,
	        properties    : !false_by_default,
	        pure_getters  : !false_by_default && "strict",
	        pure_funcs    : null,
	        reduce_vars   : !false_by_default,
	        screw_ie8     : true,
	        sequences     : !false_by_default,
	        side_effects  : !false_by_default,
	        switches      : !false_by_default,
	        top_retain    : null,
	        toplevel      : !!(options && options["top_retain"]),
	        unsafe        : false,
	        unsafe_comps  : false,
	        unsafe_math   : false,
	        unsafe_proto  : false,
	        unsafe_regexp : false,
	        unused        : !false_by_default,
	        warnings      : true,
	    }, true);
	    var pure_funcs = this.options["pure_funcs"];
	    if (typeof pure_funcs == "function") {
	        this.pure_funcs = pure_funcs;
	    } else {
	        this.pure_funcs = pure_funcs ? function(node) {
	            return pure_funcs.indexOf(node.expression.print_to_string()) < 0;
	        } : return_true;
	    }
	    var top_retain = this.options["top_retain"];
	    if (top_retain instanceof RegExp) {
	        this.top_retain = function(def) {
	            return top_retain.test(def.name);
	        };
	    } else if (typeof top_retain == "function") {
	        this.top_retain = top_retain;
	    } else if (top_retain) {
	        if (typeof top_retain == "string") {
	            top_retain = top_retain.split(/,/);
	        }
	        this.top_retain = function(def) {
	            return top_retain.indexOf(def.name) >= 0;
	        };
	    }
	    var sequences = this.options["sequences"];
	    this.sequences_limit = sequences == 1 ? 200 : sequences | 0;
	    this.warnings_produced = {};
	};
	
	Compressor.prototype = new TreeTransformer;
	merge(Compressor.prototype, {
	    option: function(key) { return this.options[key] },
	    compress: function(node) {
	        if (this.option("expression")) {
	            node = node.process_expression(true);
	        }
	        var passes = +this.options.passes || 1;
	        for (var pass = 0; pass < passes && pass < 3; ++pass) {
	            if (pass > 0 || this.option("reduce_vars"))
	                node.reset_opt_flags(this, true);
	            node = node.transform(this);
	        }
	        if (this.option("expression")) {
	            node = node.process_expression(false);
	        }
	        return node;
	    },
	    info: function() {
	        if (this.options.warnings == "verbose") {
	            AST_Node.warn.apply(AST_Node, arguments);
	        }
	    },
	    warn: function(text, props) {
	        if (this.options.warnings) {
	            // only emit unique warnings
	            var message = string_template(text, props);
	            if (!(message in this.warnings_produced)) {
	                this.warnings_produced[message] = true;
	                AST_Node.warn.apply(AST_Node, arguments);
	            }
	        }
	    },
	    clear_warnings: function() {
	        this.warnings_produced = {};
	    },
	    before: function(node, descend, in_list) {
	        if (node._squeezed) return node;
	        var was_scope = false;
	        if (node instanceof AST_Scope) {
	            node = node.hoist_declarations(this);
	            was_scope = true;
	        }
	        // Before https://github.com/mishoo/UglifyJS2/pull/1602 AST_Node.optimize()
	        // would call AST_Node.transform() if a different instance of AST_Node is
	        // produced after OPT().
	        // This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.
	        // Migrate and defer all children's AST_Node.transform() to below, which
	        // will now happen after this parent AST_Node has been properly substituted
	        // thus gives a consistent AST snapshot.
	        descend(node, this);
	        // Existing code relies on how AST_Node.optimize() worked, and omitting the
	        // following replacement call would result in degraded efficiency of both
	        // output and performance.
	        descend(node, this);
	        var opt = node.optimize(this);
	        if (was_scope && opt instanceof AST_Scope) {
	            opt.drop_unused(this);
	            descend(opt, this);
	        }
	        if (opt === node) opt._squeezed = true;
	        return opt;
	    }
	});
	
	(function(){
	
	    function OPT(node, optimizer) {
	        node.DEFMETHOD("optimize", function(compressor){
	            var self = this;
	            if (self._optimized) return self;
	            if (compressor.has_directive("use asm")) return self;
	            var opt = optimizer(self, compressor);
	            opt._optimized = true;
	            return opt;
	        });
	    };
	
	    OPT(AST_Node, function(self, compressor){
	        return self;
	    });
	
	    AST_Node.DEFMETHOD("equivalent_to", function(node){
	        return this.TYPE == node.TYPE && this.print_to_string() == node.print_to_string();
	    });
	
	    AST_Node.DEFMETHOD("process_expression", function(insert, compressor) {
	        var self = this;
	        var tt = new TreeTransformer(function(node) {
	            if (insert && node instanceof AST_SimpleStatement) {
	                return make_node(AST_Return, node, {
	                    value: node.body
	                });
	            }
	            if (!insert && node instanceof AST_Return) {
	                if (compressor) {
	                    var value = node.value && node.value.drop_side_effect_free(compressor, true);
	                    return value ? make_node(AST_SimpleStatement, node, {
	                        body: value
	                    }) : make_node(AST_EmptyStatement, node);
	                }
	                return make_node(AST_SimpleStatement, node, {
	                    body: node.value || make_node(AST_UnaryPrefix, node, {
	                        operator: "void",
	                        expression: make_node(AST_Number, node, {
	                            value: 0
	                        })
	                    })
	                });
	            }
	            if (node instanceof AST_Lambda && node !== self) {
	                return node;
	            }
	            if (node instanceof AST_Block) {
	                var index = node.body.length - 1;
	                if (index >= 0) {
	                    node.body[index] = node.body[index].transform(tt);
	                }
	            }
	            if (node instanceof AST_If) {
	                node.body = node.body.transform(tt);
	                if (node.alternative) {
	                    node.alternative = node.alternative.transform(tt);
	                }
	            }
	            if (node instanceof AST_With) {
	                node.body = node.body.transform(tt);
	            }
	            return node;
	        });
	        return self.transform(tt);
	    });
	
	    AST_Node.DEFMETHOD("reset_opt_flags", function(compressor, rescan){
	        var reduce_vars = rescan && compressor.option("reduce_vars");
	        var toplevel = compressor.option("toplevel");
	        var safe_ids = Object.create(null);
	        var suppressor = new TreeWalker(function(node) {
	            if (node instanceof AST_Symbol) {
	                var d = node.definition();
	                if (node instanceof AST_SymbolRef) d.references.push(node);
	                d.fixed = false;
	            }
	        });
	        var tw = new TreeWalker(function(node, descend){
	            node._squeezed = false;
	            node._optimized = false;
	            if (reduce_vars) {
	                if (node instanceof AST_Toplevel) node.globals.each(reset_def);
	                if (node instanceof AST_Scope) node.variables.each(reset_def);
	                if (node instanceof AST_SymbolRef) {
	                    var d = node.definition();
	                    d.references.push(node);
	                    if (d.fixed === undefined || !is_safe(d)
	                        || is_modified(node, 0, node.fixed_value() instanceof AST_Lambda)) {
	                        d.fixed = false;
	                    } else {
	                        var parent = tw.parent();
	                        if (parent instanceof AST_Assign && parent.operator == "=" && node === parent.right
	                            || parent instanceof AST_Call && node !== parent.expression
	                            || parent instanceof AST_Return && node === parent.value && node.scope !== d.scope
	                            || parent instanceof AST_VarDef && node === parent.value) {
	                            d.escaped = true;
	                        }
	                    }
	                }
	                if (node instanceof AST_SymbolCatch) {
	                    node.definition().fixed = false;
	                }
	                if (node instanceof AST_VarDef) {
	                    var d = node.name.definition();
	                    if (d.fixed == null) {
	                        if (node.value) {
	                            d.fixed = function() {
	                                return node.value;
	                            };
	                            mark(d, false);
	                            descend();
	                        } else {
	                            d.fixed = null;
	                        }
	                        mark(d, true);
	                        return true;
	                    } else if (node.value) {
	                        d.fixed = false;
	                    }
	                }
	                if (node instanceof AST_Defun) {
	                    var d = node.name.definition();
	                    if (!toplevel && d.global || is_safe(d)) {
	                        d.fixed = false;
	                    } else {
	                        d.fixed = node;
	                        mark(d, true);
	                    }
	                    var save_ids = safe_ids;
	                    safe_ids = Object.create(null);
	                    descend();
	                    safe_ids = save_ids;
	                    return true;
	                }
	                if (node instanceof AST_Function) {
	                    push();
	                    var iife;
	                    if (!node.name
	                        && (iife = tw.parent()) instanceof AST_Call
	                        && iife.expression === node) {
	                        // Virtually turn IIFE parameters into variable definitions:
	                        //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()
	                        // So existing transformation rules can work on them.
	                        node.argnames.forEach(function(arg, i) {
	                            var d = arg.definition();
	                            if (!node.uses_arguments && d.fixed === undefined) {
	                                d.fixed = function() {
	                                    return iife.args[i] || make_node(AST_Undefined, iife);
	                                };
	                                mark(d, true);
	                            } else {
	                                d.fixed = false;
	                            }
	                        });
	                    }
	                    descend();
	                    pop();
	                    return true;
	                }
	                if (node instanceof AST_Accessor) {
	                    var save_ids = safe_ids;
	                    safe_ids = Object.create(null);
	                    descend();
	                    safe_ids = save_ids;
	                    return true;
	                }
	                if (node instanceof AST_Binary
	                    && (node.operator == "&&" || node.operator == "||")) {
	                    node.left.walk(tw);
	                    push();
	                    node.right.walk(tw);
	                    pop();
	                    return true;
	                }
	                if (node instanceof AST_Conditional) {
	                    node.condition.walk(tw);
	                    push();
	                    node.consequent.walk(tw);
	                    pop();
	                    push();
	                    node.alternative.walk(tw);
	                    pop();
	                    return true;
	                }
	                if (node instanceof AST_If || node instanceof AST_DWLoop) {
	                    node.condition.walk(tw);
	                    push();
	                    node.body.walk(tw);
	                    pop();
	                    if (node.alternative) {
	                        push();
	                        node.alternative.walk(tw);
	                        pop();
	                    }
	                    return true;
	                }
	                if (node instanceof AST_LabeledStatement) {
	                    push();
	                    node.body.walk(tw);
	                    pop();
	                    return true;
	                }
	                if (node instanceof AST_For) {
	                    if (node.init) node.init.walk(tw);
	                    push();
	                    if (node.condition) node.condition.walk(tw);
	                    node.body.walk(tw);
	                    if (node.step) node.step.walk(tw);
	                    pop();
	                    return true;
	                }
	                if (node instanceof AST_ForIn) {
	                    node.init.walk(suppressor);
	                    node.object.walk(tw);
	                    push();
	                    node.body.walk(tw);
	                    pop();
	                    return true;
	                }
	                if (node instanceof AST_Try) {
	                    push();
	                    walk_body(node, tw);
	                    pop();
	                    if (node.bcatch) {
	                        push();
	                        node.bcatch.walk(tw);
	                        pop();
	                    }
	                    if (node.bfinally) node.bfinally.walk(tw);
	                    return true;
	                }
	                if (node instanceof AST_SwitchBranch) {
	                    push();
	                    descend();
	                    pop();
	                    return true;
	                }
	            }
	        });
	        this.walk(tw);
	
	        function mark(def, safe) {
	            safe_ids[def.id] = safe;
	        }
	
	        function is_safe(def) {
	            if (safe_ids[def.id]) {
	                if (def.fixed == null) {
	                    var orig = def.orig[0];
	                    if (orig instanceof AST_SymbolFunarg || orig.name == "arguments") return false;
	                    def.fixed = make_node(AST_Undefined, orig);
	                }
	                return true;
	            }
	        }
	
	        function push() {
	            safe_ids = Object.create(safe_ids);
	        }
	
	        function pop() {
	            safe_ids = Object.getPrototypeOf(safe_ids);
	        }
	
	        function reset_def(def) {
	            def.escaped = false;
	            if (def.scope.uses_eval) {
	                def.fixed = false;
	            } else if (toplevel || !def.global || def.orig[0] instanceof AST_SymbolConst) {
	                def.fixed = undefined;
	            } else {
	                def.fixed = false;
	            }
	            def.references = [];
	            def.should_replace = undefined;
	        }
	
	        function is_modified(node, level, func) {
	            var parent = tw.parent(level);
	            if (is_lhs(node, parent)
	                || !func && parent instanceof AST_Call && parent.expression === node) {
	                return true;
	            } else if (parent instanceof AST_PropAccess && parent.expression === node) {
	                return !func && is_modified(parent, level + 1);
	            }
	        }
	    });
	
	    AST_SymbolRef.DEFMETHOD("fixed_value", function() {
	        var fixed = this.definition().fixed;
	        if (!fixed || fixed instanceof AST_Node) return fixed;
	        return fixed();
	    });
	
	    function is_reference_const(ref) {
	        if (!(ref instanceof AST_SymbolRef)) return false;
	        var orig = ref.definition().orig;
	        for (var i = orig.length; --i >= 0;) {
	            if (orig[i] instanceof AST_SymbolConst) return true;
	        }
	    }
	
	    function find_variable(compressor, name) {
	        var scope, i = 0;
	        while (scope = compressor.parent(i++)) {
	            if (scope instanceof AST_Scope) break;
	            if (scope instanceof AST_Catch) {
	                scope = scope.argname.definition().scope;
	                break;
	            }
	        }
	        return scope.find_variable(name);
	    }
	
	    function make_node(ctor, orig, props) {
	        if (!props) props = {};
	        if (orig) {
	            if (!props.start) props.start = orig.start;
	            if (!props.end) props.end = orig.end;
	        }
	        return new ctor(props);
	    };
	
	    function make_node_from_constant(val, orig) {
	        switch (typeof val) {
	          case "string":
	            return make_node(AST_String, orig, {
	                value: val
	            });
	          case "number":
	            if (isNaN(val)) return make_node(AST_NaN, orig);
	            if (isFinite(val)) {
	                return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {
	                    operator: "-",
	                    expression: make_node(AST_Number, orig, { value: -val })
	                }) : make_node(AST_Number, orig, { value: val });
	            }
	            return val < 0 ? make_node(AST_UnaryPrefix, orig, {
	                operator: "-",
	                expression: make_node(AST_Infinity, orig)
	            }) : make_node(AST_Infinity, orig);
	          case "boolean":
	            return make_node(val ? AST_True : AST_False, orig);
	          case "undefined":
	            return make_node(AST_Undefined, orig);
	          default:
	            if (val === null) {
	                return make_node(AST_Null, orig, { value: null });
	            }
	            if (val instanceof RegExp) {
	                return make_node(AST_RegExp, orig, { value: val });
	            }
	            throw new Error(string_template("Can't handle constant of type: {type}", {
	                type: typeof val
	            }));
	        }
	    };
	
	    // we shouldn't compress (1,func)(something) to
	    // func(something) because that changes the meaning of
	    // the func (becomes lexical instead of global).
	    function maintain_this_binding(parent, orig, val) {
	        if (parent instanceof AST_UnaryPrefix && parent.operator == "delete"
	            || parent instanceof AST_Call && parent.expression === orig
	                && (val instanceof AST_PropAccess || val instanceof AST_SymbolRef && val.name == "eval")) {
	            return make_node(AST_Seq, orig, {
	                car: make_node(AST_Number, orig, {
	                    value: 0
	                }),
	                cdr: val
	            });
	        }
	        return val;
	    }
	
	    function as_statement_array(thing) {
	        if (thing === null) return [];
	        if (thing instanceof AST_BlockStatement) return thing.body;
	        if (thing instanceof AST_EmptyStatement) return [];
	        if (thing instanceof AST_Statement) return [ thing ];
	        throw new Error("Can't convert thing to statement array");
	    };
	
	    function is_empty(thing) {
	        if (thing === null) return true;
	        if (thing instanceof AST_EmptyStatement) return true;
	        if (thing instanceof AST_BlockStatement) return thing.body.length == 0;
	        return false;
	    };
	
	    function loop_body(x) {
	        if (x instanceof AST_Switch) return x;
	        if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {
	            return (x.body instanceof AST_BlockStatement ? x.body : x);
	        }
	        return x;
	    };
	
	    function is_iife_call(node) {
	        if (node instanceof AST_Call && !(node instanceof AST_New)) {
	            return node.expression instanceof AST_Function || is_iife_call(node.expression);
	        }
	        return false;
	    }
	
	    function tighten_body(statements, compressor) {
	        var CHANGED, max_iter = 10;
	        do {
	            CHANGED = false;
	            if (compressor.option("angular")) {
	                statements = process_for_angular(statements);
	            }
	            statements = eliminate_spurious_blocks(statements);
	            if (compressor.option("dead_code")) {
	                statements = eliminate_dead_code(statements, compressor);
	            }
	            if (compressor.option("if_return")) {
	                statements = handle_if_return(statements, compressor);
	            }
	            if (compressor.sequences_limit > 0) {
	                statements = sequencesize(statements, compressor);
	            }
	            if (compressor.option("join_vars")) {
	                statements = join_consecutive_vars(statements, compressor);
	            }
	            if (compressor.option("collapse_vars")) {
	                statements = collapse_single_use_vars(statements, compressor);
	            }
	        } while (CHANGED && max_iter-- > 0);
	
	        return statements;
	
	        function collapse_single_use_vars(statements, compressor) {
	            // Iterate statements backwards looking for a statement with a var/const
	            // declaration immediately preceding it. Grab the rightmost var definition
	            // and if it has exactly one reference then attempt to replace its reference
	            // in the statement with the var value and then erase the var definition.
	
	            var self = compressor.self();
	            var var_defs_removed = false;
	            var toplevel = compressor.option("toplevel");
	            for (var stat_index = statements.length; --stat_index >= 0;) {
	                var stat = statements[stat_index];
	                if (stat instanceof AST_Definitions) continue;
	
	                // Process child blocks of statement if present.
	                [stat, stat.body, stat.alternative, stat.bcatch, stat.bfinally].forEach(function(node) {
	                    node && node.body && collapse_single_use_vars(node.body, compressor);
	                });
	
	                // The variable definition must precede a statement.
	                if (stat_index <= 0) break;
	                var prev_stat_index = stat_index - 1;
	                var prev_stat = statements[prev_stat_index];
	                if (!(prev_stat instanceof AST_Definitions)) continue;
	                var var_defs = prev_stat.definitions;
	                if (var_defs == null) continue;
	
	                var var_names_seen = {};
	                var side_effects_encountered = false;
	                var lvalues_encountered = false;
	                var lvalues = {};
	
	                // Scan variable definitions from right to left.
	                for (var var_defs_index = var_defs.length; --var_defs_index >= 0;) {
	
	                    // Obtain var declaration and var name with basic sanity check.
	                    var var_decl = var_defs[var_defs_index];
	                    if (var_decl.value == null) break;
	                    var var_name = var_decl.name.name;
	                    if (!var_name || !var_name.length) break;
	
	                    // Bail if we've seen a var definition of same name before.
	                    if (var_name in var_names_seen) break;
	                    var_names_seen[var_name] = true;
	
	                    // Only interested in cases with just one reference to the variable.
	                    var def = self.find_variable && self.find_variable(var_name);
	                    if (!def || !def.references || def.references.length !== 1
	                        || var_name == "arguments" || (!toplevel && def.global)) {
	                        side_effects_encountered = true;
	                        continue;
	                    }
	                    var ref = def.references[0];
	
	                    // Don't replace ref if eval() or with statement in scope.
	                    if (ref.scope.uses_eval || ref.scope.uses_with) break;
	
	                    // Constant single use vars can be replaced in any scope.
	                    if (var_decl.value.is_constant()) {
	                        var ctt = new TreeTransformer(function(node) {
	                            var parent = ctt.parent();
	                            if (parent instanceof AST_IterationStatement
	                                && (parent.condition === node || parent.init === node)) {
	                                return node;
	                            }
	                            if (node === ref)
	                                return replace_var(node, parent, true);
	                        });
	                        stat.transform(ctt);
	                        continue;
	                    }
	
	                    // Restrict var replacement to constants if side effects encountered.
	                    if (side_effects_encountered |= lvalues_encountered) continue;
	
	                    var value_has_side_effects = var_decl.value.has_side_effects(compressor);
	                    // Non-constant single use vars can only be replaced in same scope.
	                    if (ref.scope !== self) {
	                        side_effects_encountered |= value_has_side_effects;
	                        continue;
	                    }
	
	                    // Detect lvalues in var value.
	                    var tw = new TreeWalker(function(node){
	                        if (node instanceof AST_SymbolRef && is_lvalue(node, tw.parent())) {
	                            lvalues[node.name] = lvalues_encountered = true;
	                        }
	                    });
	                    var_decl.value.walk(tw);
	
	                    // Replace the non-constant single use var in statement if side effect free.
	                    var unwind = false;
	                    var tt = new TreeTransformer(
	                        function preorder(node) {
	                            if (unwind) return node;
	                            var parent = tt.parent();
	                            if (node instanceof AST_Lambda
	                                || node instanceof AST_Try
	                                || node instanceof AST_With
	                                || node instanceof AST_Case
	                                || node instanceof AST_IterationStatement
	                                || (parent instanceof AST_If          && node !== parent.condition)
	                                || (parent instanceof AST_Conditional && node !== parent.condition)
	                                || (node instanceof AST_SymbolRef
	                                    && value_has_side_effects
	                                    && !are_references_in_scope(node.definition(), self))
	                                || (parent instanceof AST_Binary
	                                    && (parent.operator == "&&" || parent.operator == "||")
	                                    && node === parent.right)
	                                || (parent instanceof AST_Switch && node !== parent.expression)) {
	                                return side_effects_encountered = unwind = true, node;
	                            }
	                            function are_references_in_scope(def, scope) {
	                                if (def.orig.length === 1
	                                    && def.orig[0] instanceof AST_SymbolDefun) return true;
	                                if (def.scope !== scope) return false;
	                                var refs = def.references;
	                                for (var i = 0, len = refs.length; i < len; i++) {
	                                    if (refs[i].scope !== scope) return false;
	                                }
	                                return true;
	                            }
	                        },
	                        function postorder(node) {
	                            if (unwind) return node;
	                            if (node === ref)
	                                return unwind = true, replace_var(node, tt.parent(), false);
	                            if (side_effects_encountered |= node.has_side_effects(compressor))
	                                return unwind = true, node;
	                            if (lvalues_encountered && node instanceof AST_SymbolRef && node.name in lvalues) {
	                                side_effects_encountered = true;
	                                return unwind = true, node;
	                            }
	                        }
	                    );
	                    stat.transform(tt);
	                }
	            }
	
	            // Remove extraneous empty statments in block after removing var definitions.
	            // Leave at least one statement in `statements`.
	            if (var_defs_removed) for (var i = statements.length; --i >= 0;) {
	                if (statements.length > 1 && statements[i] instanceof AST_EmptyStatement)
	                    statements.splice(i, 1);
	            }
	
	            return statements;
	
	            function is_lvalue(node, parent) {
	                return node instanceof AST_SymbolRef && is_lhs(node, parent);
	            }
	            function replace_var(node, parent, is_constant) {
	                if (is_lvalue(node, parent)) return node;
	
	                // Remove var definition and return its value to the TreeTransformer to replace.
	                var value = maintain_this_binding(parent, node, var_decl.value);
	                var_decl.value = null;
	
	                var_defs.splice(var_defs_index, 1);
	                if (var_defs.length === 0) {
	                    statements[prev_stat_index] = make_node(AST_EmptyStatement, self);
	                    var_defs_removed = true;
	                }
	                // Further optimize statement after substitution.
	                stat.reset_opt_flags(compressor);
	
	                compressor.info("Collapsing " + (is_constant ? "constant" : "variable") +
	                    " " + var_name + " [{file}:{line},{col}]", node.start);
	                CHANGED = true;
	                return value;
	            }
	        }
	
	        function process_for_angular(statements) {
	            function has_inject(comment) {
	                return /@ngInject/.test(comment.value);
	            }
	            function make_arguments_names_list(func) {
	                return func.argnames.map(function(sym){
	                    return make_node(AST_String, sym, { value: sym.name });
	                });
	            }
	            function make_array(orig, elements) {
	                return make_node(AST_Array, orig, { elements: elements });
	            }
	            function make_injector(func, name) {
	                return make_node(AST_SimpleStatement, func, {
	                    body: make_node(AST_Assign, func, {
	                        operator: "=",
	                        left: make_node(AST_Dot, name, {
	                            expression: make_node(AST_SymbolRef, name, name),
	                            property: "$inject"
	                        }),
	                        right: make_array(func, make_arguments_names_list(func))
	                    })
	                });
	            }
	            function check_expression(body) {
	                if (body && body.args) {
	                    // if this is a function call check all of arguments passed
	                    body.args.forEach(function(argument, index, array) {
	                        var comments = argument.start.comments_before;
	                        // if the argument is function preceded by @ngInject
	                        if (argument instanceof AST_Lambda && comments.length && has_inject(comments[0])) {
	                            // replace the function with an array of names of its parameters and function at the end
	                            array[index] = make_array(argument, make_arguments_names_list(argument).concat(argument));
	                        }
	                    });
	                    // if this is chained call check previous one recursively
	                    if (body.expression && body.expression.expression) {
	                        check_expression(body.expression.expression);
	                    }
	                }
	            }
	            return statements.reduce(function(a, stat){
	                a.push(stat);
	
	                if (stat.body && stat.body.args) {
	                    check_expression(stat.body);
	                } else {
	                    var token = stat.start;
	                    var comments = token.comments_before;
	                    if (comments && comments.length > 0) {
	                        var last = comments.pop();
	                        if (has_inject(last)) {
	                            // case 1: defun
	                            if (stat instanceof AST_Defun) {
	                                a.push(make_injector(stat, stat.name));
	                            }
	                            else if (stat instanceof AST_Definitions) {
	                                stat.definitions.forEach(function(def) {
	                                    if (def.value && def.value instanceof AST_Lambda) {
	                                        a.push(make_injector(def.value, def.name));
	                                    }
	                                });
	                            }
	                            else {
	                                compressor.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]", token);
	                            }
	                        }
	                    }
	                }
	
	                return a;
	            }, []);
	        }
	
	        function eliminate_spurious_blocks(statements) {
	            var seen_dirs = [];
	            return statements.reduce(function(a, stat){
	                if (stat instanceof AST_BlockStatement) {
	                    CHANGED = true;
	                    a.push.apply(a, eliminate_spurious_blocks(stat.body));
	                } else if (stat instanceof AST_EmptyStatement) {
	                    CHANGED = true;
	                } else if (stat instanceof AST_Directive) {
	                    if (seen_dirs.indexOf(stat.value) < 0) {
	                        a.push(stat);
	                        seen_dirs.push(stat.value);
	                    } else {
	                        CHANGED = true;
	                    }
	                } else {
	                    a.push(stat);
	                }
	                return a;
	            }, []);
	        };
	
	        function handle_if_return(statements, compressor) {
	            var self = compressor.self();
	            var multiple_if_returns = has_multiple_if_returns(statements);
	            var in_lambda = self instanceof AST_Lambda;
	            var ret = []; // Optimized statements, build from tail to front
	            loop: for (var i = statements.length; --i >= 0;) {
	                var stat = statements[i];
	                switch (true) {
	                  case (in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0):
	                    CHANGED = true;
	                    // note, ret.length is probably always zero
	                    // because we drop unreachable code before this
	                    // step.  nevertheless, it's good to check.
	                    continue loop;
	                  case stat instanceof AST_If:
	                    if (stat.body instanceof AST_Return) {
	                        //---
	                        // pretty silly case, but:
	                        // if (foo()) return; return; ==> foo(); return;
	                        if (((in_lambda && ret.length == 0)
	                             || (ret[0] instanceof AST_Return && !ret[0].value))
	                            && !stat.body.value && !stat.alternative) {
	                            CHANGED = true;
	                            var cond = make_node(AST_SimpleStatement, stat.condition, {
	                                body: stat.condition
	                            });
	                            ret.unshift(cond);
	                            continue loop;
	                        }
	                        //---
	                        // if (foo()) return x; return y; ==> return foo() ? x : y;
	                        if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {
	                            CHANGED = true;
	                            stat = stat.clone();
	                            stat.alternative = ret[0];
	                            ret[0] = stat.transform(compressor);
	                            continue loop;
	                        }
	                        //---
	                        // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;
	                        if (multiple_if_returns && (ret.length == 0 || ret[0] instanceof AST_Return)
	                            && stat.body.value && !stat.alternative && in_lambda) {
	                            CHANGED = true;
	                            stat = stat.clone();
	                            stat.alternative = ret[0] || make_node(AST_Return, stat, {
	                                value: null
	                            });
	                            ret[0] = stat.transform(compressor);
	                            continue loop;
	                        }
	                        //---
	                        // if (foo()) return; [ else x... ]; y... ==> if (!foo()) { x...; y... }
	                        if (!stat.body.value && in_lambda) {
	                            CHANGED = true;
	                            stat = stat.clone();
	                            stat.condition = stat.condition.negate(compressor);
	                            var body = as_statement_array(stat.alternative).concat(ret);
	                            var funs = extract_functions_from_statement_array(body);
	                            stat.body = make_node(AST_BlockStatement, stat, {
	                                body: body
	                            });
	                            stat.alternative = null;
	                            ret = funs.concat([ stat.transform(compressor) ]);
	                            continue loop;
	                        }
	
	                        //---
	                        // if (a) return b; if (c) return d; e; ==> return a ? b : c ? d : void e;
	                        //
	                        // if sequences is not enabled, this can lead to an endless loop (issue #866).
	                        // however, with sequences on this helps producing slightly better output for
	                        // the example code.
	                        if (compressor.option("sequences")
	                            && i > 0 && statements[i - 1] instanceof AST_If && statements[i - 1].body instanceof AST_Return
	                            && ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement
	                            && !stat.alternative) {
	                            CHANGED = true;
	                            ret.push(make_node(AST_Return, ret[0], {
	                                value: null
	                            }).transform(compressor));
	                            ret.unshift(stat);
	                            continue loop;
	                        }
	                    }
	
	                    var ab = aborts(stat.body);
	                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab) : null;
	                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
	                               || (ab instanceof AST_Continue && self === loop_body(lct))
	                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
	                        if (ab.label) {
	                            remove(ab.label.thedef.references, ab);
	                        }
	                        CHANGED = true;
	                        var body = as_statement_array(stat.body).slice(0, -1);
	                        stat = stat.clone();
	                        stat.condition = stat.condition.negate(compressor);
	                        stat.body = make_node(AST_BlockStatement, stat, {
	                            body: as_statement_array(stat.alternative).concat(ret)
	                        });
	                        stat.alternative = make_node(AST_BlockStatement, stat, {
	                            body: body
	                        });
	                        ret = [ stat.transform(compressor) ];
	                        continue loop;
	                    }
	
	                    var ab = aborts(stat.alternative);
	                    var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab) : null;
	                    if (ab && ((ab instanceof AST_Return && !ab.value && in_lambda)
	                               || (ab instanceof AST_Continue && self === loop_body(lct))
	                               || (ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct))) {
	                        if (ab.label) {
	                            remove(ab.label.thedef.references, ab);
	                        }
	                        CHANGED = true;
	                        stat = stat.clone();
	                        stat.body = make_node(AST_BlockStatement, stat.body, {
	                            body: as_statement_array(stat.body).concat(ret)
	                        });
	                        stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
	                            body: as_statement_array(stat.alternative).slice(0, -1)
	                        });
	                        ret = [ stat.transform(compressor) ];
	                        continue loop;
	                    }
	
	                    ret.unshift(stat);
	                    break;
	                  default:
	                    ret.unshift(stat);
	                    break;
	                }
	            }
	            return ret;
	
	            function has_multiple_if_returns(statements) {
	                var n = 0;
	                for (var i = statements.length; --i >= 0;) {
	                    var stat = statements[i];
	                    if (stat instanceof AST_If && stat.body instanceof AST_Return) {
	                        if (++n > 1) return true;
	                    }
	                }
	                return false;
	            }
	        };
	
	        function eliminate_dead_code(statements, compressor) {
	            var has_quit = false;
	            var orig = statements.length;
	            var self = compressor.self();
	            statements = statements.reduce(function(a, stat){
	                if (has_quit) {
	                    extract_declarations_from_unreachable_code(compressor, stat, a);
	                } else {
	                    if (stat instanceof AST_LoopControl) {
	                        var lct = compressor.loopcontrol_target(stat);
	                        if ((stat instanceof AST_Break
	                             && !(lct instanceof AST_IterationStatement)
	                             && loop_body(lct) === self) || (stat instanceof AST_Continue
	                                                             && loop_body(lct) === self)) {
	                            if (stat.label) {
	                                remove(stat.label.thedef.references, stat);
	                            }
	                        } else {
	                            a.push(stat);
	                        }
	                    } else {
	                        a.push(stat);
	                    }
	                    if (aborts(stat)) has_quit = true;
	                }
	                return a;
	            }, []);
	            CHANGED = statements.length != orig;
	            return statements;
	        };
	
	        function sequencesize(statements, compressor) {
	            if (statements.length < 2) return statements;
	            var seq = [], ret = [];
	            function push_seq() {
	                seq = AST_Seq.from_array(seq);
	                if (seq) ret.push(make_node(AST_SimpleStatement, seq, {
	                    body: seq
	                }));
	                seq = [];
	            };
	            statements.forEach(function(stat){
	                if (stat instanceof AST_SimpleStatement) {
	                    if (seqLength(seq) >= compressor.sequences_limit) push_seq();
	                    var body = stat.body;
	                    if (seq.length > 0) body = body.drop_side_effect_free(compressor);
	                    if (body) seq.push(body);
	                } else {
	                    push_seq();
	                    ret.push(stat);
	                }
	            });
	            push_seq();
	            ret = sequencesize_2(ret, compressor);
	            CHANGED = ret.length != statements.length;
	            return ret;
	        };
	
	        function seqLength(a) {
	            for (var len = 0, i = 0; i < a.length; ++i) {
	                var stat = a[i];
	                if (stat instanceof AST_Seq) {
	                    len += stat.len();
	                } else {
	                    len++;
	                }
	            }
	            return len;
	        };
	
	        function sequencesize_2(statements, compressor) {
	            function cons_seq(right) {
	                ret.pop();
	                var left = prev.body;
	                if (left instanceof AST_Seq) {
	                    left.add(right);
	                } else {
	                    left = AST_Seq.cons(left, right);
	                }
	                return left.transform(compressor);
	            };
	            var ret = [], prev = null;
	            statements.forEach(function(stat){
	                if (prev) {
	                    if (stat instanceof AST_For) {
	                        var opera = {};
	                        try {
	                            prev.body.walk(new TreeWalker(function(node){
	                                if (node instanceof AST_Binary && node.operator == "in")
	                                    throw opera;
	                            }));
	                            if (stat.init && !(stat.init instanceof AST_Definitions)) {
	                                stat.init = cons_seq(stat.init);
	                            }
	                            else if (!stat.init) {
	                                stat.init = prev.body.drop_side_effect_free(compressor);
	                                ret.pop();
	                            }
	                        } catch(ex) {
	                            if (ex !== opera) throw ex;
	                        }
	                    }
	                    else if (stat instanceof AST_If) {
	                        stat.condition = cons_seq(stat.condition);
	                    }
	                    else if (stat instanceof AST_With) {
	                        stat.expression = cons_seq(stat.expression);
	                    }
	                    else if (stat instanceof AST_Exit && stat.value) {
	                        stat.value = cons_seq(stat.value);
	                    }
	                    else if (stat instanceof AST_Exit) {
	                        stat.value = cons_seq(make_node(AST_Undefined, stat).transform(compressor));
	                    }
	                    else if (stat instanceof AST_Switch) {
	                        stat.expression = cons_seq(stat.expression);
	                    }
	                }
	                ret.push(stat);
	                prev = stat instanceof AST_SimpleStatement ? stat : null;
	            });
	            return ret;
	        };
	
	        function join_consecutive_vars(statements, compressor) {
	            var prev = null;
	            return statements.reduce(function(a, stat){
	                if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {
	                    prev.definitions = prev.definitions.concat(stat.definitions);
	                    CHANGED = true;
	                }
	                else if (stat instanceof AST_For
	                         && prev instanceof AST_Var
	                         && (!stat.init || stat.init.TYPE == prev.TYPE)) {
	                    CHANGED = true;
	                    a.pop();
	                    if (stat.init) {
	                        stat.init.definitions = prev.definitions.concat(stat.init.definitions);
	                    } else {
	                        stat.init = prev;
	                    }
	                    a.push(stat);
	                    prev = stat;
	                }
	                else {
	                    prev = stat;
	                    a.push(stat);
	                }
	                return a;
	            }, []);
	        };
	
	    };
	
	    function extract_functions_from_statement_array(statements) {
	        var funs = [];
	        for (var i = statements.length - 1; i >= 0; --i) {
	            var stat = statements[i];
	            if (stat instanceof AST_Defun) {
	                statements.splice(i, 1);
	                funs.unshift(stat);
	            }
	        }
	        return funs;
	    }
	
	    function extract_declarations_from_unreachable_code(compressor, stat, target) {
	        if (!(stat instanceof AST_Defun)) {
	            compressor.warn("Dropping unreachable code [{file}:{line},{col}]", stat.start);
	        }
	        stat.walk(new TreeWalker(function(node){
	            if (node instanceof AST_Definitions) {
	                compressor.warn("Declarations in unreachable code! [{file}:{line},{col}]", node.start);
	                node.remove_initializers();
	                target.push(node);
	                return true;
	            }
	            if (node instanceof AST_Defun) {
	                target.push(node);
	                return true;
	            }
	            if (node instanceof AST_Scope) {
	                return true;
	            }
	        }));
	    };
	
	    function is_undefined(node, compressor) {
	        return node.is_undefined
	            || node instanceof AST_Undefined
	            || node instanceof AST_UnaryPrefix
	                && node.operator == "void"
	                && !node.expression.has_side_effects(compressor);
	    }
	
	    // may_throw_on_access()
	    // returns true if this node may be null, undefined or contain `AST_Accessor`
	    (function(def) {
	        AST_Node.DEFMETHOD("may_throw_on_access", function(compressor) {
	            var pure_getters = compressor.option("pure_getters");
	            return !pure_getters || this._throw_on_access(pure_getters);
	        });
	
	        function is_strict(pure_getters) {
	            return /strict/.test(pure_getters);
	        }
	
	        def(AST_Node, is_strict);
	        def(AST_Null, return_true);
	        def(AST_Undefined, return_true);
	        def(AST_Constant, return_false);
	        def(AST_Array, return_false);
	        def(AST_Object, function(pure_getters) {
	            if (!is_strict(pure_getters)) return false;
	            for (var i = this.properties.length; --i >=0;)
	                if (this.properties[i].value instanceof AST_Accessor) return true;
	            return false;
	        });
	        def(AST_Function, return_false);
	        def(AST_UnaryPostfix, return_false);
	        def(AST_UnaryPrefix, function() {
	            return this.operator == "void";
	        });
	        def(AST_Binary, function(pure_getters) {
	            switch (this.operator) {
	              case "&&":
	                return this.left._throw_on_access(pure_getters);
	              case "||":
	                return this.left._throw_on_access(pure_getters)
	                    && this.right._throw_on_access(pure_getters);
	              default:
	                return false;
	            }
	        })
	        def(AST_Assign, function(pure_getters) {
	            return this.operator == "="
	                && this.right._throw_on_access(pure_getters);
	        })
	        def(AST_Conditional, function(pure_getters) {
	            return this.consequent._throw_on_access(pure_getters)
	                || this.alternative._throw_on_access(pure_getters);
	        })
	        def(AST_Seq, function(pure_getters) {
	            return this.cdr._throw_on_access(pure_getters);
	        });
	        def(AST_SymbolRef, function(pure_getters) {
	            if (this.is_undefined) return true;
	            if (!is_strict(pure_getters)) return false;
	            var fixed = this.fixed_value();
	            return !fixed || fixed._throw_on_access(pure_getters);
	        });
	    })(function(node, func) {
	        node.DEFMETHOD("_throw_on_access", func);
	    });
	
	    /* -----[ boolean/negation helpers ]----- */
	
	    // methods to determine whether an expression has a boolean result type
	    (function (def){
	        var unary_bool = [ "!", "delete" ];
	        var binary_bool = [ "in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">" ];
	        def(AST_Node, return_false);
	        def(AST_UnaryPrefix, function(){
	            return member(this.operator, unary_bool);
	        });
	        def(AST_Binary, function(){
	            return member(this.operator, binary_bool) ||
	                ( (this.operator == "&&" || this.operator == "||") &&
	                  this.left.is_boolean() && this.right.is_boolean() );
	        });
	        def(AST_Conditional, function(){
	            return this.consequent.is_boolean() && this.alternative.is_boolean();
	        });
	        def(AST_Assign, function(){
	            return this.operator == "=" && this.right.is_boolean();
	        });
	        def(AST_Seq, function(){
	            return this.cdr.is_boolean();
	        });
	        def(AST_True, return_true);
	        def(AST_False, return_true);
	    })(function(node, func){
	        node.DEFMETHOD("is_boolean", func);
	    });
	
	    // methods to determine if an expression has a numeric result type
	    (function (def){
	        def(AST_Node, return_false);
	        def(AST_Number, return_true);
	        var unary = makePredicate("+ - ~ ++ --");
	        def(AST_Unary, function(){
	            return unary(this.operator);
	        });
	        var binary = makePredicate("- * / % & | ^ << >> >>>");
	        def(AST_Binary, function(compressor){
	            return binary(this.operator) || this.operator == "+"
	                && this.left.is_number(compressor)
	                && this.right.is_number(compressor);
	        });
	        def(AST_Assign, function(compressor){
	            return binary(this.operator.slice(0, -1))
	                || this.operator == "=" && this.right.is_number(compressor);
	        });
	        def(AST_Seq, function(compressor){
	            return this.cdr.is_number(compressor);
	        });
	        def(AST_Conditional, function(compressor){
	            return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);
	        });
	    })(function(node, func){
	        node.DEFMETHOD("is_number", func);
	    });
	
	    // methods to determine if an expression has a string result type
	    (function (def){
	        def(AST_Node, return_false);
	        def(AST_String, return_true);
	        def(AST_UnaryPrefix, function(){
	            return this.operator == "typeof";
	        });
	        def(AST_Binary, function(compressor){
	            return this.operator == "+" &&
	                (this.left.is_string(compressor) || this.right.is_string(compressor));
	        });
	        def(AST_Assign, function(compressor){
	            return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
	        });
	        def(AST_Seq, function(compressor){
	            return this.cdr.is_string(compressor);
	        });
	        def(AST_Conditional, function(compressor){
	            return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
	        });
	    })(function(node, func){
	        node.DEFMETHOD("is_string", func);
	    });
	
	    var unary_side_effects = makePredicate("delete ++ --");
	
	    function is_lhs(node, parent) {
	        if (parent instanceof AST_Unary && unary_side_effects(parent.operator)) return parent.expression;
	        if (parent instanceof AST_Assign && parent.left === node) return node;
	    }
	
	    (function (def){
	        AST_Node.DEFMETHOD("resolve_defines", function(compressor) {
	            if (!compressor.option("global_defs")) return;
	            var def = this._find_defs(compressor, "");
	            if (def) {
	                var node, parent = this, level = 0;
	                do {
	                    node = parent;
	                    parent = compressor.parent(level++);
	                } while (parent instanceof AST_PropAccess && parent.expression === node);
	                if (is_lhs(node, parent)) {
	                    compressor.warn('global_defs ' + this.print_to_string() + ' redefined [{file}:{line},{col}]', this.start);
	                } else {
	                    return def;
	                }
	            }
	        });
	        function to_node(value, orig) {
	            if (value instanceof AST_Node) return make_node(value.CTOR, orig, value);
	            if (Array.isArray(value)) return make_node(AST_Array, orig, {
	                elements: value.map(function(value) {
	                    return to_node(value, orig);
	                })
	            });
	            if (value && typeof value == "object") {
	                var props = [];
	                for (var key in value) {
	                    props.push(make_node(AST_ObjectKeyVal, orig, {
	                        key: key,
	                        value: to_node(value[key], orig)
	                    }));
	                }
	                return make_node(AST_Object, orig, {
	                    properties: props
	                });
	            }
	            return make_node_from_constant(value, orig);
	        }
	        def(AST_Node, noop);
	        def(AST_Dot, function(compressor, suffix){
	            return this.expression._find_defs(compressor, "." + this.property + suffix);
	        });
	        def(AST_SymbolRef, function(compressor, suffix){
	            if (!this.global()) return;
	            var name;
	            var defines = compressor.option("global_defs");
	            if (defines && HOP(defines, (name = this.name + suffix))) {
	                var node = to_node(defines[name], this);
	                var top = compressor.find_parent(AST_Toplevel);
	                node.walk(new TreeWalker(function(node) {
	                    if (node instanceof AST_SymbolRef) {
	                        node.scope = top;
	                        node.thedef = top.def_global(node);
	                    }
	                }));
	                return node;
	            }
	        });
	    })(function(node, func){
	        node.DEFMETHOD("_find_defs", func);
	    });
	
	    function best_of_expression(ast1, ast2) {
	        return ast1.print_to_string().length >
	            ast2.print_to_string().length
	            ? ast2 : ast1;
	    }
	
	    function best_of_statement(ast1, ast2) {
	        return best_of_expression(make_node(AST_SimpleStatement, ast1, {
	            body: ast1
	        }), make_node(AST_SimpleStatement, ast2, {
	            body: ast2
	        })).body;
	    }
	
	    function best_of(compressor, ast1, ast2) {
	        return (first_in_statement(compressor) ? best_of_statement : best_of_expression)(ast1, ast2);
	    }
	
	    // methods to evaluate a constant expression
	    (function (def){
	        // If the node has been successfully reduced to a constant,
	        // then its value is returned; otherwise the element itself
	        // is returned.
	        // They can be distinguished as constant value is never a
	        // descendant of AST_Node.
	        AST_Node.DEFMETHOD("evaluate", function(compressor){
	            if (!compressor.option("evaluate")) return this;
	            try {
	                var val = this._eval(compressor);
	                return !val || val instanceof RegExp || typeof val != "object" ? val : this;
	            } catch(ex) {
	                if (ex !== def) throw ex;
	                return this;
	            }
	        });
	        var unaryPrefix = makePredicate("! ~ - + void");
	        AST_Node.DEFMETHOD("is_constant", function(){
	            // Accomodate when compress option evaluate=false
	            // as well as the common constant expressions !0 and -1
	            if (this instanceof AST_Constant) {
	                return !(this instanceof AST_RegExp);
	            } else {
	                return this instanceof AST_UnaryPrefix
	                    && this.expression instanceof AST_Constant
	                    && unaryPrefix(this.operator);
	            }
	        });
	        // Obtain the constant value of an expression already known to be constant.
	        // Result only valid iff this.is_constant() is true.
	        AST_Node.DEFMETHOD("constant_value", function(compressor){
	            // Accomodate when option evaluate=false.
	            if (this instanceof AST_Constant && !(this instanceof AST_RegExp)) {
	                return this.value;
	            }
	            // Accomodate the common constant expressions !0 and -1 when option evaluate=false.
	            if (this instanceof AST_UnaryPrefix
	                && this.expression instanceof AST_Constant) switch (this.operator) {
	              case "!":
	                return !this.expression.value;
	              case "~":
	                return ~this.expression.value;
	              case "-":
	                return -this.expression.value;
	              case "+":
	                return +this.expression.value;
	              default:
	                throw new Error(string_template("Cannot evaluate unary expression {value}", {
	                    value: this.print_to_string()
	                }));
	            }
	            var result = this.evaluate(compressor);
	            if (result !== this) {
	                return result;
	            }
	            throw new Error(string_template("Cannot evaluate constant [{file}:{line},{col}]", this.start));
	        });
	        def(AST_Statement, function(){
	            throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
	        });
	        def(AST_Lambda, function(){
	            throw def;
	        });
	        function ev(node, compressor) {
	            if (!compressor) throw new Error("Compressor must be passed");
	
	            return node._eval(compressor);
	        };
	        def(AST_Node, function(){
	            throw def;          // not constant
	        });
	        def(AST_Constant, function(){
	            return this.getValue();
	        });
	        def(AST_Array, function(compressor){
	            if (compressor.option("unsafe")) {
	                return this.elements.map(function(element) {
	                    return ev(element, compressor);
	                });
	            }
	            throw def;
	        });
	        def(AST_Object, function(compressor){
	            if (compressor.option("unsafe")) {
	                var val = {};
	                for (var i = 0, len = this.properties.length; i < len; i++) {
	                    var prop = this.properties[i];
	                    var key = prop.key;
	                    if (key instanceof AST_Symbol) {
	                        key = key.name;
	                    } else if (key instanceof AST_Node) {
	                        key = ev(key, compressor);
	                    }
	                    if (typeof Object.prototype[key] === 'function') {
	                        throw def;
	                    }
	                    val[key] = ev(prop.value, compressor);
	                }
	                return val;
	            }
	            throw def;
	        });
	        def(AST_UnaryPrefix, function(compressor){
	            var e = this.expression;
	            switch (this.operator) {
	              case "!": return !ev(e, compressor);
	              case "typeof":
	                // Function would be evaluated to an array and so typeof would
	                // incorrectly return 'object'. Hence making is a special case.
	                if (e instanceof AST_Function) return typeof function(){};
	
	                e = ev(e, compressor);
	
	                // typeof <RegExp> returns "object" or "function" on different platforms
	                // so cannot evaluate reliably
	                if (e instanceof RegExp) throw def;
	
	                return typeof e;
	              case "void": return void ev(e, compressor);
	              case "~": return ~ev(e, compressor);
	              case "-": return -ev(e, compressor);
	              case "+": return +ev(e, compressor);
	            }
	            throw def;
	        });
	        def(AST_Binary, function(c){
	            var left = this.left, right = this.right, result;
	            switch (this.operator) {
	              case "&&"  : result = ev(left, c) &&  ev(right, c); break;
	              case "||"  : result = ev(left, c) ||  ev(right, c); break;
	              case "|"   : result = ev(left, c) |   ev(right, c); break;
	              case "&"   : result = ev(left, c) &   ev(right, c); break;
	              case "^"   : result = ev(left, c) ^   ev(right, c); break;
	              case "+"   : result = ev(left, c) +   ev(right, c); break;
	              case "*"   : result = ev(left, c) *   ev(right, c); break;
	              case "/"   : result = ev(left, c) /   ev(right, c); break;
	              case "%"   : result = ev(left, c) %   ev(right, c); break;
	              case "-"   : result = ev(left, c) -   ev(right, c); break;
	              case "<<"  : result = ev(left, c) <<  ev(right, c); break;
	              case ">>"  : result = ev(left, c) >>  ev(right, c); break;
	              case ">>>" : result = ev(left, c) >>> ev(right, c); break;
	              case "=="  : result = ev(left, c) ==  ev(right, c); break;
	              case "===" : result = ev(left, c) === ev(right, c); break;
	              case "!="  : result = ev(left, c) !=  ev(right, c); break;
	              case "!==" : result = ev(left, c) !== ev(right, c); break;
	              case "<"   : result = ev(left, c) <   ev(right, c); break;
	              case "<="  : result = ev(left, c) <=  ev(right, c); break;
	              case ">"   : result = ev(left, c) >   ev(right, c); break;
	              case ">="  : result = ev(left, c) >=  ev(right, c); break;
	              default:
	                  throw def;
	            }
	            if (isNaN(result) && c.find_parent(AST_With)) {
	                // leave original expression as is
	                throw def;
	            }
	            return result;
	        });
	        def(AST_Conditional, function(compressor){
	            return ev(this.condition, compressor)
	                ? ev(this.consequent, compressor)
	                : ev(this.alternative, compressor);
	        });
	        def(AST_SymbolRef, function(compressor){
	            if (!compressor.option("reduce_vars") || this._evaluating) throw def;
	            this._evaluating = true;
	            try {
	                var fixed = this.fixed_value();
	                if (!fixed) throw def;
	                var value = ev(fixed, compressor);
	                if (!HOP(fixed, "_eval")) fixed._eval = function() {
	                    return value;
	                };
	                if (value && typeof value == "object" && this.definition().escaped) throw def;
	                return value;
	            } finally {
	                this._evaluating = false;
	            }
	        });
	        def(AST_PropAccess, function(compressor){
	            if (compressor.option("unsafe")) {
	                var key = this.property;
	                if (key instanceof AST_Node) {
	                    key = ev(key, compressor);
	                }
	                var val = ev(this.expression, compressor);
	                if (val && HOP(val, key)) {
	                    return val[key];
	                }
	            }
	            throw def;
	        });
	    })(function(node, func){
	        node.DEFMETHOD("_eval", func);
	    });
	
	    // method to negate an expression
	    (function(def){
	        function basic_negation(exp) {
	            return make_node(AST_UnaryPrefix, exp, {
	                operator: "!",
	                expression: exp
	            });
	        }
	        function best(orig, alt, first_in_statement) {
	            var negated = basic_negation(orig);
	            if (first_in_statement) {
	                var stat = make_node(AST_SimpleStatement, alt, {
	                    body: alt
	                });
	                return best_of_expression(negated, stat) === stat ? alt : negated;
	            }
	            return best_of_expression(negated, alt);
	        }
	        def(AST_Node, function(){
	            return basic_negation(this);
	        });
	        def(AST_Statement, function(){
	            throw new Error("Cannot negate a statement");
	        });
	        def(AST_Function, function(){
	            return basic_negation(this);
	        });
	        def(AST_UnaryPrefix, function(){
	            if (this.operator == "!")
	                return this.expression;
	            return basic_negation(this);
	        });
	        def(AST_Seq, function(compressor){
	            var self = this.clone();
	            self.cdr = self.cdr.negate(compressor);
	            return self;
	        });
	        def(AST_Conditional, function(compressor, first_in_statement){
	            var self = this.clone();
	            self.consequent = self.consequent.negate(compressor);
	            self.alternative = self.alternative.negate(compressor);
	            return best(this, self, first_in_statement);
	        });
	        def(AST_Binary, function(compressor, first_in_statement){
	            var self = this.clone(), op = this.operator;
	            if (compressor.option("unsafe_comps")) {
	                switch (op) {
	                  case "<=" : self.operator = ">"  ; return self;
	                  case "<"  : self.operator = ">=" ; return self;
	                  case ">=" : self.operator = "<"  ; return self;
	                  case ">"  : self.operator = "<=" ; return self;
	                }
	            }
	            switch (op) {
	              case "==" : self.operator = "!="; return self;
	              case "!=" : self.operator = "=="; return self;
	              case "===": self.operator = "!=="; return self;
	              case "!==": self.operator = "==="; return self;
	              case "&&":
	                self.operator = "||";
	                self.left = self.left.negate(compressor, first_in_statement);
	                self.right = self.right.negate(compressor);
	                return best(this, self, first_in_statement);
	              case "||":
	                self.operator = "&&";
	                self.left = self.left.negate(compressor, first_in_statement);
	                self.right = self.right.negate(compressor);
	                return best(this, self, first_in_statement);
	            }
	            return basic_negation(this);
	        });
	    })(function(node, func){
	        node.DEFMETHOD("negate", function(compressor, first_in_statement){
	            return func.call(this, compressor, first_in_statement);
	        });
	    });
	
	    AST_Call.DEFMETHOD("has_pure_annotation", function(compressor) {
	        if (!compressor.option("side_effects")) return false;
	        if (this.pure !== undefined) return this.pure;
	        var pure = false;
	        var comments, last_comment;
	        if (this.start
	            && (comments = this.start.comments_before)
	            && comments.length
	            && /[@#]__PURE__/.test((last_comment = comments[comments.length - 1]).value)) {
	            pure = last_comment;
	        }
	        return this.pure = pure;
	    });
	
	    // determine if expression has side effects
	    (function(def){
	        def(AST_Node, return_true);
	
	        def(AST_EmptyStatement, return_false);
	        def(AST_Constant, return_false);
	        def(AST_This, return_false);
	
	        def(AST_Call, function(compressor){
	            if (!this.has_pure_annotation(compressor) && compressor.pure_funcs(this)) return true;
	            for (var i = this.args.length; --i >= 0;) {
	                if (this.args[i].has_side_effects(compressor))
	                    return true;
	            }
	            return false;
	        });
	
	        function any(list, compressor) {
	            for (var i = list.length; --i >= 0;)
	                if (list[i].has_side_effects(compressor))
	                    return true;
	            return false;
	        }
	
	        def(AST_Block, function(compressor){
	            return any(this.body, compressor);
	        });
	        def(AST_Switch, function(compressor){
	            return this.expression.has_side_effects(compressor)
	                || any(this.body, compressor);
	        });
	        def(AST_Case, function(compressor){
	            return this.expression.has_side_effects(compressor)
	                || any(this.body, compressor);
	        });
	        def(AST_Try, function(compressor){
	            return any(this.body, compressor)
	                || this.bcatch && this.bcatch.has_side_effects(compressor)
	                || this.bfinally && this.bfinally.has_side_effects(compressor);
	        });
	        def(AST_If, function(compressor){
	            return this.condition.has_side_effects(compressor)
	                || this.body && this.body.has_side_effects(compressor)
	                || this.alternative && this.alternative.has_side_effects(compressor);
	        });
	        def(AST_LabeledStatement, function(compressor){
	            return this.body.has_side_effects(compressor);
	        });
	        def(AST_SimpleStatement, function(compressor){
	            return this.body.has_side_effects(compressor);
	        });
	        def(AST_Defun, return_true);
	        def(AST_Function, return_false);
	        def(AST_Binary, function(compressor){
	            return this.left.has_side_effects(compressor)
	                || this.right.has_side_effects(compressor);
	        });
	        def(AST_Assign, return_true);
	        def(AST_Conditional, function(compressor){
	            return this.condition.has_side_effects(compressor)
	                || this.consequent.has_side_effects(compressor)
	                || this.alternative.has_side_effects(compressor);
	        });
	        def(AST_Unary, function(compressor){
	            return unary_side_effects(this.operator)
	                || this.expression.has_side_effects(compressor);
	        });
	        def(AST_SymbolRef, function(compressor){
	            return this.undeclared();
	        });
	        def(AST_Object, function(compressor){
	            return any(this.properties, compressor);
	        });
	        def(AST_ObjectProperty, function(compressor){
	            return this.value.has_side_effects(compressor);
	        });
	        def(AST_Array, function(compressor){
	            return any(this.elements, compressor);
	        });
	        def(AST_Dot, function(compressor){
	            return this.expression.may_throw_on_access(compressor)
	                || this.expression.has_side_effects(compressor);
	        });
	        def(AST_Sub, function(compressor){
	            return this.expression.may_throw_on_access(compressor)
	                || this.expression.has_side_effects(compressor)
	                || this.property.has_side_effects(compressor);
	        });
	        def(AST_Seq, function(compressor){
	            return this.car.has_side_effects(compressor)
	                || this.cdr.has_side_effects(compressor);
	        });
	    })(function(node, func){
	        node.DEFMETHOD("has_side_effects", func);
	    });
	
	    // tell me if a statement aborts
	    function aborts(thing) {
	        return thing && thing.aborts();
	    };
	    (function(def){
	        def(AST_Statement, return_null);
	        def(AST_Jump, return_this);
	        function block_aborts(){
	            var n = this.body.length;
	            return n > 0 && aborts(this.body[n - 1]);
	        };
	        def(AST_BlockStatement, block_aborts);
	        def(AST_SwitchBranch, block_aborts);
	        def(AST_If, function(){
	            return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
	        });
	    })(function(node, func){
	        node.DEFMETHOD("aborts", func);
	    });
	
	    /* -----[ optimizers ]----- */
	
	    OPT(AST_Directive, function(self, compressor){
	        if (compressor.has_directive(self.value) !== self) {
	            return make_node(AST_EmptyStatement, self);
	        }
	        return self;
	    });
	
	    OPT(AST_Debugger, function(self, compressor){
	        if (compressor.option("drop_debugger"))
	            return make_node(AST_EmptyStatement, self);
	        return self;
	    });
	
	    OPT(AST_LabeledStatement, function(self, compressor){
	        if (self.body instanceof AST_Break
	            && compressor.loopcontrol_target(self.body) === self.body) {
	            return make_node(AST_EmptyStatement, self);
	        }
	        return self.label.references.length == 0 ? self.body : self;
	    });
	
	    OPT(AST_Block, function(self, compressor){
	        self.body = tighten_body(self.body, compressor);
	        return self;
	    });
	
	    OPT(AST_BlockStatement, function(self, compressor){
	        self.body = tighten_body(self.body, compressor);
	        switch (self.body.length) {
	          case 1: return self.body[0];
	          case 0: return make_node(AST_EmptyStatement, self);
	        }
	        return self;
	    });
	
	    AST_Scope.DEFMETHOD("drop_unused", function(compressor){
	        var self = this;
	        if (compressor.has_directive("use asm")) return self;
	        var toplevel = compressor.option("toplevel");
	        if (compressor.option("unused")
	            && (!(self instanceof AST_Toplevel) || toplevel)
	            && !self.uses_eval
	            && !self.uses_with) {
	            var assign_as_unused = !/keep_assign/.test(compressor.option("unused"));
	            var drop_funcs = /funcs/.test(toplevel);
	            var drop_vars = /vars/.test(toplevel);
	            if (!(self instanceof AST_Toplevel) || toplevel == true) {
	                drop_funcs = drop_vars = true;
	            }
	            var in_use = [];
	            var in_use_ids = Object.create(null); // avoid expensive linear scans of in_use
	            if (self instanceof AST_Toplevel && compressor.top_retain) {
	                self.variables.each(function(def) {
	                    if (compressor.top_retain(def) && !(def.id in in_use_ids)) {
	                        in_use_ids[def.id] = true;
	                        in_use.push(def);
	                    }
	                });
	            }
	            var initializations = new Dictionary();
	            // pass 1: find out which symbols are directly used in
	            // this scope (not in nested scopes).
	            var scope = this;
	            var tw = new TreeWalker(function(node, descend){
	                if (node !== self) {
	                    if (node instanceof AST_Defun) {
	                        if (!drop_funcs && scope === self) {
	                            var node_def = node.name.definition();
	                            if (!(node_def.id in in_use_ids)) {
	                                in_use_ids[node_def.id] = true;
	                                in_use.push(node_def);
	                            }
	                        }
	                        initializations.add(node.name.name, node);
	                        return true; // don't go in nested scopes
	                    }
	                    if (node instanceof AST_Definitions && scope === self) {
	                        node.definitions.forEach(function(def){
	                            if (!drop_vars) {
	                                var node_def = def.name.definition();
	                                if (!(node_def.id in in_use_ids)) {
	                                    in_use_ids[node_def.id] = true;
	                                    in_use.push(node_def);
	                                }
	                            }
	                            if (def.value) {
	                                initializations.add(def.name.name, def.value);
	                                if (def.value.has_side_effects(compressor)) {
	                                    def.value.walk(tw);
	                                }
	                            }
	                        });
	                        return true;
	                    }
	                    if (assign_as_unused
	                        && node instanceof AST_Assign
	                        && node.operator == "="
	                        && node.left instanceof AST_SymbolRef
	                        && !is_reference_const(node.left)
	                        && scope === self) {
	                        node.right.walk(tw);
	                        return true;
	                    }
	                    if (node instanceof AST_SymbolRef) {
	                        var node_def = node.definition();
	                        if (!(node_def.id in in_use_ids)) {
	                            in_use_ids[node_def.id] = true;
	                            in_use.push(node_def);
	                        }
	                        return true;
	                    }
	                    if (node instanceof AST_Scope) {
	                        var save_scope = scope;
	                        scope = node;
	                        descend();
	                        scope = save_scope;
	                        return true;
	                    }
	                }
	            });
	            self.walk(tw);
	            // pass 2: for every used symbol we need to walk its
	            // initialization code to figure out if it uses other
	            // symbols (that may not be in_use).
	            for (var i = 0; i < in_use.length; ++i) {
	                in_use[i].orig.forEach(function(decl){
	                    // undeclared globals will be instanceof AST_SymbolRef
	                    var init = initializations.get(decl.name);
	                    if (init) init.forEach(function(init){
	                        var tw = new TreeWalker(function(node){
	                            if (node instanceof AST_SymbolRef) {
	                                var node_def = node.definition();
	                                if (!(node_def.id in in_use_ids)) {
	                                    in_use_ids[node_def.id] = true;
	                                    in_use.push(node_def);
	                                }
	                            }
	                        });
	                        init.walk(tw);
	                    });
	                });
	            }
	            // pass 3: we should drop declarations not in_use
	            var tt = new TreeTransformer(
	                function before(node, descend, in_list) {
	                    if (node instanceof AST_Function
	                        && node.name
	                        && !compressor.option("keep_fnames")) {
	                        var def = node.name.definition();
	                        // any declarations with same name will overshadow
	                        // name of this anonymous function and can therefore
	                        // never be used anywhere
	                        if (!(def.id in in_use_ids) || def.orig.length > 1)
	                            node.name = null;
	                    }
	                    if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
	                        var trim = !compressor.option("keep_fargs");
	                        for (var a = node.argnames, i = a.length; --i >= 0;) {
	                            var sym = a[i];
	                            if (!(sym.definition().id in in_use_ids)) {
	                                sym.__unused = true;
	                                if (trim) {
	                                    a.pop();
	                                    compressor[sym.unreferenced() ? "warn" : "info"]("Dropping unused function argument {name} [{file}:{line},{col}]", {
	                                        name : sym.name,
	                                        file : sym.start.file,
	                                        line : sym.start.line,
	                                        col  : sym.start.col
	                                    });
	                                }
	                            }
	                            else {
	                                trim = false;
	                            }
	                        }
	                    }
	                    if (drop_funcs && node instanceof AST_Defun && node !== self) {
	                        if (!(node.name.definition().id in in_use_ids)) {
	                            compressor[node.name.unreferenced() ? "warn" : "info"]("Dropping unused function {name} [{file}:{line},{col}]", {
	                                name : node.name.name,
	                                file : node.name.start.file,
	                                line : node.name.start.line,
	                                col  : node.name.start.col
	                            });
	                            return make_node(AST_EmptyStatement, node);
	                        }
	                        return node;
	                    }
	                    if (drop_vars && node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn && tt.parent().init === node)) {
	                        var def = node.definitions.filter(function(def){
	                            if (def.value) def.value = def.value.transform(tt);
	                            var sym = def.name.definition();
	                            if (sym.id in in_use_ids) return true;
	                            if (sym.orig[0] instanceof AST_SymbolCatch) {
	                                def.value = def.value && def.value.drop_side_effect_free(compressor);
	                                return true;
	                            }
	                            var w = {
	                                name : def.name.name,
	                                file : def.name.start.file,
	                                line : def.name.start.line,
	                                col  : def.name.start.col
	                            };
	                            if (def.value && (def._unused_side_effects = def.value.drop_side_effect_free(compressor))) {
	                                compressor.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", w);
	                                return true;
	                            }
	                            compressor[def.name.unreferenced() ? "warn" : "info"]("Dropping unused variable {name} [{file}:{line},{col}]", w);
	                            return false;
	                        });
	                        // place uninitialized names at the start
	                        def = mergeSort(def, function(a, b){
	                            if (!a.value && b.value) return -1;
	                            if (!b.value && a.value) return 1;
	                            return 0;
	                        });
	                        // for unused names whose initialization has
	                        // side effects, we can cascade the init. code
	                        // into the next one, or next statement.
	                        var side_effects = [];
	                        for (var i = 0; i < def.length;) {
	                            var x = def[i];
	                            if (x._unused_side_effects) {
	                                side_effects.push(x._unused_side_effects);
	                                def.splice(i, 1);
	                            } else {
	                                if (side_effects.length > 0) {
	                                    side_effects.push(x.value);
	                                    x.value = AST_Seq.from_array(side_effects);
	                                    side_effects = [];
	                                }
	                                ++i;
	                            }
	                        }
	                        if (side_effects.length > 0) {
	                            side_effects = make_node(AST_BlockStatement, node, {
	                                body: [ make_node(AST_SimpleStatement, node, {
	                                    body: AST_Seq.from_array(side_effects)
	                                }) ]
	                            });
	                        } else {
	                            side_effects = null;
	                        }
	                        if (def.length == 0 && !side_effects) {
	                            return make_node(AST_EmptyStatement, node);
	                        }
	                        if (def.length == 0) {
	                            return in_list ? MAP.splice(side_effects.body) : side_effects;
	                        }
	                        node.definitions = def;
	                        if (side_effects) {
	                            side_effects.body.unshift(node);
	                            return in_list ? MAP.splice(side_effects.body) : side_effects;
	                        }
	                        return node;
	                    }
	                    if (drop_vars && assign_as_unused
	                        && node instanceof AST_Assign
	                        && node.operator == "="
	                        && node.left instanceof AST_SymbolRef) {
	                        var def = node.left.definition();
	                        if (!(def.id in in_use_ids)
	                            && self.variables.get(def.name) === def) {
	                            return maintain_this_binding(tt.parent(), node, node.right.transform(tt));
	                        }
	                    }
	                    // certain combination of unused name + side effect leads to:
	                    //    https://github.com/mishoo/UglifyJS2/issues/44
	                    //    https://github.com/mishoo/UglifyJS2/issues/1830
	                    // that's an invalid AST.
	                    // We fix it at this stage by moving the `var` outside the `for`.
	                    if (node instanceof AST_For) {
	                        descend(node, this);
	                        if (node.init instanceof AST_BlockStatement) {
	                            var block = node.init;
	                            node.init = block.body.pop();
	                            block.body.push(node);
	                            return in_list ? MAP.splice(block.body) : block;
	                        } else if (is_empty(node.init)) {
	                            node.init = null;
	                        }
	                        return node;
	                    }
	                    if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {
	                        descend(node, this);
	                        if (node.body instanceof AST_BlockStatement) {
	                            var block = node.body;
	                            node.body = block.body.pop();
	                            block.body.push(node);
	                            return in_list ? MAP.splice(block.body) : block;
	                        }
	                        return node;
	                    }
	                    if (node instanceof AST_Scope && node !== self)
	                        return node;
	                }
	            );
	            self.transform(tt);
	        }
	    });
	
	    AST_Scope.DEFMETHOD("hoist_declarations", function(compressor){
	        var self = this;
	        if (compressor.has_directive("use asm")) return self;
	        var hoist_funs = compressor.option("hoist_funs");
	        var hoist_vars = compressor.option("hoist_vars");
	        if (hoist_funs || hoist_vars) {
	            var dirs = [];
	            var hoisted = [];
	            var vars = new Dictionary(), vars_found = 0, var_decl = 0;
	            // let's count var_decl first, we seem to waste a lot of
	            // space if we hoist `var` when there's only one.
	            self.walk(new TreeWalker(function(node){
	                if (node instanceof AST_Scope && node !== self)
	                    return true;
	                if (node instanceof AST_Var) {
	                    ++var_decl;
	                    return true;
	                }
	            }));
	            hoist_vars = hoist_vars && var_decl > 1;
	            var tt = new TreeTransformer(
	                function before(node) {
	                    if (node !== self) {
	                        if (node instanceof AST_Directive) {
	                            dirs.push(node);
	                            return make_node(AST_EmptyStatement, node);
	                        }
	                        if (node instanceof AST_Defun && hoist_funs) {
	                            hoisted.push(node);
	                            return make_node(AST_EmptyStatement, node);
	                        }
	                        if (node instanceof AST_Var && hoist_vars) {
	                            node.definitions.forEach(function(def){
	                                vars.set(def.name.name, def);
	                                ++vars_found;
	                            });
	                            var seq = node.to_assignments(compressor);
	                            var p = tt.parent();
	                            if (p instanceof AST_ForIn && p.init === node) {
	                                if (seq == null) {
	                                    var def = node.definitions[0].name;
	                                    return make_node(AST_SymbolRef, def, def);
	                                }
	                                return seq;
	                            }
	                            if (p instanceof AST_For && p.init === node) {
	                                return seq;
	                            }
	                            if (!seq) return make_node(AST_EmptyStatement, node);
	                            return make_node(AST_SimpleStatement, node, {
	                                body: seq
	                            });
	                        }
	                        if (node instanceof AST_Scope)
	                            return node; // to avoid descending in nested scopes
	                    }
	                }
	            );
	            self = self.transform(tt);
	            if (vars_found > 0) {
	                // collect only vars which don't show up in self's arguments list
	                var defs = [];
	                vars.each(function(def, name){
	                    if (self instanceof AST_Lambda
	                        && find_if(function(x){ return x.name == def.name.name },
	                                   self.argnames)) {
	                        vars.del(name);
	                    } else {
	                        def = def.clone();
	                        def.value = null;
	                        defs.push(def);
	                        vars.set(name, def);
	                    }
	                });
	                if (defs.length > 0) {
	                    // try to merge in assignments
	                    for (var i = 0; i < self.body.length;) {
	                        if (self.body[i] instanceof AST_SimpleStatement) {
	                            var expr = self.body[i].body, sym, assign;
	                            if (expr instanceof AST_Assign
	                                && expr.operator == "="
	                                && (sym = expr.left) instanceof AST_Symbol
	                                && vars.has(sym.name))
	                            {
	                                var def = vars.get(sym.name);
	                                if (def.value) break;
	                                def.value = expr.right;
	                                remove(defs, def);
	                                defs.push(def);
	                                self.body.splice(i, 1);
	                                continue;
	                            }
	                            if (expr instanceof AST_Seq
	                                && (assign = expr.car) instanceof AST_Assign
	                                && assign.operator == "="
	                                && (sym = assign.left) instanceof AST_Symbol
	                                && vars.has(sym.name))
	                            {
	                                var def = vars.get(sym.name);
	                                if (def.value) break;
	                                def.value = assign.right;
	                                remove(defs, def);
	                                defs.push(def);
	                                self.body[i].body = expr.cdr;
	                                continue;
	                            }
	                        }
	                        if (self.body[i] instanceof AST_EmptyStatement) {
	                            self.body.splice(i, 1);
	                            continue;
	                        }
	                        if (self.body[i] instanceof AST_BlockStatement) {
	                            var tmp = [ i, 1 ].concat(self.body[i].body);
	                            self.body.splice.apply(self.body, tmp);
	                            continue;
	                        }
	                        break;
	                    }
	                    defs = make_node(AST_Var, self, {
	                        definitions: defs
	                    });
	                    hoisted.push(defs);
	                };
	            }
	            self.body = dirs.concat(hoisted, self.body);
	        }
	        return self;
	    });
	
	    // drop_side_effect_free()
	    // remove side-effect-free parts which only affects return value
	    (function(def){
	        // Drop side-effect-free elements from an array of expressions.
	        // Returns an array of expressions with side-effects or null
	        // if all elements were dropped. Note: original array may be
	        // returned if nothing changed.
	        function trim(nodes, compressor, first_in_statement) {
	            var ret = [], changed = false;
	            for (var i = 0, len = nodes.length; i < len; i++) {
	                var node = nodes[i].drop_side_effect_free(compressor, first_in_statement);
	                changed |= node !== nodes[i];
	                if (node) {
	                    ret.push(node);
	                    first_in_statement = false;
	                }
	            }
	            return changed ? ret.length ? ret : null : nodes;
	        }
	
	        def(AST_Node, return_this);
	        def(AST_Constant, return_null);
	        def(AST_This, return_null);
	        def(AST_Call, function(compressor, first_in_statement){
	            if (!this.has_pure_annotation(compressor) && compressor.pure_funcs(this)) {
	                if (this.expression instanceof AST_Function
	                    && (!this.expression.name || !this.expression.name.definition().references.length)) {
	                    var node = this.clone();
	                    node.expression = node.expression.process_expression(false, compressor);
	                    return node;
	                }
	                return this;
	            }
	            if (this.pure) {
	                compressor.warn("Dropping __PURE__ call [{file}:{line},{col}]", this.start);
	                this.pure.value = this.pure.value.replace(/[@#]__PURE__/g, ' ');
	            }
	            var args = trim(this.args, compressor, first_in_statement);
	            return args && AST_Seq.from_array(args);
	        });
	        def(AST_Accessor, return_null);
	        def(AST_Function, return_null);
	        def(AST_Binary, function(compressor, first_in_statement){
	            var right = this.right.drop_side_effect_free(compressor);
	            if (!right) return this.left.drop_side_effect_free(compressor, first_in_statement);
	            switch (this.operator) {
	              case "&&":
	              case "||":
	                if (right === this.right) return this;
	                var node = this.clone();
	                node.right = right;
	                return node;
	              default:
	                var left = this.left.drop_side_effect_free(compressor, first_in_statement);
	                if (!left) return this.right.drop_side_effect_free(compressor, first_in_statement);
	                return make_node(AST_Seq, this, {
	                    car: left,
	                    cdr: right
	                });
	            }
	        });
	        def(AST_Assign, return_this);
	        def(AST_Conditional, function(compressor){
	            var consequent = this.consequent.drop_side_effect_free(compressor);
	            var alternative = this.alternative.drop_side_effect_free(compressor);
	            if (consequent === this.consequent && alternative === this.alternative) return this;
	            if (!consequent) return alternative ? make_node(AST_Binary, this, {
	                operator: "||",
	                left: this.condition,
	                right: alternative
	            }) : this.condition.drop_side_effect_free(compressor);
	            if (!alternative) return make_node(AST_Binary, this, {
	                operator: "&&",
	                left: this.condition,
	                right: consequent
	            });
	            var node = this.clone();
	            node.consequent = consequent;
	            node.alternative = alternative;
	            return node;
	        });
	        def(AST_Unary, function(compressor, first_in_statement){
	            if (unary_side_effects(this.operator)) return this;
	            if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef) return null;
	            var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);
	            if (first_in_statement
	                && this instanceof AST_UnaryPrefix
	                && is_iife_call(expression)) {
	                if (expression === this.expression && this.operator.length === 1) return this;
	                return make_node(AST_UnaryPrefix, this, {
	                    operator: this.operator.length === 1 ? this.operator : "!",
	                    expression: expression
	                });
	            }
	            return expression;
	        });
	        def(AST_SymbolRef, function() {
	            return this.undeclared() ? this : null;
	        });
	        def(AST_Object, function(compressor, first_in_statement){
	            var values = trim(this.properties, compressor, first_in_statement);
	            return values && AST_Seq.from_array(values);
	        });
	        def(AST_ObjectProperty, function(compressor, first_in_statement){
	            return this.value.drop_side_effect_free(compressor, first_in_statement);
	        });
	        def(AST_Array, function(compressor, first_in_statement){
	            var values = trim(this.elements, compressor, first_in_statement);
	            return values && AST_Seq.from_array(values);
	        });
	        def(AST_Dot, function(compressor, first_in_statement){
	            if (this.expression.may_throw_on_access(compressor)) return this;
	            return this.expression.drop_side_effect_free(compressor, first_in_statement);
	        });
	        def(AST_Sub, function(compressor, first_in_statement){
	            if (this.expression.may_throw_on_access(compressor)) return this;
	            var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);
	            if (!expression) return this.property.drop_side_effect_free(compressor, first_in_statement);
	            var property = this.property.drop_side_effect_free(compressor);
	            if (!property) return expression;
	            return make_node(AST_Seq, this, {
	                car: expression,
	                cdr: property
	            });
	        });
	        def(AST_Seq, function(compressor){
	            var cdr = this.cdr.drop_side_effect_free(compressor);
	            if (cdr === this.cdr) return this;
	            if (!cdr) return this.car;
	            return make_node(AST_Seq, this, {
	                car: this.car,
	                cdr: cdr
	            });
	        });
	    })(function(node, func){
	        node.DEFMETHOD("drop_side_effect_free", func);
	    });
	
	    OPT(AST_SimpleStatement, function(self, compressor){
	        if (compressor.option("side_effects")) {
	            var body = self.body;
	            var node = body.drop_side_effect_free(compressor, true);
	            if (!node) {
	                compressor.warn("Dropping side-effect-free statement [{file}:{line},{col}]", self.start);
	                return make_node(AST_EmptyStatement, self);
	            }
	            if (node !== body) {
	                return make_node(AST_SimpleStatement, self, { body: node });
	            }
	        }
	        return self;
	    });
	
	    OPT(AST_DWLoop, function(self, compressor){
	        if (!compressor.option("loops")) return self;
	        var cond = self.condition.evaluate(compressor);
	        if (cond !== self.condition) {
	            if (cond) {
	                return make_node(AST_For, self, {
	                    body: self.body
	                });
	            }
	            if (compressor.option("dead_code") && self instanceof AST_While) {
	                var a = [];
	                extract_declarations_from_unreachable_code(compressor, self.body, a);
	                return make_node(AST_BlockStatement, self, { body: a }).optimize(compressor);
	            }
	            if (self instanceof AST_Do) {
	                var has_loop_control = false;
	                var tw = new TreeWalker(function(node) {
	                    if (node instanceof AST_Scope || has_loop_control) return true;
	                    if (node instanceof AST_LoopControl && tw.loopcontrol_target(node) === self)
	                        return has_loop_control = true;
	                });
	                var parent = compressor.parent();
	                (parent instanceof AST_LabeledStatement ? parent : self).walk(tw);
	                if (!has_loop_control) return self.body;
	            }
	        }
	        if (self instanceof AST_While) {
	            return make_node(AST_For, self, self).optimize(compressor);
	        }
	        return self;
	    });
	
	    function if_break_in_loop(self, compressor) {
	        function drop_it(rest) {
	            rest = as_statement_array(rest);
	            if (self.body instanceof AST_BlockStatement) {
	                self.body = self.body.clone();
	                self.body.body = rest.concat(self.body.body.slice(1));
	                self.body = self.body.transform(compressor);
	            } else {
	                self.body = make_node(AST_BlockStatement, self.body, {
	                    body: rest
	                }).transform(compressor);
	            }
	            if_break_in_loop(self, compressor);
	        }
	        var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;
	        if (first instanceof AST_If) {
	            if (first.body instanceof AST_Break
	                && compressor.loopcontrol_target(first.body) === compressor.self()) {
	                if (self.condition) {
	                    self.condition = make_node(AST_Binary, self.condition, {
	                        left: self.condition,
	                        operator: "&&",
	                        right: first.condition.negate(compressor),
	                    });
	                } else {
	                    self.condition = first.condition.negate(compressor);
	                }
	                drop_it(first.alternative);
	            }
	            else if (first.alternative instanceof AST_Break
	                     && compressor.loopcontrol_target(first.alternative) === compressor.self()) {
	                if (self.condition) {
	                    self.condition = make_node(AST_Binary, self.condition, {
	                        left: self.condition,
	                        operator: "&&",
	                        right: first.condition,
	                    });
	                } else {
	                    self.condition = first.condition;
	                }
	                drop_it(first.body);
	            }
	        }
	    };
	
	    OPT(AST_For, function(self, compressor){
	        if (!compressor.option("loops")) return self;
	        if (self.condition) {
	            var cond = self.condition.evaluate(compressor);
	            if (compressor.option("dead_code") && !cond) {
	                var a = [];
	                if (self.init instanceof AST_Statement) {
	                    a.push(self.init);
	                }
	                else if (self.init) {
	                    a.push(make_node(AST_SimpleStatement, self.init, {
	                        body: self.init
	                    }));
	                }
	                extract_declarations_from_unreachable_code(compressor, self.body, a);
	                return make_node(AST_BlockStatement, self, { body: a }).optimize(compressor);
	            }
	            if (cond !== self.condition) {
	                cond = make_node_from_constant(cond, self.condition).transform(compressor);
	                self.condition = best_of_expression(cond, self.condition);
	            }
	        }
	        if_break_in_loop(self, compressor);
	        return self;
	    });
	
	    OPT(AST_If, function(self, compressor){
	        if (is_empty(self.alternative)) self.alternative = null;
	
	        if (!compressor.option("conditionals")) return self;
	        // if condition can be statically determined, warn and drop
	        // one of the blocks.  note, statically determined implies
	        // “has no side effects”; also it doesn't work for cases like
	        // `x && true`, though it probably should.
	        var cond = self.condition.evaluate(compressor);
	        if (cond !== self.condition) {
	            if (cond) {
	                compressor.warn("Condition always true [{file}:{line},{col}]", self.condition.start);
	                if (compressor.option("dead_code")) {
	                    var a = [];
	                    if (self.alternative) {
	                        extract_declarations_from_unreachable_code(compressor, self.alternative, a);
	                    }
	                    a.push(self.body);
	                    return make_node(AST_BlockStatement, self, { body: a }).optimize(compressor);
	                }
	            } else {
	                compressor.warn("Condition always false [{file}:{line},{col}]", self.condition.start);
	                if (compressor.option("dead_code")) {
	                    var a = [];
	                    extract_declarations_from_unreachable_code(compressor, self.body, a);
	                    if (self.alternative) a.push(self.alternative);
	                    return make_node(AST_BlockStatement, self, { body: a }).optimize(compressor);
	                }
	            }
	            cond = make_node_from_constant(cond, self.condition).transform(compressor);
	            self.condition = best_of_expression(cond, self.condition);
	        }
	        var negated = self.condition.negate(compressor);
	        var self_condition_length = self.condition.print_to_string().length;
	        var negated_length = negated.print_to_string().length;
	        var negated_is_best = negated_length < self_condition_length;
	        if (self.alternative && negated_is_best) {
	            negated_is_best = false; // because we already do the switch here.
	            // no need to swap values of self_condition_length and negated_length
	            // here because they are only used in an equality comparison later on.
	            self.condition = negated;
	            var tmp = self.body;
	            self.body = self.alternative || make_node(AST_EmptyStatement, self);
	            self.alternative = tmp;
	        }
	        if (is_empty(self.body) && is_empty(self.alternative)) {
	            return make_node(AST_SimpleStatement, self.condition, {
	                body: self.condition.clone()
	            }).optimize(compressor);
	        }
	        if (self.body instanceof AST_SimpleStatement
	            && self.alternative instanceof AST_SimpleStatement) {
	            return make_node(AST_SimpleStatement, self, {
	                body: make_node(AST_Conditional, self, {
	                    condition   : self.condition,
	                    consequent  : self.body.body,
	                    alternative : self.alternative.body
	                })
	            }).optimize(compressor);
	        }
	        if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {
	            if (self_condition_length === negated_length && !negated_is_best
	                && self.condition instanceof AST_Binary && self.condition.operator == "||") {
	                // although the code length of self.condition and negated are the same,
	                // negated does not require additional surrounding parentheses.
	                // see https://github.com/mishoo/UglifyJS2/issues/979
	                negated_is_best = true;
	            }
	            if (negated_is_best) return make_node(AST_SimpleStatement, self, {
	                body: make_node(AST_Binary, self, {
	                    operator : "||",
	                    left     : negated,
	                    right    : self.body.body
	                })
	            }).optimize(compressor);
	            return make_node(AST_SimpleStatement, self, {
	                body: make_node(AST_Binary, self, {
	                    operator : "&&",
	                    left     : self.condition,
	                    right    : self.body.body
	                })
	            }).optimize(compressor);
	        }
	        if (self.body instanceof AST_EmptyStatement
	            && self.alternative instanceof AST_SimpleStatement) {
	            return make_node(AST_SimpleStatement, self, {
	                body: make_node(AST_Binary, self, {
	                    operator : "||",
	                    left     : self.condition,
	                    right    : self.alternative.body
	                })
	            }).optimize(compressor);
	        }
	        if (self.body instanceof AST_Exit
	            && self.alternative instanceof AST_Exit
	            && self.body.TYPE == self.alternative.TYPE) {
	            return make_node(self.body.CTOR, self, {
	                value: make_node(AST_Conditional, self, {
	                    condition   : self.condition,
	                    consequent  : self.body.value || make_node(AST_Undefined, self.body),
	                    alternative : self.alternative.value || make_node(AST_Undefined, self.alternative)
	                }).transform(compressor)
	            }).optimize(compressor);
	        }
	        if (self.body instanceof AST_If
	            && !self.body.alternative
	            && !self.alternative) {
	            self = make_node(AST_If, self, {
	                condition: make_node(AST_Binary, self.condition, {
	                    operator: "&&",
	                    left: self.condition,
	                    right: self.body.condition
	                }),
	                body: self.body.body,
	                alternative: null
	            });
	        }
	        if (aborts(self.body)) {
	            if (self.alternative) {
	                var alt = self.alternative;
	                self.alternative = null;
	                return make_node(AST_BlockStatement, self, {
	                    body: [ self, alt ]
	                }).optimize(compressor);
	            }
	        }
	        if (aborts(self.alternative)) {
	            var body = self.body;
	            self.body = self.alternative;
	            self.condition = negated_is_best ? negated : self.condition.negate(compressor);
	            self.alternative = null;
	            return make_node(AST_BlockStatement, self, {
	                body: [ self, body ]
	            }).optimize(compressor);
	        }
	        return self;
	    });
	
	    OPT(AST_Switch, function(self, compressor){
	        if (!compressor.option("switches")) return self;
	        var branch;
	        var value = self.expression.evaluate(compressor);
	        if (value !== self.expression) {
	            var expression = make_node_from_constant(value, self.expression).transform(compressor);
	            self.expression = best_of_expression(expression, self.expression);
	        }
	        if (!compressor.option("dead_code")) return self;
	        var decl = [];
	        var body = [];
	        var default_branch;
	        var exact_match;
	        for (var i = 0, len = self.body.length; i < len && !exact_match; i++) {
	            branch = self.body[i];
	            if (branch instanceof AST_Default) {
	                if (!default_branch) {
	                    default_branch = branch;
	                } else {
	                    eliminate_branch(branch, body[body.length - 1]);
	                }
	            } else if (value !== self.expression) {
	                var exp = branch.expression.evaluate(compressor);
	                if (exp === value) {
	                    exact_match = branch;
	                    if (default_branch) {
	                        var default_index = body.indexOf(default_branch);
	                        body.splice(default_index, 1);
	                        eliminate_branch(default_branch, body[default_index - 1]);
	                        default_branch = null;
	                    }
	                } else if (exp !== branch.expression) {
	                    eliminate_branch(branch, body[body.length - 1]);
	                    continue;
	                }
	            }
	            if (aborts(branch)) {
	                var prev = body[body.length - 1];
	                if (aborts(prev) && prev.body.length == branch.body.length
	                    && make_node(AST_BlockStatement, prev, prev).equivalent_to(make_node(AST_BlockStatement, branch, branch))) {
	                    prev.body = [];
	                }
	            }
	            body.push(branch);
	        }
	        while (i < len) eliminate_branch(self.body[i++], body[body.length - 1]);
	        if (body.length > 0) {
	            body[0].body = decl.concat(body[0].body);
	        }
	        self.body = body;
	        while (branch = body[body.length - 1]) {
	            var stat = branch.body[branch.body.length - 1];
	            if (stat instanceof AST_Break && compressor.loopcontrol_target(stat) === self)
	                branch.body.pop();
	            if (branch.body.length || branch instanceof AST_Case
	                && (default_branch || branch.expression.has_side_effects(compressor))) break;
	            if (body.pop() === default_branch) default_branch = null;
	        }
	        if (body.length == 0) {
	            return make_node(AST_BlockStatement, self, {
	                body: decl.concat(make_node(AST_SimpleStatement, self.expression, {
	                    body: self.expression
	                }))
	            }).optimize(compressor);
	        }
	        if (body.length == 1 && (body[0] === exact_match || body[0] === default_branch)) {
	            var has_break = false;
	            var tw = new TreeWalker(function(node) {
	                if (has_break
	                    || node instanceof AST_Lambda
	                    || node instanceof AST_SimpleStatement) return true;
	                if (node instanceof AST_Break && tw.loopcontrol_target(node) === self)
	                    has_break = true;
	            });
	            self.walk(tw);
	            if (!has_break) {
	                body = body[0].body.slice();
	                body.unshift(make_node(AST_SimpleStatement, self.expression, {
	                    body: self.expression
	                }));
	                return make_node(AST_BlockStatement, self, {
	                    body: body
	                }).optimize(compressor);
	            }
	        }
	        return self;
	
	        function eliminate_branch(branch, prev) {
	            if (prev && !aborts(prev)) {
	                prev.body = prev.body.concat(branch.body);
	            } else {
	                extract_declarations_from_unreachable_code(compressor, branch, decl);
	            }
	        }
	    });
	
	    OPT(AST_Try, function(self, compressor){
	        self.body = tighten_body(self.body, compressor);
	        if (self.bcatch && self.bfinally && all(self.bfinally.body, is_empty)) self.bfinally = null;
	        if (all(self.body, is_empty)) {
	            var body = [];
	            if (self.bcatch) extract_declarations_from_unreachable_code(compressor, self.bcatch, body);
	            if (self.bfinally) body = body.concat(self.bfinally.body);
	            return make_node(AST_BlockStatement, self, {
	                body: body
	            }).optimize(compressor);
	        }
	        return self;
	    });
	
	    AST_Definitions.DEFMETHOD("remove_initializers", function(){
	        this.definitions.forEach(function(def){ def.value = null });
	    });
	
	    AST_Definitions.DEFMETHOD("to_assignments", function(compressor){
	        var reduce_vars = compressor.option("reduce_vars");
	        var assignments = this.definitions.reduce(function(a, def){
	            if (def.value) {
	                var name = make_node(AST_SymbolRef, def.name, def.name);
	                a.push(make_node(AST_Assign, def, {
	                    operator : "=",
	                    left     : name,
	                    right    : def.value
	                }));
	                if (reduce_vars) name.definition().fixed = false;
	            }
	            return a;
	        }, []);
	        if (assignments.length == 0) return null;
	        return AST_Seq.from_array(assignments);
	    });
	
	    OPT(AST_Definitions, function(self, compressor){
	        if (self.definitions.length == 0)
	            return make_node(AST_EmptyStatement, self);
	        return self;
	    });
	
	    OPT(AST_Call, function(self, compressor){
	        var exp = self.expression;
	        if (compressor.option("reduce_vars")
	            && exp instanceof AST_SymbolRef) {
	            var def = exp.definition();
	            var fixed = exp.fixed_value();
	            if (fixed instanceof AST_Defun) {
	                def.fixed = fixed = make_node(AST_Function, fixed, fixed).clone(true);
	            }
	            if (fixed instanceof AST_Function) {
	                exp = fixed;
	                if (compressor.option("unused")
	                    && def.references.length == 1
	                    && !(def.scope.uses_arguments
	                        && def.orig[0] instanceof AST_SymbolFunarg)
	                    && !def.scope.uses_eval
	                    && compressor.find_parent(AST_Scope) === def.scope) {
	                    self.expression = exp;
	                }
	            }
	        }
	        if (compressor.option("unused")
	            && exp instanceof AST_Function
	            && !exp.uses_arguments
	            && !exp.uses_eval) {
	            var pos = 0, last = 0;
	            for (var i = 0, len = self.args.length; i < len; i++) {
	                var trim = i >= exp.argnames.length;
	                if (trim || exp.argnames[i].__unused) {
	                    var node = self.args[i].drop_side_effect_free(compressor);
	                    if (node) {
	                        self.args[pos++] = node;
	                    } else if (!trim) {
	                        self.args[pos++] = make_node(AST_Number, self.args[i], {
	                            value: 0
	                        });
	                        continue;
	                    }
	                } else {
	                    self.args[pos++] = self.args[i];
	                }
	                last = pos;
	            }
	            self.args.length = last;
	        }
	        if (compressor.option("unsafe")) {
	            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
	                switch (exp.name) {
	                  case "Array":
	                    if (self.args.length != 1) {
	                        return make_node(AST_Array, self, {
	                            elements: self.args
	                        }).optimize(compressor);
	                    }
	                    break;
	                  case "Object":
	                    if (self.args.length == 0) {
	                        return make_node(AST_Object, self, {
	                            properties: []
	                        });
	                    }
	                    break;
	                  case "String":
	                    if (self.args.length == 0) return make_node(AST_String, self, {
	                        value: ""
	                    });
	                    if (self.args.length <= 1) return make_node(AST_Binary, self, {
	                        left: self.args[0],
	                        operator: "+",
	                        right: make_node(AST_String, self, { value: "" })
	                    }).optimize(compressor);
	                    break;
	                  case "Number":
	                    if (self.args.length == 0) return make_node(AST_Number, self, {
	                        value: 0
	                    });
	                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
	                        expression: self.args[0],
	                        operator: "+"
	                    }).optimize(compressor);
	                  case "Boolean":
	                    if (self.args.length == 0) return make_node(AST_False, self);
	                    if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {
	                        expression: make_node(AST_UnaryPrefix, self, {
	                            expression: self.args[0],
	                            operator: "!"
	                        }),
	                        operator: "!"
	                    }).optimize(compressor);
	                    break;
	                  case "Function":
	                    // new Function() => function(){}
	                    if (self.args.length == 0) return make_node(AST_Function, self, {
	                        argnames: [],
	                        body: []
	                    });
	                    if (all(self.args, function(x){ return x instanceof AST_String })) {
	                        // quite a corner-case, but we can handle it:
	                        //   https://github.com/mishoo/UglifyJS2/issues/203
	                        // if the code argument is a constant, then we can minify it.
	                        try {
	                            var code = "(function(" + self.args.slice(0, -1).map(function(arg){
	                                return arg.value;
	                            }).join(",") + "){" + self.args[self.args.length - 1].value + "})()";
	                            var ast = parse(code);
	                            ast.figure_out_scope({ screw_ie8: compressor.option("screw_ie8") });
	                            var comp = new Compressor(compressor.options);
	                            ast = ast.transform(comp);
	                            ast.figure_out_scope({ screw_ie8: compressor.option("screw_ie8") });
	                            ast.mangle_names();
	                            var fun;
	                            try {
	                                ast.walk(new TreeWalker(function(node){
	                                    if (node instanceof AST_Lambda) {
	                                        fun = node;
	                                        throw ast;
	                                    }
	                                }));
	                            } catch(ex) {
	                                if (ex !== ast) throw ex;
	                            };
	                            if (!fun) return self;
	                            var args = fun.argnames.map(function(arg, i){
	                                return make_node(AST_String, self.args[i], {
	                                    value: arg.print_to_string()
	                                });
	                            });
	                            var code = OutputStream();
	                            AST_BlockStatement.prototype._codegen.call(fun, fun, code);
	                            code = code.toString().replace(/^\{|\}$/g, "");
	                            args.push(make_node(AST_String, self.args[self.args.length - 1], {
	                                value: code
	                            }));
	                            self.args = args;
	                            return self;
	                        } catch(ex) {
	                            if (ex instanceof JS_Parse_Error) {
	                                compressor.warn("Error parsing code passed to new Function [{file}:{line},{col}]", self.args[self.args.length - 1].start);
	                                compressor.warn(ex.toString());
	                            } else {
	                                console.log(ex);
	                                throw ex;
	                            }
	                        }
	                    }
	                    break;
	                }
	            }
	            else if (exp instanceof AST_Dot && exp.property == "toString" && self.args.length == 0) {
	                return make_node(AST_Binary, self, {
	                    left: make_node(AST_String, self, { value: "" }),
	                    operator: "+",
	                    right: exp.expression
	                }).optimize(compressor);
	            }
	            else if (exp instanceof AST_Dot && exp.expression instanceof AST_Array && exp.property == "join") EXIT: {
	                var separator;
	                if (self.args.length > 0) {
	                    separator = self.args[0].evaluate(compressor);
	                    if (separator === self.args[0]) break EXIT; // not a constant
	                }
	                var elements = [];
	                var consts = [];
	                exp.expression.elements.forEach(function(el) {
	                    var value = el.evaluate(compressor);
	                    if (value !== el) {
	                        consts.push(value);
	                    } else {
	                        if (consts.length > 0) {
	                            elements.push(make_node(AST_String, self, {
	                                value: consts.join(separator)
	                            }));
	                            consts.length = 0;
	                        }
	                        elements.push(el);
	                    }
	                });
	                if (consts.length > 0) {
	                    elements.push(make_node(AST_String, self, {
	                        value: consts.join(separator)
	                    }));
	                }
	                if (elements.length == 0) return make_node(AST_String, self, { value: "" });
	                if (elements.length == 1) {
	                    if (elements[0].is_string(compressor)) {
	                        return elements[0];
	                    }
	                    return make_node(AST_Binary, elements[0], {
	                        operator : "+",
	                        left     : make_node(AST_String, self, { value: "" }),
	                        right    : elements[0]
	                    });
	                }
	                if (separator == "") {
	                    var first;
	                    if (elements[0].is_string(compressor)
	                        || elements[1].is_string(compressor)) {
	                        first = elements.shift();
	                    } else {
	                        first = make_node(AST_String, self, { value: "" });
	                    }
	                    return elements.reduce(function(prev, el){
	                        return make_node(AST_Binary, el, {
	                            operator : "+",
	                            left     : prev,
	                            right    : el
	                        });
	                    }, first).optimize(compressor);
	                }
	                // need this awkward cloning to not affect original element
	                // best_of will decide which one to get through.
	                var node = self.clone();
	                node.expression = node.expression.clone();
	                node.expression.expression = node.expression.expression.clone();
	                node.expression.expression.elements = elements;
	                return best_of(compressor, self, node);
	            }
	            else if (exp instanceof AST_Dot && exp.expression.is_string(compressor) && exp.property == "charAt") {
	                var arg = self.args[0];
	                var index = arg ? arg.evaluate(compressor) : 0;
	                if (index !== arg) {
	                    return make_node(AST_Sub, exp, {
	                        expression: exp.expression,
	                        property: make_node_from_constant(index | 0, arg || exp)
	                    }).optimize(compressor);
	                }
	            }
	        }
	        if (exp instanceof AST_Function) {
	            if (exp.body[0] instanceof AST_Return) {
	                var value = exp.body[0].value;
	                if (!value || value.is_constant()) {
	                    var args = self.args.concat(value || make_node(AST_Undefined, self));
	                    return AST_Seq.from_array(args).transform(compressor);
	                }
	            }
	            if (compressor.option("side_effects") && all(exp.body, is_empty)) {
	                var args = self.args.concat(make_node(AST_Undefined, self));
	                return AST_Seq.from_array(args).transform(compressor);
	            }
	        }
	        if (compressor.option("drop_console")) {
	            if (exp instanceof AST_PropAccess) {
	                var name = exp.expression;
	                while (name.expression) {
	                    name = name.expression;
	                }
	                if (name instanceof AST_SymbolRef
	                    && name.name == "console"
	                    && name.undeclared()) {
	                    return make_node(AST_Undefined, self).optimize(compressor);
	                }
	            }
	        }
	        if (compressor.option("negate_iife")
	            && compressor.parent() instanceof AST_SimpleStatement
	            && is_iife_call(self)) {
	            return self.negate(compressor, true);
	        }
	        return self;
	    });
	
	    OPT(AST_New, function(self, compressor){
	        if (compressor.option("unsafe")) {
	            var exp = self.expression;
	            if (exp instanceof AST_SymbolRef && exp.undeclared()) {
	                switch (exp.name) {
	                  case "Object":
	                  case "RegExp":
	                  case "Function":
	                  case "Error":
	                  case "Array":
	                    return make_node(AST_Call, self, self).transform(compressor);
	                }
	            }
	        }
	        return self;
	    });
	
	    OPT(AST_Seq, function(self, compressor){
	        if (!compressor.option("side_effects"))
	            return self;
	        self.car = self.car.drop_side_effect_free(compressor, first_in_statement(compressor));
	        if (!self.car) return maintain_this_binding(compressor.parent(), self, self.cdr);
	        if (compressor.option("cascade")) {
	            var left;
	            if (self.car instanceof AST_Assign
	                && !self.car.left.has_side_effects(compressor)) {
	                left = self.car.left;
	            } else if (self.car instanceof AST_Unary
	                && (self.car.operator == "++" || self.car.operator == "--")) {
	                left = self.car.expression;
	            }
	            if (left
	                && !(left instanceof AST_SymbolRef
	                    && (left.definition().orig[0] instanceof AST_SymbolLambda
	                        || is_reference_const(left)))) {
	                var parent, field;
	                var cdr = self.cdr;
	                while (true) {
	                    if (cdr.equivalent_to(left)) {
	                        var car = self.car instanceof AST_UnaryPostfix ? make_node(AST_UnaryPrefix, self.car, {
	                            operator: self.car.operator,
	                            expression: left
	                        }) : self.car;
	                        if (parent) {
	                            parent[field] = car;
	                            return self.cdr;
	                        }
	                        return car;
	                    }
	                    if (cdr instanceof AST_Binary && !(cdr instanceof AST_Assign)) {
	                        if (cdr.left.is_constant()) {
	                            if (cdr.operator == "||" || cdr.operator == "&&") break;
	                            field = "right";
	                        } else {
	                            field = "left";
	                        }
	                    } else if (cdr instanceof AST_Call
	                        || cdr instanceof AST_Unary && !unary_side_effects(cdr.operator)) {
	                        field = "expression";
	                    } else break;
	                    parent = cdr;
	                    cdr = cdr[field];
	                }
	            }
	        }
	        if (is_undefined(self.cdr, compressor)) {
	            return make_node(AST_UnaryPrefix, self, {
	                operator   : "void",
	                expression : self.car
	            });
	        }
	        return self;
	    });
	
	    AST_Unary.DEFMETHOD("lift_sequences", function(compressor){
	        if (compressor.option("sequences")) {
	            if (this.expression instanceof AST_Seq) {
	                var seq = this.expression;
	                var x = seq.to_array();
	                var e = this.clone();
	                e.expression = x.pop();
	                x.push(e);
	                seq = AST_Seq.from_array(x).transform(compressor);
	                return seq;
	            }
	        }
	        return this;
	    });
	
	    OPT(AST_UnaryPostfix, function(self, compressor){
	        return self.lift_sequences(compressor);
	    });
	
	    OPT(AST_UnaryPrefix, function(self, compressor){
	        var e = self.expression;
	        if (self.operator == "delete"
	            && !(e instanceof AST_SymbolRef
	                || e instanceof AST_PropAccess
	                || e instanceof AST_NaN
	                || e instanceof AST_Infinity
	                || e instanceof AST_Undefined)) {
	            if (e instanceof AST_Seq) {
	                e = e.to_array();
	                e.push(make_node(AST_True, self));
	                return AST_Seq.from_array(e).optimize(compressor);
	            }
	            return make_node(AST_Seq, self, {
	                car: e,
	                cdr: make_node(AST_True, self)
	            }).optimize(compressor);
	        }
	        var seq = self.lift_sequences(compressor);
	        if (seq !== self) {
	            return seq;
	        }
	        if (compressor.option("side_effects") && self.operator == "void") {
	            e = e.drop_side_effect_free(compressor);
	            if (e) {
	                self.expression = e;
	                return self;
	            } else {
	                return make_node(AST_Undefined, self).optimize(compressor);
	            }
	        }
	        if (compressor.option("booleans") && compressor.in_boolean_context()) {
	            switch (self.operator) {
	              case "!":
	                if (e instanceof AST_UnaryPrefix && e.operator == "!") {
	                    // !!foo ==> foo, if we're in boolean context
	                    return e.expression;
	                }
	                if (e instanceof AST_Binary) {
	                    self = best_of(compressor, self, e.negate(compressor, first_in_statement(compressor)));
	                }
	                break;
	              case "typeof":
	                // typeof always returns a non-empty string, thus it's
	                // always true in booleans
	                compressor.warn("Boolean expression always true [{file}:{line},{col}]", self.start);
	                return (e instanceof AST_SymbolRef ? make_node(AST_True, self) : make_node(AST_Seq, self, {
	                    car: e,
	                    cdr: make_node(AST_True, self)
	                })).optimize(compressor);
	            }
	        }
	        if (self.operator == "-" && e instanceof AST_Infinity) {
	            e = e.transform(compressor);
	        }
	        if (e instanceof AST_Binary
	            && (self.operator == "+" || self.operator == "-")
	            && (e.operator == "*" || e.operator == "/" || e.operator == "%")) {
	            return make_node(AST_Binary, self, {
	                operator: e.operator,
	                left: make_node(AST_UnaryPrefix, e.left, {
	                    operator: self.operator,
	                    expression: e.left
	                }),
	                right: e.right
	            });
	        }
	        // avoids infinite recursion of numerals
	        if (self.operator != "-"
	            || !(e instanceof AST_Number || e instanceof AST_Infinity)) {
	            var ev = self.evaluate(compressor);
	            if (ev !== self) {
	                ev = make_node_from_constant(ev, self).optimize(compressor);
	                return best_of(compressor, ev, self);
	            }
	        }
	        return self;
	    });
	
	    AST_Binary.DEFMETHOD("lift_sequences", function(compressor){
	        if (compressor.option("sequences")) {
	            if (this.left instanceof AST_Seq) {
	                var seq = this.left;
	                var x = seq.to_array();
	                var e = this.clone();
	                e.left = x.pop();
	                x.push(e);
	                return AST_Seq.from_array(x).optimize(compressor);
	            }
	            if (this.right instanceof AST_Seq && !this.left.has_side_effects(compressor)) {
	                var assign = this.operator == "=" && this.left instanceof AST_SymbolRef;
	                var root = this.right.clone();
	                var cursor, seq = root;
	                while (assign || !seq.car.has_side_effects(compressor)) {
	                    cursor = seq;
	                    if (seq.cdr instanceof AST_Seq) {
	                        seq = seq.cdr = seq.cdr.clone();
	                    } else break;
	                }
	                if (cursor) {
	                    var e = this.clone();
	                    e.right = cursor.cdr;
	                    cursor.cdr = e;
	                    return root.optimize(compressor);
	                }
	            }
	        }
	        return this;
	    });
	
	    var commutativeOperators = makePredicate("== === != !== * & | ^");
	
	    OPT(AST_Binary, function(self, compressor){
	        function reversible() {
	            return self.left.is_constant()
	                || self.right.is_constant()
	                || !self.left.has_side_effects(compressor)
	                    && !self.right.has_side_effects(compressor);
	        }
	        function reverse(op) {
	            if (reversible()) {
	                if (op) self.operator = op;
	                var tmp = self.left;
	                self.left = self.right;
	                self.right = tmp;
	            }
	        }
	        if (commutativeOperators(self.operator)) {
	            if (self.right.is_constant()
	                && !self.left.is_constant()) {
	                // if right is a constant, whatever side effects the
	                // left side might have could not influence the
	                // result.  hence, force switch.
	
	                if (!(self.left instanceof AST_Binary
	                      && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
	                    reverse();
	                }
	            }
	        }
	        self = self.lift_sequences(compressor);
	        if (compressor.option("comparisons")) switch (self.operator) {
	          case "===":
	          case "!==":
	            if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||
	                (self.left.is_number(compressor) && self.right.is_number(compressor)) ||
	                (self.left.is_boolean() && self.right.is_boolean())) {
	                self.operator = self.operator.substr(0, 2);
	            }
	            // XXX: intentionally falling down to the next case
	          case "==":
	          case "!=":
	            // "undefined" == typeof x => undefined === x
	            if (self.left instanceof AST_String
	                && self.left.value == "undefined"
	                && self.right instanceof AST_UnaryPrefix
	                && self.right.operator == "typeof") {
	                var expr = self.right.expression;
	                if (expr instanceof AST_SymbolRef ? !expr.undeclared()
	                    : !(expr instanceof AST_PropAccess) || compressor.option("screw_ie8")) {
	                    self.right = expr;
	                    self.left = make_node(AST_Undefined, self.left).optimize(compressor);
	                    if (self.operator.length == 2) self.operator += "=";
	                }
	            }
	            break;
	        }
	        if (compressor.option("booleans") && self.operator == "+" && compressor.in_boolean_context()) {
	            var ll = self.left.evaluate(compressor);
	            var rr = self.right.evaluate(compressor);
	            if (ll && typeof ll == "string") {
	                compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
	                return make_node(AST_Seq, self, {
	                    car: self.right,
	                    cdr: make_node(AST_True, self)
	                }).optimize(compressor);
	            }
	            if (rr && typeof rr == "string") {
	                compressor.warn("+ in boolean context always true [{file}:{line},{col}]", self.start);
	                return make_node(AST_Seq, self, {
	                    car: self.left,
	                    cdr: make_node(AST_True, self)
	                }).optimize(compressor);
	            }
	        }
	        if (compressor.option("comparisons") && self.is_boolean()) {
	            if (!(compressor.parent() instanceof AST_Binary)
	                || compressor.parent() instanceof AST_Assign) {
	                var negated = make_node(AST_UnaryPrefix, self, {
	                    operator: "!",
	                    expression: self.negate(compressor, first_in_statement(compressor))
	                });
	                self = best_of(compressor, self, negated);
	            }
	            if (compressor.option("unsafe_comps")) {
	                switch (self.operator) {
	                  case "<": reverse(">"); break;
	                  case "<=": reverse(">="); break;
	                }
	            }
	        }
	        if (self.operator == "+") {
	            if (self.right instanceof AST_String
	                && self.right.getValue() == ""
	                && self.left.is_string(compressor)) {
	                return self.left;
	            }
	            if (self.left instanceof AST_String
	                && self.left.getValue() == ""
	                && self.right.is_string(compressor)) {
	                return self.right;
	            }
	            if (self.left instanceof AST_Binary
	                && self.left.operator == "+"
	                && self.left.left instanceof AST_String
	                && self.left.left.getValue() == ""
	                && self.right.is_string(compressor)) {
	                self.left = self.left.right;
	                return self.transform(compressor);
	            }
	        }
	        if (compressor.option("evaluate")) {
	            switch (self.operator) {
	              case "&&":
	                var ll = self.left.evaluate(compressor);
	                if (!ll) {
	                    compressor.warn("Condition left of && always false [{file}:{line},{col}]", self.start);
	                    return maintain_this_binding(compressor.parent(), self, self.left).optimize(compressor);
	                } else if (ll !== self.left) {
	                    compressor.warn("Condition left of && always true [{file}:{line},{col}]", self.start);
	                    return maintain_this_binding(compressor.parent(), self, self.right).optimize(compressor);
	                }
	                if (compressor.option("booleans") && compressor.in_boolean_context()) {
	                    var rr = self.right.evaluate(compressor);
	                    if (!rr) {
	                        compressor.warn("Boolean && always false [{file}:{line},{col}]", self.start);
	                        return make_node(AST_Seq, self, {
	                            car: self.left,
	                            cdr: make_node(AST_False, self)
	                        }).optimize(compressor);
	                    } else if (rr !== self.right) {
	                        compressor.warn("Dropping side-effect-free && in boolean context [{file}:{line},{col}]", self.start);
	                        return self.left.optimize(compressor);
	                    }
	                }
	                break;
	              case "||":
	                var ll = self.left.evaluate(compressor);
	                if (!ll) {
	                    compressor.warn("Condition left of || always false [{file}:{line},{col}]", self.start);
	                    return maintain_this_binding(compressor.parent(), self, self.right).optimize(compressor);
	                } else if (ll !== self.left) {
	                    compressor.warn("Condition left of || always true [{file}:{line},{col}]", self.start);
	                    return maintain_this_binding(compressor.parent(), self, self.left).optimize(compressor);
	                }
	                if (compressor.option("booleans") && compressor.in_boolean_context()) {
	                    var rr = self.right.evaluate(compressor);
	                    if (!rr) {
	                        compressor.warn("Dropping side-effect-free || in boolean context [{file}:{line},{col}]", self.start);
	                        return self.left.optimize(compressor);
	                    } else if (rr !== self.right) {
	                        compressor.warn("Boolean || always true [{file}:{line},{col}]", self.start);
	                        return make_node(AST_Seq, self, {
	                            car: self.left,
	                            cdr: make_node(AST_True, self)
	                        }).optimize(compressor);
	                    }
	                }
	                break;
	            }
	            var associative = true;
	            switch (self.operator) {
	              case "+":
	                // "foo" + ("bar" + x) => "foobar" + x
	                if (self.left instanceof AST_Constant
	                    && self.right instanceof AST_Binary
	                    && self.right.operator == "+"
	                    && self.right.left instanceof AST_Constant
	                    && self.right.is_string(compressor)) {
	                    self = make_node(AST_Binary, self, {
	                        operator: "+",
	                        left: make_node(AST_String, self.left, {
	                            value: "" + self.left.getValue() + self.right.left.getValue(),
	                            start: self.left.start,
	                            end: self.right.left.end
	                        }),
	                        right: self.right.right
	                    });
	                }
	                // (x + "foo") + "bar" => x + "foobar"
	                if (self.right instanceof AST_Constant
	                    && self.left instanceof AST_Binary
	                    && self.left.operator == "+"
	                    && self.left.right instanceof AST_Constant
	                    && self.left.is_string(compressor)) {
	                    self = make_node(AST_Binary, self, {
	                        operator: "+",
	                        left: self.left.left,
	                        right: make_node(AST_String, self.right, {
	                            value: "" + self.left.right.getValue() + self.right.getValue(),
	                            start: self.left.right.start,
	                            end: self.right.end
	                        })
	                    });
	                }
	                // (x + "foo") + ("bar" + y) => (x + "foobar") + y
	                if (self.left instanceof AST_Binary
	                    && self.left.operator == "+"
	                    && self.left.is_string(compressor)
	                    && self.left.right instanceof AST_Constant
	                    && self.right instanceof AST_Binary
	                    && self.right.operator == "+"
	                    && self.right.left instanceof AST_Constant
	                    && self.right.is_string(compressor)) {
	                    self = make_node(AST_Binary, self, {
	                        operator: "+",
	                        left: make_node(AST_Binary, self.left, {
	                            operator: "+",
	                            left: self.left.left,
	                            right: make_node(AST_String, self.left.right, {
	                                value: "" + self.left.right.getValue() + self.right.left.getValue(),
	                                start: self.left.right.start,
	                                end: self.right.left.end
	                            })
	                        }),
	                        right: self.right.right
	                    });
	                }
	                // a + -b => a - b
	                if (self.right instanceof AST_UnaryPrefix
	                    && self.right.operator == "-"
	                    && self.left.is_number(compressor)) {
	                    self = make_node(AST_Binary, self, {
	                        operator: "-",
	                        left: self.left,
	                        right: self.right.expression
	                    });
	                    break;
	                }
	                // -a + b => b - a
	                if (self.left instanceof AST_UnaryPrefix
	                    && self.left.operator == "-"
	                    && reversible()
	                    && self.right.is_number(compressor)) {
	                    self = make_node(AST_Binary, self, {
	                        operator: "-",
	                        left: self.right,
	                        right: self.left.expression
	                    });
	                    break;
	                }
	              case "*":
	                associative = compressor.option("unsafe_math");
	              case "&":
	              case "|":
	              case "^":
	                // a + +b => +b + a
	                if (self.left.is_number(compressor)
	                    && self.right.is_number(compressor)
	                    && reversible()
	                    && !(self.left instanceof AST_Binary
	                        && self.left.operator != self.operator
	                        && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {
	                    var reversed = make_node(AST_Binary, self, {
	                        operator: self.operator,
	                        left: self.right,
	                        right: self.left
	                    });
	                    if (self.right instanceof AST_Constant
	                        && !(self.left instanceof AST_Constant)) {
	                        self = best_of(compressor, reversed, self);
	                    } else {
	                        self = best_of(compressor, self, reversed);
	                    }
	                }
	                if (associative && self.is_number(compressor)) {
	                    // a + (b + c) => (a + b) + c
	                    if (self.right instanceof AST_Binary
	                        && self.right.operator == self.operator) {
	                        self = make_node(AST_Binary, self, {
	                            operator: self.operator,
	                            left: make_node(AST_Binary, self.left, {
	                                operator: self.operator,
	                                left: self.left,
	                                right: self.right.left,
	                                start: self.left.start,
	                                end: self.right.left.end
	                            }),
	                            right: self.right.right
	                        });
	                    }
	                    // (n + 2) + 3 => 5 + n
	                    // (2 * n) * 3 => 6 + n
	                    if (self.right instanceof AST_Constant
	                        && self.left instanceof AST_Binary
	                        && self.left.operator == self.operator) {
	                        if (self.left.left instanceof AST_Constant) {
	                            self = make_node(AST_Binary, self, {
	                                operator: self.operator,
	                                left: make_node(AST_Binary, self.left, {
	                                    operator: self.operator,
	                                    left: self.left.left,
	                                    right: self.right,
	                                    start: self.left.left.start,
	                                    end: self.right.end
	                                }),
	                                right: self.left.right
	                            });
	                        } else if (self.left.right instanceof AST_Constant) {
	                            self = make_node(AST_Binary, self, {
	                                operator: self.operator,
	                                left: make_node(AST_Binary, self.left, {
	                                    operator: self.operator,
	                                    left: self.left.right,
	                                    right: self.right,
	                                    start: self.left.right.start,
	                                    end: self.right.end
	                                }),
	                                right: self.left.left
	                            });
	                        }
	                    }
	                    // (a | 1) | (2 | d) => (3 | a) | b
	                    if (self.left instanceof AST_Binary
	                        && self.left.operator == self.operator
	                        && self.left.right instanceof AST_Constant
	                        && self.right instanceof AST_Binary
	                        && self.right.operator == self.operator
	                        && self.right.left instanceof AST_Constant) {
	                        self = make_node(AST_Binary, self, {
	                            operator: self.operator,
	                            left: make_node(AST_Binary, self.left, {
	                                operator: self.operator,
	                                left: make_node(AST_Binary, self.left.left, {
	                                    operator: self.operator,
	                                    left: self.left.right,
	                                    right: self.right.left,
	                                    start: self.left.right.start,
	                                    end: self.right.left.end
	                                }),
	                                right: self.left.left
	                            }),
	                            right: self.right.right
	                        });
	                    }
	                }
	            }
	        }
	        // x && (y && z)  ==>  x && y && z
	        // x || (y || z)  ==>  x || y || z
	        // x + ("y" + z)  ==>  x + "y" + z
	        // "x" + (y + "z")==>  "x" + y + "z"
	        if (self.right instanceof AST_Binary
	            && self.right.operator == self.operator
	            && (self.operator == "&&"
	                || self.operator == "||"
	                || (self.operator == "+"
	                    && (self.right.left.is_string(compressor)
	                        || (self.left.is_string(compressor)
	                            && self.right.right.is_string(compressor))))))
	        {
	            self.left = make_node(AST_Binary, self.left, {
	                operator : self.operator,
	                left     : self.left,
	                right    : self.right.left
	            });
	            self.right = self.right.right;
	            return self.transform(compressor);
	        }
	        var ev = self.evaluate(compressor);
	        if (ev !== self) {
	            ev = make_node_from_constant(ev, self).optimize(compressor);
	            return best_of(compressor, ev, self);
	        }
	        return self;
	    });
	
	    OPT(AST_SymbolRef, function(self, compressor){
	        var def = self.resolve_defines(compressor);
	        if (def) {
	            return def.optimize(compressor);
	        }
	        // testing against !self.scope.uses_with first is an optimization
	        if (compressor.option("screw_ie8")
	            && self.undeclared()
	            && (!self.scope.uses_with || !compressor.find_parent(AST_With))) {
	            switch (self.name) {
	              case "undefined":
	                return make_node(AST_Undefined, self).optimize(compressor);
	              case "NaN":
	                return make_node(AST_NaN, self).optimize(compressor);
	              case "Infinity":
	                return make_node(AST_Infinity, self).optimize(compressor);
	            }
	        }
	        if (compressor.option("evaluate")
	            && compressor.option("reduce_vars")
	            && is_lhs(self, compressor.parent()) !== self) {
	            var d = self.definition();
	            var fixed = self.fixed_value();
	            if (fixed) {
	                if (d.should_replace === undefined) {
	                    var init = fixed.evaluate(compressor);
	                    if (init !== fixed && (compressor.option("unsafe_regexp") || !(init instanceof RegExp))) {
	                        init = make_node_from_constant(init, fixed);
	                        var value = init.optimize(compressor).print_to_string().length;
	                        var fn;
	                        if (has_symbol_ref(fixed)) {
	                            fn = function() {
	                                var result = init.optimize(compressor);
	                                return result === init ? result.clone(true) : result;
	                            };
	                        } else {
	                            value = Math.min(value, fixed.print_to_string().length);
	                            fn = function() {
	                                var result = best_of_expression(init.optimize(compressor), fixed);
	                                return result === init || result === fixed ? result.clone(true) : result;
	                            };
	                        }
	                        var name = d.name.length;
	                        var overhead = 0;
	                        if (compressor.option("unused") && (!d.global || compressor.option("toplevel"))) {
	                            overhead = (name + 2 + value) / d.references.length;
	                        }
	                        d.should_replace = value <= name + overhead ? fn : false;
	                    } else {
	                        d.should_replace = false;
	                    }
	                }
	                if (d.should_replace) {
	                    return d.should_replace();
	                }
	            }
	        }
	        return self;
	
	        function has_symbol_ref(value) {
	            var found;
	            value.walk(new TreeWalker(function(node) {
	                if (node instanceof AST_SymbolRef) found = true;
	                if (found) return true;
	            }));
	            return found;
	        }
	    });
	
	    function is_atomic(lhs, self) {
	        return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;
	    }
	
	    OPT(AST_Undefined, function(self, compressor){
	        if (compressor.option("unsafe")) {
	            var undef = find_variable(compressor, "undefined");
	            if (undef) {
	                var ref = make_node(AST_SymbolRef, self, {
	                    name   : "undefined",
	                    scope  : undef.scope,
	                    thedef : undef
	                });
	                ref.is_undefined = true;
	                return ref;
	            }
	        }
	        var lhs = is_lhs(compressor.self(), compressor.parent());
	        if (lhs && is_atomic(lhs, self)) return self;
	        return make_node(AST_UnaryPrefix, self, {
	            operator: "void",
	            expression: make_node(AST_Number, self, {
	                value: 0
	            })
	        });
	    });
	
	    OPT(AST_Infinity, function(self, compressor){
	        var lhs = is_lhs(compressor.self(), compressor.parent());
	        if (lhs && is_atomic(lhs, self)) return self;
	        if (compressor.option("keep_infinity")
	            && !(lhs && !is_atomic(lhs, self))
	            && !find_variable(compressor, "Infinity"))
	            return self;
	        return make_node(AST_Binary, self, {
	            operator: "/",
	            left: make_node(AST_Number, self, {
	                value: 1
	            }),
	            right: make_node(AST_Number, self, {
	                value: 0
	            })
	        });
	    });
	
	    OPT(AST_NaN, function(self, compressor){
	        var lhs = is_lhs(compressor.self(), compressor.parent());
	        if (lhs && !is_atomic(lhs, self)
	            || find_variable(compressor, "NaN")) {
	            return make_node(AST_Binary, self, {
	                operator: "/",
	                left: make_node(AST_Number, self, {
	                    value: 0
	                }),
	                right: make_node(AST_Number, self, {
	                    value: 0
	                })
	            });
	        }
	        return self;
	    });
	
	    var ASSIGN_OPS = [ '+', '-', '/', '*', '%', '>>', '<<', '>>>', '|', '^', '&' ];
	    var ASSIGN_OPS_COMMUTATIVE = [ '*', '|', '^', '&' ];
	    OPT(AST_Assign, function(self, compressor){
	        self = self.lift_sequences(compressor);
	        if (self.operator == "=" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {
	            // x = expr1 OP expr2
	            if (self.right.left instanceof AST_SymbolRef
	                && self.right.left.name == self.left.name
	                && member(self.right.operator, ASSIGN_OPS)) {
	                // x = x - 2  --->  x -= 2
	                self.operator = self.right.operator + "=";
	                self.right = self.right.right;
	            }
	            else if (self.right.right instanceof AST_SymbolRef
	                && self.right.right.name == self.left.name
	                && member(self.right.operator, ASSIGN_OPS_COMMUTATIVE)
	                && !self.right.left.has_side_effects(compressor)) {
	                // x = 2 & x  --->  x &= 2
	                self.operator = self.right.operator + "=";
	                self.right = self.right.left;
	            }
	        }
	        return self;
	    });
	
	    OPT(AST_Conditional, function(self, compressor){
	        if (!compressor.option("conditionals")) return self;
	        if (self.condition instanceof AST_Seq) {
	            var car = self.condition.car;
	            self.condition = self.condition.cdr;
	            return AST_Seq.cons(car, self);
	        }
	        var cond = self.condition.evaluate(compressor);
	        if (cond !== self.condition) {
	            if (cond) {
	                compressor.warn("Condition always true [{file}:{line},{col}]", self.start);
	                return maintain_this_binding(compressor.parent(), self, self.consequent);
	            } else {
	                compressor.warn("Condition always false [{file}:{line},{col}]", self.start);
	                return maintain_this_binding(compressor.parent(), self, self.alternative);
	            }
	        }
	        var negated = cond.negate(compressor, first_in_statement(compressor));
	        if (best_of(compressor, cond, negated) === negated) {
	            self = make_node(AST_Conditional, self, {
	                condition: negated,
	                consequent: self.alternative,
	                alternative: self.consequent
	            });
	        }
	        var condition = self.condition;
	        var consequent = self.consequent;
	        var alternative = self.alternative;
	        // x?x:y --> x||y
	        if (condition instanceof AST_SymbolRef
	            && consequent instanceof AST_SymbolRef
	            && condition.definition() === consequent.definition()) {
	            return make_node(AST_Binary, self, {
	                operator: "||",
	                left: condition,
	                right: alternative
	            });
	        }
	        // if (foo) exp = something; else exp = something_else;
	        //                   |
	        //                   v
	        // exp = foo ? something : something_else;
	        if (consequent instanceof AST_Assign
	            && alternative instanceof AST_Assign
	            && consequent.operator == alternative.operator
	            && consequent.left.equivalent_to(alternative.left)
	            && (!self.condition.has_side_effects(compressor)
	                || consequent.operator == "="
	                    && !consequent.left.has_side_effects(compressor))) {
	            return make_node(AST_Assign, self, {
	                operator: consequent.operator,
	                left: consequent.left,
	                right: make_node(AST_Conditional, self, {
	                    condition: self.condition,
	                    consequent: consequent.right,
	                    alternative: alternative.right
	                })
	            });
	        }
	        // x ? y(a) : y(b) --> y(x ? a : b)
	        if (consequent instanceof AST_Call
	            && alternative.TYPE === consequent.TYPE
	            && consequent.args.length == 1
	            && alternative.args.length == 1
	            && consequent.expression.equivalent_to(alternative.expression)
	            && !consequent.expression.has_side_effects(compressor)) {
	            consequent.args[0] = make_node(AST_Conditional, self, {
	                condition: self.condition,
	                consequent: consequent.args[0],
	                alternative: alternative.args[0]
	            });
	            return consequent;
	        }
	        // x?y?z:a:a --> x&&y?z:a
	        if (consequent instanceof AST_Conditional
	            && consequent.alternative.equivalent_to(alternative)) {
	            return make_node(AST_Conditional, self, {
	                condition: make_node(AST_Binary, self, {
	                    left: self.condition,
	                    operator: "&&",
	                    right: consequent.condition
	                }),
	                consequent: consequent.consequent,
	                alternative: alternative
	            });
	        }
	        // x ? y : y --> x, y
	        if (consequent.equivalent_to(alternative)) {
	            return make_node(AST_Seq, self, {
	                car: self.condition,
	                cdr: consequent
	            }).optimize(compressor);
	        }
	
	        if (is_true(self.consequent)) {
	            if (is_false(self.alternative)) {
	                // c ? true : false ---> !!c
	                return booleanize(self.condition);
	            }
	            // c ? true : x ---> !!c || x
	            return make_node(AST_Binary, self, {
	                operator: "||",
	                left: booleanize(self.condition),
	                right: self.alternative
	            });
	        }
	        if (is_false(self.consequent)) {
	            if (is_true(self.alternative)) {
	                // c ? false : true ---> !c
	                return booleanize(self.condition.negate(compressor));
	            }
	            // c ? false : x ---> !c && x
	            return make_node(AST_Binary, self, {
	                operator: "&&",
	                left: booleanize(self.condition.negate(compressor)),
	                right: self.alternative
	            });
	        }
	        if (is_true(self.alternative)) {
	            // c ? x : true ---> !c || x
	            return make_node(AST_Binary, self, {
	                operator: "||",
	                left: booleanize(self.condition.negate(compressor)),
	                right: self.consequent
	            });
	        }
	        if (is_false(self.alternative)) {
	            // c ? x : false ---> !!c && x
	            return make_node(AST_Binary, self, {
	                operator: "&&",
	                left: booleanize(self.condition),
	                right: self.consequent
	            });
	        }
	
	        return self;
	
	        function booleanize(node) {
	            if (node.is_boolean()) return node;
	            // !!expression
	            return make_node(AST_UnaryPrefix, node, {
	                operator: "!",
	                expression: node.negate(compressor)
	            });
	        }
	
	        // AST_True or !0
	        function is_true(node) {
	            return node instanceof AST_True
	                || (node instanceof AST_UnaryPrefix
	                    && node.operator == "!"
	                    && node.expression instanceof AST_Constant
	                    && !node.expression.value);
	        }
	        // AST_False or !1
	        function is_false(node) {
	            return node instanceof AST_False
	                || (node instanceof AST_UnaryPrefix
	                    && node.operator == "!"
	                    && node.expression instanceof AST_Constant
	                    && !!node.expression.value);
	        }
	    });
	
	    OPT(AST_Boolean, function(self, compressor){
	        if (compressor.option("booleans")) {
	            var p = compressor.parent();
	            if (p instanceof AST_Binary && (p.operator == "=="
	                                            || p.operator == "!=")) {
	                compressor.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
	                    operator : p.operator,
	                    value    : self.value,
	                    file     : p.start.file,
	                    line     : p.start.line,
	                    col      : p.start.col,
	                });
	                return make_node(AST_Number, self, {
	                    value: +self.value
	                });
	            }
	            return make_node(AST_UnaryPrefix, self, {
	                operator: "!",
	                expression: make_node(AST_Number, self, {
	                    value: 1 - self.value
	                })
	            });
	        }
	        return self;
	    });
	
	    OPT(AST_Sub, function(self, compressor){
	        var prop = self.property;
	        if (prop instanceof AST_String && compressor.option("properties")) {
	            prop = prop.getValue();
	            if (RESERVED_WORDS(prop) ? compressor.option("screw_ie8") : is_identifier_string(prop)) {
	                return make_node(AST_Dot, self, {
	                    expression : self.expression,
	                    property   : prop
	                }).optimize(compressor);
	            }
	            var v = parseFloat(prop);
	            if (!isNaN(v) && v.toString() == prop) {
	                self.property = make_node(AST_Number, self.property, {
	                    value: v
	                });
	            }
	        }
	        var ev = self.evaluate(compressor);
	        if (ev !== self) {
	            ev = make_node_from_constant(ev, self).optimize(compressor);
	            return best_of(compressor, ev, self);
	        }
	        return self;
	    });
	
	    OPT(AST_Dot, function(self, compressor){
	        var def = self.resolve_defines(compressor);
	        if (def) {
	            return def.optimize(compressor);
	        }
	        var prop = self.property;
	        if (RESERVED_WORDS(prop) && !compressor.option("screw_ie8")) {
	            return make_node(AST_Sub, self, {
	                expression : self.expression,
	                property   : make_node(AST_String, self, {
	                    value: prop
	                })
	            }).optimize(compressor);
	        }
	        if (compressor.option("unsafe_proto")
	            && self.expression instanceof AST_Dot
	            && self.expression.property == "prototype") {
	            var exp = self.expression.expression;
	            if (exp instanceof AST_SymbolRef && exp.undeclared()) switch (exp.name) {
	              case "Array":
	                self.expression = make_node(AST_Array, self.expression, {
	                    elements: []
	                });
	                break;
	              case "Object":
	                self.expression = make_node(AST_Object, self.expression, {
	                    properties: []
	                });
	                break;
	              case "String":
	                self.expression = make_node(AST_String, self.expression, {
	                    value: ""
	                });
	                break;
	            }
	        }
	        var ev = self.evaluate(compressor);
	        if (ev !== self) {
	            ev = make_node_from_constant(ev, self).optimize(compressor);
	            return best_of(compressor, ev, self);
	        }
	        return self;
	    });
	
	    function literals_in_boolean_context(self, compressor) {
	        if (compressor.option("booleans") && compressor.in_boolean_context()) {
	            return best_of(compressor, self, make_node(AST_Seq, self, {
	                car: self,
	                cdr: make_node(AST_True, self)
	            }).optimize(compressor));
	        }
	        return self;
	    };
	    OPT(AST_Array, literals_in_boolean_context);
	    OPT(AST_Object, literals_in_boolean_context);
	    OPT(AST_RegExp, literals_in_boolean_context);
	
	    OPT(AST_Return, function(self, compressor){
	        if (self.value && is_undefined(self.value, compressor)) {
	            self.value = null;
	        }
	        return self;
	    });
	
	    OPT(AST_VarDef, function(self, compressor){
	        var defines = compressor.option("global_defs");
	        if (defines && HOP(defines, self.name.name)) {
	            compressor.warn('global_defs ' + self.name.name + ' redefined [{file}:{line},{col}]', self.start);
	        }
	        return self;
	    });
	
	})();
	
	
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	// a small wrapper around fitzgen's source-map library
	function SourceMap(options) {
	    options = defaults(options, {
	        file : null,
	        root : null,
	        orig : null,
	
	        orig_line_diff : 0,
	        dest_line_diff : 0,
	    });
	    var generator = new MOZ_SourceMap.SourceMapGenerator({
	        file       : options.file,
	        sourceRoot : options.root
	    });
	    var orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);
	
	    if (orig_map && Array.isArray(options.orig.sources)) {
	        orig_map._sources.toArray().forEach(function(source) {
	            var sourceContent = orig_map.sourceContentFor(source, true);
	            if (sourceContent) {
	                generator.setSourceContent(source, sourceContent);
	            }
	        });
	    }
	
	    function add(source, gen_line, gen_col, orig_line, orig_col, name) {
	        if (orig_map) {
	            var info = orig_map.originalPositionFor({
	                line: orig_line,
	                column: orig_col
	            });
	            if (info.source === null) {
	                return;
	            }
	            source = info.source;
	            orig_line = info.line;
	            orig_col = info.column;
	            name = info.name || name;
	        }
	        generator.addMapping({
	            generated : { line: gen_line + options.dest_line_diff, column: gen_col },
	            original  : { line: orig_line + options.orig_line_diff, column: orig_col },
	            source    : source,
	            name      : name
	        });
	    };
	    return {
	        add        : add,
	        get        : function() { return generator },
	        toString   : function() { return JSON.stringify(generator.toJSON()); }
	    };
	};
	
	
	/***********************************************************************
	
	  A JavaScript tokenizer / parser / beautifier / compressor.
	  https://github.com/mishoo/UglifyJS2
	
	  -------------------------------- (C) ---------------------------------
	
	                           Author: Mihai Bazon
	                         <mihai.bazon@gmail.com>
	                       http://mihai.bazon.net/blog
	
	  Distributed under the BSD license:
	
	    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>
	
	    Redistribution and use in source and binary forms, with or without
	    modification, are permitted provided that the following conditions
	    are met:
	
	        * Redistributions of source code must retain the above
	          copyright notice, this list of conditions and the following
	          disclaimer.
	
	        * Redistributions in binary form must reproduce the above
	          copyright notice, this list of conditions and the following
	          disclaimer in the documentation and/or other materials
	          provided with the distribution.
	
	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
	    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
	    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
	    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
	    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	    SUCH DAMAGE.
	
	 ***********************************************************************/
	
	"use strict";
	
	(function(){
	
	    var normalize_directives = function(body) {
	        var in_directive = true;
	
	        for (var i = 0; i < body.length; i++) {
	            if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {
	                body[i] = new AST_Directive({
	                    start: body[i].start,
	                    end: body[i].end,
	                    value: body[i].body.value
	                });
	            } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {
	                in_directive = false;
	            }
	        }
	
	        return body;
	    };
	
	    var MOZ_TO_ME = {
	        Program: function(M) {
	            return new AST_Toplevel({
	                start: my_start_token(M),
	                end: my_end_token(M),
	                body: normalize_directives(M.body.map(from_moz))
	            });
	        },
	        FunctionDeclaration: function(M) {
	            return new AST_Defun({
	                start: my_start_token(M),
	                end: my_end_token(M),
	                name: from_moz(M.id),
	                argnames: M.params.map(from_moz),
	                body: normalize_directives(from_moz(M.body).body)
	            });
	        },
	        FunctionExpression: function(M) {
	            return new AST_Function({
	                start: my_start_token(M),
	                end: my_end_token(M),
	                name: from_moz(M.id),
	                argnames: M.params.map(from_moz),
	                body: normalize_directives(from_moz(M.body).body)
	            });
	        },
	        ExpressionStatement: function(M) {
	            return new AST_SimpleStatement({
	                start: my_start_token(M),
	                end: my_end_token(M),
	                body: from_moz(M.expression)
	            });
	        },
	        TryStatement: function(M) {
	            var handlers = M.handlers || [M.handler];
	            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {
	                throw new Error("Multiple catch clauses are not supported.");
	            }
	            return new AST_Try({
	                start    : my_start_token(M),
	                end      : my_end_token(M),
	                body     : from_moz(M.block).body,
	                bcatch   : from_moz(handlers[0]),
	                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
	            });
	        },
	        Property: function(M) {
	            var key = M.key;
	            var args = {
	                start    : my_start_token(key),
	                end      : my_end_token(M.value),
	                key      : key.type == "Identifier" ? key.name : key.value,
	                value    : from_moz(M.value)
	            };
	            if (M.kind == "init") return new AST_ObjectKeyVal(args);
	            args.key = new AST_SymbolAccessor({
	                name: args.key
	            });
	            args.value = new AST_Accessor(args.value);
	            if (M.kind == "get") return new AST_ObjectGetter(args);
	            if (M.kind == "set") return new AST_ObjectSetter(args);
	        },
	        ArrayExpression: function(M) {
	            return new AST_Array({
	                start    : my_start_token(M),
	                end      : my_end_token(M),
	                elements : M.elements.map(function(elem){
	                    return elem === null ? new AST_Hole() : from_moz(elem);
	                })
	            });
	        },
	        ObjectExpression: function(M) {
	            return new AST_Object({
	                start      : my_start_token(M),
	                end        : my_end_token(M),
	                properties : M.properties.map(function(prop){
	                    prop.type = "Property";
	                    return from_moz(prop)
	                })
	            });
	        },
	        SequenceExpression: function(M) {
	            return AST_Seq.from_array(M.expressions.map(from_moz));
	        },
	        MemberExpression: function(M) {
	            return new (M.computed ? AST_Sub : AST_Dot)({
	                start      : my_start_token(M),
	                end        : my_end_token(M),
	                property   : M.computed ? from_moz(M.property) : M.property.name,
	                expression : from_moz(M.object)
	            });
	        },
	        SwitchCase: function(M) {
	            return new (M.test ? AST_Case : AST_Default)({
	                start      : my_start_token(M),
	                end        : my_end_token(M),
	                expression : from_moz(M.test),
	                body       : M.consequent.map(from_moz)
	            });
	        },
	        VariableDeclaration: function(M) {
	            return new (M.kind === "const" ? AST_Const : AST_Var)({
	                start       : my_start_token(M),
	                end         : my_end_token(M),
	                definitions : M.declarations.map(from_moz)
	            });
	        },
	        Literal: function(M) {
	            var val = M.value, args = {
	                start  : my_start_token(M),
	                end    : my_end_token(M)
	            };
	            if (val === null) return new AST_Null(args);
	            switch (typeof val) {
	              case "string":
	                args.value = val;
	                return new AST_String(args);
	              case "number":
	                args.value = val;
	                return new AST_Number(args);
	              case "boolean":
	                return new (val ? AST_True : AST_False)(args);
	              default:
	                var rx = M.regex;
	                if (rx && rx.pattern) {
	                    // RegExpLiteral as per ESTree AST spec
	                    args.value = new RegExp(rx.pattern, rx.flags).toString();
	                } else {
	                    // support legacy RegExp
	                    args.value = M.regex && M.raw ? M.raw : val;
	                }
	                return new AST_RegExp(args);
	            }
	        },
	        Identifier: function(M) {
	            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];
	            return new (  p.type == "LabeledStatement" ? AST_Label
	                        : p.type == "VariableDeclarator" && p.id === M ? (p.kind == "const" ? AST_SymbolConst : AST_SymbolVar)
	                        : p.type == "FunctionExpression" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)
	                        : p.type == "FunctionDeclaration" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)
	                        : p.type == "CatchClause" ? AST_SymbolCatch
	                        : p.type == "BreakStatement" || p.type == "ContinueStatement" ? AST_LabelRef
	                        : AST_SymbolRef)({
	                            start : my_start_token(M),
	                            end   : my_end_token(M),
	                            name  : M.name
	                        });
	        }
	    };
	
	    MOZ_TO_ME.UpdateExpression =
	    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {
	        var prefix = "prefix" in M ? M.prefix
	            : M.type == "UnaryExpression" ? true : false;
	        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
	            start      : my_start_token(M),
	            end        : my_end_token(M),
	            operator   : M.operator,
	            expression : from_moz(M.argument)
	        });
	    };
	
	    map("EmptyStatement", AST_EmptyStatement);
	    map("BlockStatement", AST_BlockStatement, "body@body");
	    map("IfStatement", AST_If, "test>condition, consequent>body, alternate>alternative");
	    map("LabeledStatement", AST_LabeledStatement, "label>label, body>body");
	    map("BreakStatement", AST_Break, "label>label");
	    map("ContinueStatement", AST_Continue, "label>label");
	    map("WithStatement", AST_With, "object>expression, body>body");
	    map("SwitchStatement", AST_Switch, "discriminant>expression, cases@body");
	    map("ReturnStatement", AST_Return, "argument>value");
	    map("ThrowStatement", AST_Throw, "argument>value");
	    map("WhileStatement", AST_While, "test>condition, body>body");
	    map("DoWhileStatement", AST_Do, "test>condition, body>body");
	    map("ForStatement", AST_For, "init>init, test>condition, update>step, body>body");
	    map("ForInStatement", AST_ForIn, "left>init, right>object, body>body");
	    map("DebuggerStatement", AST_Debugger);
	    map("VariableDeclarator", AST_VarDef, "id>name, init>value");
	    map("CatchClause", AST_Catch, "param>argname, body%body");
	
	    map("ThisExpression", AST_This);
	    map("BinaryExpression", AST_Binary, "operator=operator, left>left, right>right");
	    map("LogicalExpression", AST_Binary, "operator=operator, left>left, right>right");
	    map("AssignmentExpression", AST_Assign, "operator=operator, left>left, right>right");
	    map("ConditionalExpression", AST_Conditional, "test>condition, consequent>consequent, alternate>alternative");
	    map("NewExpression", AST_New, "callee>expression, arguments@args");
	    map("CallExpression", AST_Call, "callee>expression, arguments@args");
	
	    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {
	        return to_moz_scope("Program", M);
	    });
	
	    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {
	        return {
	            type: "FunctionDeclaration",
	            id: to_moz(M.name),
	            params: M.argnames.map(to_moz),
	            body: to_moz_scope("BlockStatement", M)
	        }
	    });
	
	    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M) {
	        return {
	            type: "FunctionExpression",
	            id: to_moz(M.name),
	            params: M.argnames.map(to_moz),
	            body: to_moz_scope("BlockStatement", M)
	        }
	    });
	
	    def_to_moz(AST_Directive, function To_Moz_Directive(M) {
	        return {
	            type: "ExpressionStatement",
	            expression: {
	                type: "Literal",
	                value: M.value
	            }
	        };
	    });
	
	    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {
	        return {
	            type: "ExpressionStatement",
	            expression: to_moz(M.body)
	        };
	    });
	
	    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {
	        return {
	            type: "SwitchCase",
	            test: to_moz(M.expression),
	            consequent: M.body.map(to_moz)
	        };
	    });
	
	    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {
	        return {
	            type: "TryStatement",
	            block: to_moz_block(M),
	            handler: to_moz(M.bcatch),
	            guardedHandlers: [],
	            finalizer: to_moz(M.bfinally)
	        };
	    });
	
	    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {
	        return {
	            type: "CatchClause",
	            param: to_moz(M.argname),
	            guard: null,
	            body: to_moz_block(M)
	        };
	    });
	
	    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {
	        return {
	            type: "VariableDeclaration",
	            kind: M instanceof AST_Const ? "const" : "var",
	            declarations: M.definitions.map(to_moz)
	        };
	    });
	
	    def_to_moz(AST_Seq, function To_Moz_SequenceExpression(M) {
	        return {
	            type: "SequenceExpression",
	            expressions: M.to_array().map(to_moz)
	        };
	    });
	
	    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {
	        var isComputed = M instanceof AST_Sub;
	        return {
	            type: "MemberExpression",
	            object: to_moz(M.expression),
	            computed: isComputed,
	            property: isComputed ? to_moz(M.property) : {type: "Identifier", name: M.property}
	        };
	    });
	
	    def_to_moz(AST_Unary, function To_Moz_Unary(M) {
	        return {
	            type: M.operator == "++" || M.operator == "--" ? "UpdateExpression" : "UnaryExpression",
	            operator: M.operator,
	            prefix: M instanceof AST_UnaryPrefix,
	            argument: to_moz(M.expression)
	        };
	    });
	
	    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {
	        return {
	            type: M.operator == "&&" || M.operator == "||" ? "LogicalExpression" : "BinaryExpression",
	            left: to_moz(M.left),
	            operator: M.operator,
	            right: to_moz(M.right)
	        };
	    });
	
	    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {
	        return {
	            type: "ArrayExpression",
	            elements: M.elements.map(to_moz)
	        };
	    });
	
	    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {
	        return {
	            type: "ObjectExpression",
	            properties: M.properties.map(to_moz)
	        };
	    });
	
	    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {
	        var key = {
	            type: "Literal",
	            value: M.key instanceof AST_SymbolAccessor ? M.key.name : M.key
	        };
	        var kind;
	        if (M instanceof AST_ObjectKeyVal) {
	            kind = "init";
	        } else
	        if (M instanceof AST_ObjectGetter) {
	            kind = "get";
	        } else
	        if (M instanceof AST_ObjectSetter) {
	            kind = "set";
	        }
	        return {
	            type: "Property",
	            kind: kind,
	            key: key,
	            value: to_moz(M.value)
	        };
	    });
	
	    def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {
	        var def = M.definition();
	        return {
	            type: "Identifier",
	            name: def ? def.mangled_name || def.name : M.name
	        };
	    });
	
	    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {
	        var value = M.value;
	        return {
	            type: "Literal",
	            value: value,
	            raw: value.toString(),
	            regex: {
	                pattern: value.source,
	                flags: value.toString().match(/[gimuy]*$/)[0]
	            }
	        };
	    });
	
	    def_to_moz(AST_Constant, function To_Moz_Literal(M) {
	        var value = M.value;
	        if (typeof value === 'number' && (value < 0 || (value === 0 && 1 / value < 0))) {
	            return {
	                type: "UnaryExpression",
	                operator: "-",
	                prefix: true,
	                argument: {
	                    type: "Literal",
	                    value: -value,
	                    raw: M.start.raw
	                }
	            };
	        }
	        return {
	            type: "Literal",
	            value: value,
	            raw: M.start.raw
	        };
	    });
	
	    def_to_moz(AST_Atom, function To_Moz_Atom(M) {
	        return {
	            type: "Identifier",
	            name: String(M.value)
	        };
	    });
	
	    AST_Boolean.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
	    AST_Null.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
	    AST_Hole.DEFMETHOD("to_mozilla_ast", function To_Moz_ArrayHole() { return null });
	
	    AST_Block.DEFMETHOD("to_mozilla_ast", AST_BlockStatement.prototype.to_mozilla_ast);
	    AST_Lambda.DEFMETHOD("to_mozilla_ast", AST_Function.prototype.to_mozilla_ast);
	
	    /* -----[ tools ]----- */
	
	    function raw_token(moznode) {
	        if (moznode.type == "Literal") {
	            return moznode.raw != null ? moznode.raw : moznode.value + "";
	        }
	    }
	
	    function my_start_token(moznode) {
	        var loc = moznode.loc, start = loc && loc.start;
	        var range = moznode.range;
	        return new AST_Token({
	            file    : loc && loc.source,
	            line    : start && start.line,
	            col     : start && start.column,
	            pos     : range ? range[0] : moznode.start,
	            endline : start && start.line,
	            endcol  : start && start.column,
	            endpos  : range ? range[0] : moznode.start,
	            raw     : raw_token(moznode),
	        });
	    };
	
	    function my_end_token(moznode) {
	        var loc = moznode.loc, end = loc && loc.end;
	        var range = moznode.range;
	        return new AST_Token({
	            file    : loc && loc.source,
	            line    : end && end.line,
	            col     : end && end.column,
	            pos     : range ? range[1] : moznode.end,
	            endline : end && end.line,
	            endcol  : end && end.column,
	            endpos  : range ? range[1] : moznode.end,
	            raw     : raw_token(moznode),
	        });
	    };
	
	    function map(moztype, mytype, propmap) {
	        var moz_to_me = "function From_Moz_" + moztype + "(M){\n";
	        moz_to_me += "return new U2." + mytype.name + "({\n" +
	            "start: my_start_token(M),\n" +
	            "end: my_end_token(M)";
	
	        var me_to_moz = "function To_Moz_" + moztype + "(M){\n";
	        me_to_moz += "return {\n" +
	            "type: " + JSON.stringify(moztype);
	
	        if (propmap) propmap.split(/\s*,\s*/).forEach(function(prop){
	            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);
	            if (!m) throw new Error("Can't understand property map: " + prop);
	            var moz = m[1], how = m[2], my = m[3];
	            moz_to_me += ",\n" + my + ": ";
	            me_to_moz += ",\n" + moz + ": ";
	            switch (how) {
	                case "@":
	                    moz_to_me += "M." + moz + ".map(from_moz)";
	                    me_to_moz += "M." +  my + ".map(to_moz)";
	                    break;
	                case ">":
	                    moz_to_me += "from_moz(M." + moz + ")";
	                    me_to_moz += "to_moz(M." + my + ")";
	                    break;
	                case "=":
	                    moz_to_me += "M." + moz;
	                    me_to_moz += "M." + my;
	                    break;
	                case "%":
	                    moz_to_me += "from_moz(M." + moz + ").body";
	                    me_to_moz += "to_moz_block(M)";
	                    break;
	                default:
	                    throw new Error("Can't understand operator in propmap: " + prop);
	            }
	        });
	
	        moz_to_me += "\n})\n}";
	        me_to_moz += "\n}\n}";
	
	        //moz_to_me = parse(moz_to_me).print_to_string({ beautify: true });
	        //me_to_moz = parse(me_to_moz).print_to_string({ beautify: true });
	        //console.log(moz_to_me);
	
	        moz_to_me = new Function("U2", "my_start_token", "my_end_token", "from_moz", "return(" + moz_to_me + ")")(
	            exports, my_start_token, my_end_token, from_moz
	        );
	        me_to_moz = new Function("to_moz", "to_moz_block", "to_moz_scope", "return(" + me_to_moz + ")")(
	            to_moz, to_moz_block, to_moz_scope
	        );
	        MOZ_TO_ME[moztype] = moz_to_me;
	        def_to_moz(mytype, me_to_moz);
	    };
	
	    var FROM_MOZ_STACK = null;
	
	    function from_moz(node) {
	        FROM_MOZ_STACK.push(node);
	        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;
	        FROM_MOZ_STACK.pop();
	        return ret;
	    };
	
	    AST_Node.from_mozilla_ast = function(node){
	        var save_stack = FROM_MOZ_STACK;
	        FROM_MOZ_STACK = [];
	        var ast = from_moz(node);
	        FROM_MOZ_STACK = save_stack;
	        return ast;
	    };
	
	    function set_moz_loc(mynode, moznode, myparent) {
	        var start = mynode.start;
	        var end = mynode.end;
	        if (start.pos != null && end.endpos != null) {
	            moznode.range = [start.pos, end.endpos];
	        }
	        if (start.line) {
	            moznode.loc = {
	                start: {line: start.line, column: start.col},
	                end: end.endline ? {line: end.endline, column: end.endcol} : null
	            };
	            if (start.file) {
	                moznode.loc.source = start.file;
	            }
	        }
	        return moznode;
	    };
	
	    function def_to_moz(mytype, handler) {
	        mytype.DEFMETHOD("to_mozilla_ast", function() {
	            return set_moz_loc(this, handler(this));
	        });
	    };
	
	    function to_moz(node) {
	        return node != null ? node.to_mozilla_ast() : null;
	    };
	
	    function to_moz_block(node) {
	        return {
	            type: "BlockStatement",
	            body: node.body.map(to_moz)
	        };
	    };
	
	    function to_moz_scope(type, node) {
	        var body = node.body.map(to_moz);
	        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {
	            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));
	        }
	        return {
	            type: type,
	            body: body
	        };
	    };
	})();
	
	module.exports = {
	defaults:defaults,parse:parse,Compressor:Compressor,SourceMap:SourceMap,merge:merge,OutputStream:OutputStream
	};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./babel/example.map": 31,
		"./coffee/example.map": 32,
		"./sass/example.map": 33,
		"./simple-coffee/example.map": 34,
		"./typescript/example.map": 35
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 19;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./babel/example": 5,
		"./coffee/example": 6,
		"./sass/example": 7,
		"./simple-coffee/example": 8,
		"./typescript/example": 9
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 20;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./babel/example.js": 36,
		"./coffee/example.js": 37,
		"./sass/example.js": 38,
		"./simple-coffee/example.js": 39,
		"./typescript/example.js": 40
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 21;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-thumb{background-color:hsla(0,0%,56%,.6);border-radius:50px}.scrollbar-style:hover::-webkit-scrollbar-thumb{background-color:rgba(64,64,64,.6)}.flex-container{display:flex;overflow:hidden}.flex-container>*{flex:0 0 auto;overflow:scroll}.flex-container>::-webkit-scrollbar{width:8px}.flex-container>::-webkit-scrollbar-thumb{background-color:hsla(0,0%,56%,.6);border-radius:50px}.flex-container>:hover::-webkit-scrollbar-thumb{background-color:rgba(64,64,64,.6)}.stretchy{flex:1 1 auto}.column{flex-direction:column}.full-screen,body,html{height:100%}body{margin:0}.full-screen{display:flex;overflow:hidden;flex-direction:column}.full-screen>*{flex:0 0 auto;overflow:scroll}.full-screen>::-webkit-scrollbar{width:8px}.full-screen>::-webkit-scrollbar-thumb{background-color:hsla(0,0%,56%,.6);border-radius:50px}.full-screen>:hover::-webkit-scrollbar-thumb{background-color:rgba(64,64,64,.6)}.full-screen>main{flex:1 1 auto;display:flex;overflow:hidden}.full-screen>main>*{flex:0 0 auto;overflow:scroll}.full-screen>main>::-webkit-scrollbar{width:8px}.full-screen>main>::-webkit-scrollbar-thumb{background-color:hsla(0,0%,56%,.6);border-radius:50px}.full-screen>main>:hover::-webkit-scrollbar-thumb{background-color:rgba(64,64,64,.6)}.full-screen>main>.codeblock{flex:1 1 auto;width:50%}.full-screen>main>:first-child{margin-right:5px}header{padding:10px}footer{height:200px}header .btn-info{float:right}span.original-item{margin:1px;min-width:3px}span.generated-item{margin:1px}span.selected{background:#000;color:#fff}.style-0{background:#e9cfed}.style-1{background:#c4ebfd}.style-2{background:#d9edd9}.style-3{background:#e9e4ba}.style-4{background:#dfcac3}pre{border-radius:0}pre code{white-space:pre-wrap;word-break:normal;word-wrap:normal}footer h3,main h3{font-size:16px;line-height:1;margin:0;padding:2px 6px;color:#fff;font-weight:400;background:hsla(0,0%,9%,.22);border:1px solid hsla(0,0%,50%,.5);border-left:0;border-right:0;position:sticky;top:0}header small{position:absolute;top:10px;right:10px}table{width:100%}td,tr{margin:0;width:33%}", ""]);
	
	// exports


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, "/*!\n * Bootstrap v2.3.0\n *\n * Copyright 2012 Twitter, Inc\n * Licensed under the Apache License v2.0\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Designed and built with all the love in the world @twitter by @mdo and @fat.\n */.clearfix{*zoom:1}.clearfix:after,.clearfix:before{display:table;content:\"\";line-height:0}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:30px;box-sizing:border-box}article,aside,details,figcaption,figure,footer,header,hgroup,nav,section{display:block}audio,canvas,video{display:inline-block;*display:inline;*zoom:1}audio:not([controls]){display:none}html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}a:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}a:active,a:hover{outline:0}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{max-width:100%;width:auto\\9;height:auto;vertical-align:middle;border:0;-ms-interpolation-mode:bicubic}#map_canvas img,.google-maps img{max-width:none}button,input,select,textarea{margin:0;font-size:100%;vertical-align:middle}button,input{*overflow:visible;line-height:normal}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button,input[type=button],input[type=checkbox],input[type=radio],input[type=reset],input[type=submit],label,select{cursor:pointer}input[type=search]{box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}textarea{overflow:auto;vertical-align:top}@media print{*{text-shadow:none!important;color:#000!important;background:transparent!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}abbr[title]:after{content:\" (\" attr(title) \")\"}.ir a:after,a[href^=\"#\"]:after,a[href^=\"javascript:\"]:after{content:\"\"}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}body{margin:0;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:14px;line-height:20px;color:#333;background-color:#fff}a{color:#08c;text-decoration:none}a:focus,a:hover{color:#005580;text-decoration:underline}.img-rounded{border-radius:6px}.img-polaroid{padding:4px;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);box-shadow:0 1px 3px rgba(0,0,0,.1)}.img-circle{border-radius:500px}.row{margin-left:-20px;*zoom:1}.row:after,.row:before{display:table;content:\"\";line-height:0}.row:after{clear:both}[class*=span]{float:left;min-height:1px;margin-left:20px}.container,.navbar-fixed-bottom .container,.navbar-fixed-top .container,.navbar-static-top .container,.span12{width:940px}.span11{width:860px}.span10{width:780px}.span9{width:700px}.span8{width:620px}.span7{width:540px}.span6{width:460px}.span5{width:380px}.span4{width:300px}.span3{width:220px}.span2{width:140px}.span1{width:60px}.offset12{margin-left:980px}.offset11{margin-left:900px}.offset10{margin-left:820px}.offset9{margin-left:740px}.offset8{margin-left:660px}.offset7{margin-left:580px}.offset6{margin-left:500px}.offset5{margin-left:420px}.offset4{margin-left:340px}.offset3{margin-left:260px}.offset2{margin-left:180px}.offset1{margin-left:100px}.row-fluid{width:100%;*zoom:1}.row-fluid:after,.row-fluid:before{display:table;content:\"\";line-height:0}.row-fluid:after{clear:both}.row-fluid [class*=span]{display:block;width:100%;min-height:30px;box-sizing:border-box;float:left;margin-left:2.127659574468085%;*margin-left:2.074468085106383%}.row-fluid [class*=span]:first-child{margin-left:0}.row-fluid .controls-row [class*=span]+[class*=span]{margin-left:2.127659574468085%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.48936170212765%;*width:91.43617021276594%}.row-fluid .span10{width:82.97872340425532%;*width:82.92553191489361%}.row-fluid .span9{width:74.46808510638297%;*width:74.41489361702126%}.row-fluid .span8{width:65.95744680851064%;*width:65.90425531914893%}.row-fluid .span7{width:57.44680851063829%;*width:57.39361702127659%}.row-fluid .span6{width:48.93617021276595%;*width:48.88297872340425%}.row-fluid .span5{width:40.42553191489362%;*width:40.37234042553192%}.row-fluid .span4{width:31.914893617021278%;*width:31.861702127659576%}.row-fluid .span3{width:23.404255319148934%;*width:23.351063829787233%}.row-fluid .span2{width:14.893617021276595%;*width:14.840425531914894%}.row-fluid .span1{width:6.382978723404255%;*width:6.329787234042553%}.row-fluid .offset12{margin-left:104.25531914893617%;*margin-left:104.14893617021275%}.row-fluid .offset12:first-child{margin-left:102.12765957446808%;*margin-left:102.02127659574467%}.row-fluid .offset11{margin-left:95.74468085106382%;*margin-left:95.6382978723404%}.row-fluid .offset11:first-child{margin-left:93.61702127659574%;*margin-left:93.51063829787232%}.row-fluid .offset10{margin-left:87.23404255319149%;*margin-left:87.12765957446807%}.row-fluid .offset10:first-child{margin-left:85.1063829787234%;*margin-left:84.99999999999999%}.row-fluid .offset9{margin-left:78.72340425531914%;*margin-left:78.61702127659572%}.row-fluid .offset9:first-child{margin-left:76.59574468085106%;*margin-left:76.48936170212764%}.row-fluid .offset8{margin-left:70.2127659574468%;*margin-left:70.10638297872339%}.row-fluid .offset8:first-child{margin-left:68.08510638297872%;*margin-left:67.9787234042553%}.row-fluid .offset7{margin-left:61.70212765957446%;*margin-left:61.59574468085106%}.row-fluid .offset7:first-child{margin-left:59.574468085106375%;*margin-left:59.46808510638297%}.row-fluid .offset6{margin-left:53.191489361702125%;*margin-left:53.085106382978715%}.row-fluid .offset6:first-child{margin-left:51.063829787234035%;*margin-left:50.95744680851063%}.row-fluid .offset5{margin-left:44.68085106382979%;*margin-left:44.57446808510638%}.row-fluid .offset5:first-child{margin-left:42.5531914893617%;*margin-left:42.4468085106383%}.row-fluid .offset4{margin-left:36.170212765957444%;*margin-left:36.06382978723405%}.row-fluid .offset4:first-child{margin-left:34.04255319148936%;*margin-left:33.93617021276596%}.row-fluid .offset3{margin-left:27.659574468085104%;*margin-left:27.5531914893617%}.row-fluid .offset3:first-child{margin-left:25.53191489361702%;*margin-left:25.425531914893618%}.row-fluid .offset2{margin-left:19.148936170212764%;*margin-left:19.04255319148936%}.row-fluid .offset2:first-child{margin-left:17.02127659574468%;*margin-left:16.914893617021278%}.row-fluid .offset1{margin-left:10.638297872340425%;*margin-left:10.53191489361702%}.row-fluid .offset1:first-child{margin-left:8.51063829787234%;*margin-left:8.404255319148938%}.row-fluid [class*=span].hide,[class*=span].hide{display:none}.row-fluid [class*=span].pull-right,[class*=span].pull-right{float:right}.container{margin-right:auto;margin-left:auto;*zoom:1}.container:after,.container:before{display:table;content:\"\";line-height:0}.container:after{clear:both}.container-fluid{padding-right:20px;padding-left:20px;*zoom:1}.container-fluid:after,.container-fluid:before{display:table;content:\"\";line-height:0}.container-fluid:after{clear:both}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:21px;font-weight:200;line-height:30px}small{font-size:85%}strong{font-weight:700}em{font-style:italic}cite{font-style:normal}.muted{color:#999}a.muted:focus,a.muted:hover{color:gray}.text-warning{color:#c09853}a.text-warning:focus,a.text-warning:hover{color:#a47e3c}.text-error{color:#b94a48}a.text-error:focus,a.text-error:hover{color:#953b39}.text-info{color:#3a87ad}a.text-info:focus,a.text-info:hover{color:#2d6987}.text-success{color:#468847}a.text-success:focus,a.text-success:hover{color:#356635}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}h1,h2,h3,h4,h5,h6{margin:10px 0;font-family:inherit;font-weight:700;line-height:20px;color:inherit;text-rendering:optimizelegibility}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:400;line-height:1;color:#999}h1,h2,h3{line-height:40px}h1{font-size:38.5px}h2{font-size:31.5px}h3{font-size:24.5px}h4{font-size:17.5px}h5{font-size:14px}h6{font-size:11.9px}h1 small{font-size:24.5px}h2 small{font-size:17.5px}h3 small,h4 small{font-size:14px}.page-header{padding-bottom:9px;margin:20px 0 30px;border-bottom:1px solid #eee}ol,ul{padding:0;margin:0 0 10px 25px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}li{line-height:20px}ol.inline,ol.unstyled,ul.inline,ul.unstyled{margin-left:0;list-style:none}ol.inline>li,ul.inline>li{display:inline-block;*display:inline;*zoom:1;padding-left:5px;padding-right:5px}dl{margin-bottom:20px}dd,dt{line-height:20px}dt{font-weight:700}dd{margin-left:10px}.dl-horizontal{*zoom:1}.dl-horizontal:after,.dl-horizontal:before{display:table;content:\"\";line-height:0}.dl-horizontal:after{clear:both}.dl-horizontal dt{float:left;width:160px;clear:left;text-align:right;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}hr{margin:20px 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #999}abbr.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:0 0 0 15px;margin:0 0 20px;border-left:5px solid #eee}blockquote p{margin-bottom:0;font-size:17.5px;font-weight:300;line-height:1.25}blockquote small{display:block;line-height:20px;color:#999}blockquote small:before{content:\"\\2014   \\A0\"}blockquote.pull-right{float:right;padding-right:15px;padding-left:0;border-right:5px solid #eee;border-left:0}blockquote.pull-right p,blockquote.pull-right small{text-align:right}blockquote.pull-right small:before{content:\"\"}blockquote.pull-right small:after{content:\"\\A0   \\2014\"}blockquote:after,blockquote:before,q:after,q:before{content:\"\"}address{display:block;margin-bottom:20px;font-style:normal;line-height:20px}code,pre{padding:0 3px 2px;font-family:Monaco,Menlo,Consolas,Courier New,monospace;font-size:12px;color:#333;border-radius:3px}code{padding:2px 4px;color:#d14;background-color:#f7f7f9;border:1px solid #e1e1e8;white-space:nowrap}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:20px;word-break:break-all;word-wrap:break-word;white-space:pre;white-space:pre-wrap;background-color:#f5f5f5;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px}pre.prettyprint{margin-bottom:20px}pre code{padding:0;color:inherit;white-space:pre;white-space:pre-wrap;background-color:transparent;border:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.badge,.label{display:inline-block;padding:2px 4px;font-size:11.844px;font-weight:700;line-height:14px;color:#fff;vertical-align:baseline;white-space:nowrap;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#999}.label{border-radius:3px}.badge{padding-left:9px;padding-right:9px;border-radius:9px}.badge:empty,.label:empty{display:none}a.badge:focus,a.badge:hover,a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.badge-important,.label-important{background-color:#b94a48}.badge-important[href],.label-important[href]{background-color:#953b39}.badge-warning,.label-warning{background-color:#f89406}.badge-warning[href],.label-warning[href]{background-color:#c67605}.badge-success,.label-success{background-color:#468847}.badge-success[href],.label-success[href]{background-color:#356635}.badge-info,.label-info{background-color:#3a87ad}.badge-info[href],.label-info[href]{background-color:#2d6987}.badge-inverse,.label-inverse{background-color:#333}.badge-inverse[href],.label-inverse[href]{background-color:#1a1a1a}.btn .badge,.btn .label{position:relative;top:-1px}.btn-mini .badge,.btn-mini .label{top:0}table{max-width:100%;background-color:transparent;border-collapse:collapse;border-spacing:0}.table{width:100%;margin-bottom:20px}.table td,.table th{padding:8px;line-height:20px;text-align:left;vertical-align:top;border-top:1px solid #ddd}.table th{font-weight:700}.table thead th{vertical-align:bottom}.table caption+thead tr:first-child td,.table caption+thead tr:first-child th,.table colgroup+thead tr:first-child td,.table colgroup+thead tr:first-child th,.table thead:first-child tr:first-child td,.table thead:first-child tr:first-child th{border-top:0}.table tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed td,.table-condensed th{padding:4px 5px}.table-bordered{border:1px solid #ddd;border-collapse:separate;*border-collapse:collapse;border-left:0;border-radius:4px}.table-bordered td,.table-bordered th{border-left:1px solid #ddd}.table-bordered caption+tbody tr:first-child td,.table-bordered caption+tbody tr:first-child th,.table-bordered caption+thead tr:first-child th,.table-bordered colgroup+tbody tr:first-child td,.table-bordered colgroup+tbody tr:first-child th,.table-bordered colgroup+thead tr:first-child th,.table-bordered tbody:first-child tr:first-child td,.table-bordered tbody:first-child tr:first-child th,.table-bordered thead:first-child tr:first-child th{border-top:0}.table-bordered tbody:first-child tr:first-child>td:first-child,.table-bordered tbody:first-child tr:first-child>th:first-child,.table-bordered thead:first-child tr:first-child>th:first-child{border-top-left-radius:4px}.table-bordered tbody:first-child tr:first-child>td:last-child,.table-bordered tbody:first-child tr:first-child>th:last-child,.table-bordered thead:first-child tr:first-child>th:last-child{border-top-right-radius:4px}.table-bordered tbody:last-child tr:last-child>td:first-child,.table-bordered tbody:last-child tr:last-child>th:first-child,.table-bordered tfoot:last-child tr:last-child>td:first-child,.table-bordered tfoot:last-child tr:last-child>th:first-child,.table-bordered thead:last-child tr:last-child>th:first-child{border-bottom-left-radius:4px}.table-bordered tbody:last-child tr:last-child>td:last-child,.table-bordered tbody:last-child tr:last-child>th:last-child,.table-bordered tfoot:last-child tr:last-child>td:last-child,.table-bordered tfoot:last-child tr:last-child>th:last-child,.table-bordered thead:last-child tr:last-child>th:last-child{border-bottom-right-radius:4px}.table-bordered tfoot+tbody:last-child tr:last-child td:first-child{border-bottom-left-radius:0}.table-bordered tfoot+tbody:last-child tr:last-child td:last-child{border-bottom-right-radius:0}.table-bordered caption+tbody tr:first-child td:first-child,.table-bordered caption+thead tr:first-child th:first-child,.table-bordered colgroup+tbody tr:first-child td:first-child,.table-bordered colgroup+thead tr:first-child th:first-child{border-top-left-radius:4px}.table-bordered caption+tbody tr:first-child td:last-child,.table-bordered caption+thead tr:first-child th:last-child,.table-bordered colgroup+tbody tr:first-child td:last-child,.table-bordered colgroup+thead tr:first-child th:last-child{border-top-right-radius:4px}.table-striped tbody>tr:nth-child(odd)>td,.table-striped tbody>tr:nth-child(odd)>th{background-color:#f9f9f9}.table-hover tbody tr:hover>td,.table-hover tbody tr:hover>th{background-color:#f5f5f5}.row-fluid table td[class*=span],.row-fluid table th[class*=span],table td[class*=span],table th[class*=span]{display:table-cell;float:none;margin-left:0}.table td.span1,.table th.span1{float:none;width:44px;margin-left:0}.table td.span2,.table th.span2{float:none;width:124px;margin-left:0}.table td.span3,.table th.span3{float:none;width:204px;margin-left:0}.table td.span4,.table th.span4{float:none;width:284px;margin-left:0}.table td.span5,.table th.span5{float:none;width:364px;margin-left:0}.table td.span6,.table th.span6{float:none;width:444px;margin-left:0}.table td.span7,.table th.span7{float:none;width:524px;margin-left:0}.table td.span8,.table th.span8{float:none;width:604px;margin-left:0}.table td.span9,.table th.span9{float:none;width:684px;margin-left:0}.table td.span10,.table th.span10{float:none;width:764px;margin-left:0}.table td.span11,.table th.span11{float:none;width:844px;margin-left:0}.table td.span12,.table th.span12{float:none;width:924px;margin-left:0}.table tbody tr.success>td{background-color:#dff0d8}.table tbody tr.error>td{background-color:#f2dede}.table tbody tr.warning>td{background-color:#fcf8e3}.table tbody tr.info>td{background-color:#d9edf7}.table-hover tbody tr.success:hover>td{background-color:#d0e9c6}.table-hover tbody tr.error:hover>td{background-color:#ebcccc}.table-hover tbody tr.warning:hover>td{background-color:#faf2cc}.table-hover tbody tr.info:hover>td{background-color:#c4e3f3}form{margin:0 0 20px}fieldset{margin:0}fieldset,legend{padding:0;border:0}legend{display:block;width:100%;margin-bottom:20px;font-size:21px;line-height:40px;color:#333;border-bottom:1px solid #e5e5e5}legend small{font-size:15px;color:#999}button,input,label,select,textarea{font-size:14px;font-weight:400;line-height:20px}button,input,select,textarea{font-family:Helvetica Neue,Helvetica,Arial,sans-serif}label{display:block;margin-bottom:5px}.uneditable-input,input[type=color],input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=month],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=time],input[type=url],input[type=week],select,textarea{display:inline-block;height:20px;padding:4px 6px;margin-bottom:10px;font-size:14px;line-height:20px;color:#555;border-radius:4px;vertical-align:middle}.uneditable-input,input,textarea{width:206px}textarea{height:auto}.uneditable-input,input[type=color],input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=month],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=time],input[type=url],input[type=week],textarea{background-color:#fff;border:1px solid #ccc;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);transition:border .2s linear,box-shadow .2s linear}.uneditable-input:focus,input[type=color]:focus,input[type=date]:focus,input[type=datetime-local]:focus,input[type=datetime]:focus,input[type=email]:focus,input[type=month]:focus,input[type=number]:focus,input[type=password]:focus,input[type=search]:focus,input[type=tel]:focus,input[type=text]:focus,input[type=time]:focus,input[type=url]:focus,input[type=week]:focus,textarea:focus{border-color:rgba(82,168,236,.8);outline:0;outline:thin dotted\\9;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(82,168,236,.6)}input[type=checkbox],input[type=radio]{margin:4px 0 0;*margin-top:0;margin-top:1px\\9;line-height:normal}input[type=button],input[type=checkbox],input[type=file],input[type=image],input[type=radio],input[type=reset],input[type=submit]{width:auto}input[type=file],select{height:30px;*margin-top:4px;line-height:30px}select{width:220px;border:1px solid #ccc;background-color:#fff}select[multiple],select[size]{height:auto}input[type=checkbox]:focus,input[type=file]:focus,input[type=radio]:focus,select:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.uneditable-input,.uneditable-textarea{color:#999;background-color:#fcfcfc;border-color:#ccc;box-shadow:inset 0 1px 2px rgba(0,0,0,.025);cursor:not-allowed}.uneditable-input{overflow:hidden;white-space:nowrap}.uneditable-textarea{width:auto;height:auto}input:-moz-placeholder,textarea:-moz-placeholder{color:#999}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#999}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#999}.checkbox,.radio{min-height:20px;padding-left:20px}.checkbox input[type=checkbox],.radio input[type=radio]{float:left;margin-left:-20px}.controls>.checkbox:first-child,.controls>.radio:first-child{padding-top:5px}.checkbox.inline,.radio.inline{display:inline-block;padding-top:5px;margin-bottom:0;vertical-align:middle}.checkbox.inline+.checkbox.inline,.radio.inline+.radio.inline{margin-left:10px}.input-mini{width:60px}.input-small{width:90px}.input-medium{width:150px}.input-large{width:210px}.input-xlarge{width:270px}.input-xxlarge{width:530px}.row-fluid .uneditable-input[class*=span],.row-fluid input[class*=span],.row-fluid select[class*=span],.row-fluid textarea[class*=span],.uneditable-input[class*=span],input[class*=span],select[class*=span],textarea[class*=span]{float:none;margin-left:0}.input-append .uneditable-input[class*=span],.input-append input[class*=span],.input-prepend .uneditable-input[class*=span],.input-prepend input[class*=span],.row-fluid .input-append [class*=span],.row-fluid .input-prepend [class*=span],.row-fluid .uneditable-input[class*=span],.row-fluid input[class*=span],.row-fluid select[class*=span],.row-fluid textarea[class*=span]{display:inline-block}.uneditable-input,input,textarea{margin-left:0}.controls-row [class*=span]+[class*=span]{margin-left:20px}.uneditable-input.span12,input.span12,textarea.span12{width:926px}.uneditable-input.span11,input.span11,textarea.span11{width:846px}.uneditable-input.span10,input.span10,textarea.span10{width:766px}.uneditable-input.span9,input.span9,textarea.span9{width:686px}.uneditable-input.span8,input.span8,textarea.span8{width:606px}.uneditable-input.span7,input.span7,textarea.span7{width:526px}.uneditable-input.span6,input.span6,textarea.span6{width:446px}.uneditable-input.span5,input.span5,textarea.span5{width:366px}.uneditable-input.span4,input.span4,textarea.span4{width:286px}.uneditable-input.span3,input.span3,textarea.span3{width:206px}.uneditable-input.span2,input.span2,textarea.span2{width:126px}.uneditable-input.span1,input.span1,textarea.span1{width:46px}.controls-row{*zoom:1}.controls-row:after,.controls-row:before{display:table;content:\"\";line-height:0}.controls-row:after{clear:both}.controls-row [class*=span],.row-fluid .controls-row [class*=span]{float:left}.controls-row .checkbox[class*=span],.controls-row .radio[class*=span]{padding-top:5px}input[disabled],input[readonly],select[disabled],select[readonly],textarea[disabled],textarea[readonly]{cursor:not-allowed;background-color:#eee}input[type=checkbox][disabled],input[type=checkbox][readonly],input[type=radio][disabled],input[type=radio][readonly]{background-color:transparent}.control-group.warning .checkbox,.control-group.warning .control-label,.control-group.warning .help-block,.control-group.warning .help-inline,.control-group.warning .radio,.control-group.warning input,.control-group.warning select,.control-group.warning textarea{color:#c09853}.control-group.warning input,.control-group.warning select,.control-group.warning textarea{border-color:#c09853;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.control-group.warning input:focus,.control-group.warning select:focus,.control-group.warning textarea:focus{border-color:#a47e3c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #dbc59e}.control-group.warning .input-append .add-on,.control-group.warning .input-prepend .add-on{color:#c09853;background-color:#fcf8e3;border-color:#c09853}.control-group.error .checkbox,.control-group.error .control-label,.control-group.error .help-block,.control-group.error .help-inline,.control-group.error .radio,.control-group.error input,.control-group.error select,.control-group.error textarea{color:#b94a48}.control-group.error input,.control-group.error select,.control-group.error textarea{border-color:#b94a48;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.control-group.error input:focus,.control-group.error select:focus,.control-group.error textarea:focus{border-color:#953b39;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #d59392}.control-group.error .input-append .add-on,.control-group.error .input-prepend .add-on{color:#b94a48;background-color:#f2dede;border-color:#b94a48}.control-group.success .checkbox,.control-group.success .control-label,.control-group.success .help-block,.control-group.success .help-inline,.control-group.success .radio,.control-group.success input,.control-group.success select,.control-group.success textarea{color:#468847}.control-group.success input,.control-group.success select,.control-group.success textarea{border-color:#468847;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.control-group.success input:focus,.control-group.success select:focus,.control-group.success textarea:focus{border-color:#356635;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #7aba7b}.control-group.success .input-append .add-on,.control-group.success .input-prepend .add-on{color:#468847;background-color:#dff0d8;border-color:#468847}.control-group.info .checkbox,.control-group.info .control-label,.control-group.info .help-block,.control-group.info .help-inline,.control-group.info .radio,.control-group.info input,.control-group.info select,.control-group.info textarea{color:#3a87ad}.control-group.info input,.control-group.info select,.control-group.info textarea{border-color:#3a87ad;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.control-group.info input:focus,.control-group.info select:focus,.control-group.info textarea:focus{border-color:#2d6987;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #7ab5d3}.control-group.info .input-append .add-on,.control-group.info .input-prepend .add-on{color:#3a87ad;background-color:#d9edf7;border-color:#3a87ad}input:focus:invalid,select:focus:invalid,textarea:focus:invalid{color:#b94a48;border-color:#ee5f5b}input:focus:invalid:focus,select:focus:invalid:focus,textarea:focus:invalid:focus{border-color:#e9322d;box-shadow:0 0 6px #f8b9b7}.form-actions{padding:19px 20px 20px;margin-top:20px;margin-bottom:20px;background-color:#f5f5f5;border-top:1px solid #e5e5e5;*zoom:1}.form-actions:after,.form-actions:before{display:table;content:\"\";line-height:0}.form-actions:after{clear:both}.help-block,.help-inline{color:#595959}.help-block{display:block;margin-bottom:10px}.help-inline{display:inline-block;*display:inline;*zoom:1;vertical-align:middle;padding-left:5px}.input-append,.input-prepend{display:inline-block;margin-bottom:10px;vertical-align:middle;font-size:0;white-space:nowrap}.input-append .dropdown-menu,.input-append .popover,.input-append .uneditable-input,.input-append input,.input-append select,.input-prepend .dropdown-menu,.input-prepend .popover,.input-prepend .uneditable-input,.input-prepend input,.input-prepend select{font-size:14px}.input-append .uneditable-input,.input-append input,.input-append select,.input-prepend .uneditable-input,.input-prepend input,.input-prepend select{position:relative;margin-bottom:0;*margin-left:0;vertical-align:top;border-radius:0 4px 4px 0}.input-append .uneditable-input:focus,.input-append input:focus,.input-append select:focus,.input-prepend .uneditable-input:focus,.input-prepend input:focus,.input-prepend select:focus{z-index:2}.input-append .add-on,.input-prepend .add-on{display:inline-block;width:auto;height:20px;min-width:16px;padding:4px 5px;font-size:14px;font-weight:400;line-height:20px;text-align:center;text-shadow:0 1px 0 #fff;background-color:#eee;border:1px solid #ccc}.input-append .add-on,.input-append .btn,.input-append .btn-group>.dropdown-toggle,.input-prepend .add-on,.input-prepend .btn,.input-prepend .btn-group>.dropdown-toggle{vertical-align:top;border-radius:0}.input-append .active,.input-prepend .active{background-color:#a9dba9;border-color:#46a546}.input-prepend .add-on,.input-prepend .btn{margin-right:-1px}.input-append .uneditable-input,.input-append input,.input-append select,.input-prepend .add-on:first-child,.input-prepend .btn:first-child{border-radius:4px 0 0 4px}.input-append .uneditable-input+.btn-group .btn:last-child,.input-append input+.btn-group .btn:last-child,.input-append select+.btn-group .btn:last-child{border-radius:0 4px 4px 0}.input-append .add-on,.input-append .btn,.input-append .btn-group{margin-left:-1px}.input-append .add-on:last-child,.input-append .btn-group:last-child>.dropdown-toggle,.input-append .btn:last-child{border-radius:0 4px 4px 0}.input-prepend.input-append .uneditable-input,.input-prepend.input-append input,.input-prepend.input-append select{border-radius:0}.input-prepend.input-append .uneditable-input+.btn-group .btn,.input-prepend.input-append input+.btn-group .btn,.input-prepend.input-append select+.btn-group .btn{border-radius:0 4px 4px 0}.input-prepend.input-append .add-on:first-child,.input-prepend.input-append .btn:first-child{margin-right:-1px;border-radius:4px 0 0 4px}.input-prepend.input-append .add-on:last-child,.input-prepend.input-append .btn:last-child{margin-left:-1px;border-radius:0 4px 4px 0}.input-prepend.input-append .btn-group:first-child{margin-left:0}input.search-query{padding-right:14px;padding-right:4px\\9;padding-left:14px;padding-left:4px\\9;margin-bottom:0;border-radius:15px}.form-search .input-append .search-query,.form-search .input-prepend .search-query{border-radius:0}.form-search .input-append .search-query{border-radius:14px 0 0 14px}.form-search .input-append .btn,.form-search .input-prepend .search-query{border-radius:0 14px 14px 0}.form-search .input-prepend .btn{border-radius:14px 0 0 14px}.form-horizontal .help-inline,.form-horizontal .input-append,.form-horizontal .input-prepend,.form-horizontal .uneditable-input,.form-horizontal input,.form-horizontal select,.form-horizontal textarea,.form-inline .help-inline,.form-inline .input-append,.form-inline .input-prepend,.form-inline .uneditable-input,.form-inline input,.form-inline select,.form-inline textarea,.form-search .help-inline,.form-search .input-append,.form-search .input-prepend,.form-search .uneditable-input,.form-search input,.form-search select,.form-search textarea{display:inline-block;*display:inline;*zoom:1;margin-bottom:0;vertical-align:middle}.form-horizontal .hide,.form-inline .hide,.form-search .hide{display:none}.form-inline .btn-group,.form-inline label,.form-search .btn-group,.form-search label{display:inline-block}.form-inline .input-append,.form-inline .input-prepend,.form-search .input-append,.form-search .input-prepend{margin-bottom:0}.form-inline .checkbox,.form-inline .radio,.form-search .checkbox,.form-search .radio{padding-left:0;margin-bottom:0;vertical-align:middle}.form-inline .checkbox input[type=checkbox],.form-inline .radio input[type=radio],.form-search .checkbox input[type=checkbox],.form-search .radio input[type=radio]{float:left;margin-right:3px;margin-left:0}.control-group{margin-bottom:10px}legend+.control-group{margin-top:20px;-webkit-margin-top-collapse:separate}.form-horizontal .control-group{margin-bottom:20px;*zoom:1}.form-horizontal .control-group:after,.form-horizontal .control-group:before{display:table;content:\"\";line-height:0}.form-horizontal .control-group:after{clear:both}.form-horizontal .control-label{float:left;width:160px;padding-top:5px;text-align:right}.form-horizontal .controls{*display:inline-block;*padding-left:20px;margin-left:180px;*margin-left:0}.form-horizontal .controls:first-child{*padding-left:180px}.form-horizontal .help-block{margin-bottom:0}.form-horizontal .input-append+.help-block,.form-horizontal .input-prepend+.help-block,.form-horizontal .uneditable-input+.help-block,.form-horizontal input+.help-block,.form-horizontal select+.help-block,.form-horizontal textarea+.help-block{margin-top:10px}.form-horizontal .form-actions{padding-left:180px}.btn{display:inline-block;*display:inline;*zoom:1;padding:4px 12px;margin-bottom:0;font-size:14px;line-height:20px;text-align:center;vertical-align:middle;cursor:pointer;color:#333;text-shadow:0 1px 1px hsla(0,0%,100%,.75);background-color:#f5f5f5;background-image:linear-gradient(180deg,#fff,#e6e6e6);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffffffff\",endColorstr=\"#ffe6e6e6\",GradientType=0);border-color:#e6e6e6 #e6e6e6 #bfbfbf;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#e6e6e6;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false);border:1px solid #ccc;*border:0;border-bottom-color:#b3b3b3;border-radius:4px;*margin-left:.3em;box-shadow:inset 0 1px 0 hsla(0,0%,100%,.2),0 1px 2px rgba(0,0,0,.05)}.btn.active,.btn.disabled,.btn:active,.btn:focus,.btn:hover,.btn[disabled]{color:#333;background-color:#e6e6e6;*background-color:#d9d9d9}.btn.active,.btn:active{background-color:#ccc\\9}.btn:first-child{*margin-left:0}.btn:focus,.btn:hover{color:#333;text-decoration:none;background-position:0 -15px;transition:background-position .1s linear}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.active,.btn:active{background-image:none;outline:0;box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05)}.btn.disabled,.btn[disabled]{cursor:default;background-image:none;opacity:.65;filter:alpha(opacity=65);box-shadow:none}.btn-large{padding:11px 19px;font-size:17.5px;border-radius:6px}.btn-large [class*=\" icon-\"],.btn-large [class^=icon-]{margin-top:4px}.btn-small{padding:2px 10px;font-size:11.9px;border-radius:3px}.btn-small [class*=\" icon-\"],.btn-small [class^=icon-]{margin-top:0}.btn-mini [class*=\" icon-\"],.btn-mini [class^=icon-]{margin-top:-1px}.btn-mini{padding:0 6px;font-size:10.5px;border-radius:3px}.btn-block{display:block;width:100%;padding-left:0;padding-right:0;box-sizing:border-box}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.btn-danger.active,.btn-info.active,.btn-inverse.active,.btn-primary.active,.btn-success.active,.btn-warning.active{color:hsla(0,0%,100%,.75)}.btn-primary{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#006dcc;background-image:linear-gradient(180deg,#08c,#04c);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff0088cc\",endColorstr=\"#ff0044cc\",GradientType=0);border-color:#04c #04c #002a80;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#04c;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false)}.btn-primary.active,.btn-primary.disabled,.btn-primary:active,.btn-primary:focus,.btn-primary:hover,.btn-primary[disabled]{color:#fff;background-color:#04c;*background-color:#003bb3}.btn-primary.active,.btn-primary:active{background-color:#039\\9}.btn-warning{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#faa732;background-image:linear-gradient(180deg,#fbb450,#f89406);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#fffbb450\",endColorstr=\"#fff89406\",GradientType=0);border-color:#f89406 #f89406 #ad6704;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#f89406;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false)}.btn-warning.active,.btn-warning.disabled,.btn-warning:active,.btn-warning:focus,.btn-warning:hover,.btn-warning[disabled]{color:#fff;background-color:#f89406;*background-color:#df8505}.btn-warning.active,.btn-warning:active{background-color:#c67605\\9}.btn-danger{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#da4f49;background-image:linear-gradient(180deg,#ee5f5b,#bd362f);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffee5f5b\",endColorstr=\"#ffbd362f\",GradientType=0);border-color:#bd362f #bd362f #802420;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#bd362f;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false)}.btn-danger.active,.btn-danger.disabled,.btn-danger:active,.btn-danger:focus,.btn-danger:hover,.btn-danger[disabled]{color:#fff;background-color:#bd362f;*background-color:#a9302a}.btn-danger.active,.btn-danger:active{background-color:#942a25\\9}.btn-success{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#5bb75b;background-image:linear-gradient(180deg,#62c462,#51a351);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff62c462\",endColorstr=\"#ff51a351\",GradientType=0);border-color:#51a351 #51a351 #387038;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#51a351;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false)}.btn-success.active,.btn-success.disabled,.btn-success:active,.btn-success:focus,.btn-success:hover,.btn-success[disabled]{color:#fff;background-color:#51a351;*background-color:#499249}.btn-success.active,.btn-success:active{background-color:#408140\\9}.btn-info{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#49afcd;background-image:linear-gradient(180deg,#5bc0de,#2f96b4);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff5bc0de\",endColorstr=\"#ff2f96b4\",GradientType=0);border-color:#2f96b4 #2f96b4 #1f6377;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#2f96b4;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false)}.btn-info.active,.btn-info.disabled,.btn-info:active,.btn-info:focus,.btn-info:hover,.btn-info[disabled]{color:#fff;background-color:#2f96b4;*background-color:#2a85a0}.btn-info.active,.btn-info:active{background-color:#24748c\\9}.btn-inverse{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#363636;background-image:linear-gradient(180deg,#444,#222);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff444444\",endColorstr=\"#ff222222\",GradientType=0);border-color:#222 #222 #000;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#222;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false)}.btn-inverse.active,.btn-inverse.disabled,.btn-inverse:active,.btn-inverse:focus,.btn-inverse:hover,.btn-inverse[disabled]{color:#fff;background-color:#222;*background-color:#151515}.btn-inverse.active,.btn-inverse:active{background-color:#080808\\9}button.btn,input[type=submit].btn{*padding-top:3px;*padding-bottom:3px}button.btn::-moz-focus-inner,input[type=submit].btn::-moz-focus-inner{padding:0;border:0}button.btn.btn-large,input[type=submit].btn.btn-large{*padding-top:7px;*padding-bottom:7px}button.btn.btn-small,input[type=submit].btn.btn-small{*padding-top:3px;*padding-bottom:3px}button.btn.btn-mini,input[type=submit].btn.btn-mini{*padding-top:1px;*padding-bottom:1px}.btn-link,.btn-link:active,.btn-link[disabled]{background-color:transparent;background-image:none;box-shadow:none}.btn-link{border-color:transparent;cursor:pointer;color:#08c;border-radius:0}.btn-link:focus,.btn-link:hover{color:#005580;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover{color:#333;text-decoration:none}[class*=\" icon-\"],[class^=icon-]{display:inline-block;width:14px;height:14px;*margin-right:.3em;line-height:14px;vertical-align:text-top;background-image:url(" + __webpack_require__(50) + ");background-position:14px 14px;background-repeat:no-repeat;margin-top:1px}.dropdown-menu>.active>a>[class*=\" icon-\"],.dropdown-menu>.active>a>[class^=icon-],.dropdown-menu>li>a:focus>[class*=\" icon-\"],.dropdown-menu>li>a:focus>[class^=icon-],.dropdown-menu>li>a:hover>[class*=\" icon-\"],.dropdown-menu>li>a:hover>[class^=icon-],.dropdown-submenu:focus>a>[class*=\" icon-\"],.dropdown-submenu:focus>a>[class^=icon-],.dropdown-submenu:hover>a>[class*=\" icon-\"],.dropdown-submenu:hover>a>[class^=icon-],.icon-white,.nav-list>.active>a>[class*=\" icon-\"],.nav-list>.active>a>[class^=icon-],.nav-pills>.active>a>[class*=\" icon-\"],.nav-pills>.active>a>[class^=icon-],.navbar-inverse .nav>.active>a>[class*=\" icon-\"],.navbar-inverse .nav>.active>a>[class^=icon-]{background-image:url(" + __webpack_require__(49) + ")}.icon-glass{background-position:0 0}.icon-music{background-position:-24px 0}.icon-search{background-position:-48px 0}.icon-envelope{background-position:-72px 0}.icon-heart{background-position:-96px 0}.icon-star{background-position:-120px 0}.icon-star-empty{background-position:-144px 0}.icon-user{background-position:-168px 0}.icon-film{background-position:-192px 0}.icon-th-large{background-position:-216px 0}.icon-th{background-position:-240px 0}.icon-th-list{background-position:-264px 0}.icon-ok{background-position:-288px 0}.icon-remove{background-position:-312px 0}.icon-zoom-in{background-position:-336px 0}.icon-zoom-out{background-position:-360px 0}.icon-off{background-position:-384px 0}.icon-signal{background-position:-408px 0}.icon-cog{background-position:-432px 0}.icon-trash{background-position:-456px 0}.icon-home{background-position:0 -24px}.icon-file{background-position:-24px -24px}.icon-time{background-position:-48px -24px}.icon-road{background-position:-72px -24px}.icon-download-alt{background-position:-96px -24px}.icon-download{background-position:-120px -24px}.icon-upload{background-position:-144px -24px}.icon-inbox{background-position:-168px -24px}.icon-play-circle{background-position:-192px -24px}.icon-repeat{background-position:-216px -24px}.icon-refresh{background-position:-240px -24px}.icon-list-alt{background-position:-264px -24px}.icon-lock{background-position:-287px -24px}.icon-flag{background-position:-312px -24px}.icon-headphones{background-position:-336px -24px}.icon-volume-off{background-position:-360px -24px}.icon-volume-down{background-position:-384px -24px}.icon-volume-up{background-position:-408px -24px}.icon-qrcode{background-position:-432px -24px}.icon-barcode{background-position:-456px -24px}.icon-tag{background-position:0 -48px}.icon-tags{background-position:-25px -48px}.icon-book{background-position:-48px -48px}.icon-bookmark{background-position:-72px -48px}.icon-print{background-position:-96px -48px}.icon-camera{background-position:-120px -48px}.icon-font{background-position:-144px -48px}.icon-bold{background-position:-167px -48px}.icon-italic{background-position:-192px -48px}.icon-text-height{background-position:-216px -48px}.icon-text-width{background-position:-240px -48px}.icon-align-left{background-position:-264px -48px}.icon-align-center{background-position:-288px -48px}.icon-align-right{background-position:-312px -48px}.icon-align-justify{background-position:-336px -48px}.icon-list{background-position:-360px -48px}.icon-indent-left{background-position:-384px -48px}.icon-indent-right{background-position:-408px -48px}.icon-facetime-video{background-position:-432px -48px}.icon-picture{background-position:-456px -48px}.icon-pencil{background-position:0 -72px}.icon-map-marker{background-position:-24px -72px}.icon-adjust{background-position:-48px -72px}.icon-tint{background-position:-72px -72px}.icon-edit{background-position:-96px -72px}.icon-share{background-position:-120px -72px}.icon-check{background-position:-144px -72px}.icon-move{background-position:-168px -72px}.icon-step-backward{background-position:-192px -72px}.icon-fast-backward{background-position:-216px -72px}.icon-backward{background-position:-240px -72px}.icon-play{background-position:-264px -72px}.icon-pause{background-position:-288px -72px}.icon-stop{background-position:-312px -72px}.icon-forward{background-position:-336px -72px}.icon-fast-forward{background-position:-360px -72px}.icon-step-forward{background-position:-384px -72px}.icon-eject{background-position:-408px -72px}.icon-chevron-left{background-position:-432px -72px}.icon-chevron-right{background-position:-456px -72px}.icon-plus-sign{background-position:0 -96px}.icon-minus-sign{background-position:-24px -96px}.icon-remove-sign{background-position:-48px -96px}.icon-ok-sign{background-position:-72px -96px}.icon-question-sign{background-position:-96px -96px}.icon-info-sign{background-position:-120px -96px}.icon-screenshot{background-position:-144px -96px}.icon-remove-circle{background-position:-168px -96px}.icon-ok-circle{background-position:-192px -96px}.icon-ban-circle{background-position:-216px -96px}.icon-arrow-left{background-position:-240px -96px}.icon-arrow-right{background-position:-264px -96px}.icon-arrow-up{background-position:-289px -96px}.icon-arrow-down{background-position:-312px -96px}.icon-share-alt{background-position:-336px -96px}.icon-resize-full{background-position:-360px -96px}.icon-resize-small{background-position:-384px -96px}.icon-plus{background-position:-408px -96px}.icon-minus{background-position:-433px -96px}.icon-asterisk{background-position:-456px -96px}.icon-exclamation-sign{background-position:0 -120px}.icon-gift{background-position:-24px -120px}.icon-leaf{background-position:-48px -120px}.icon-fire{background-position:-72px -120px}.icon-eye-open{background-position:-96px -120px}.icon-eye-close{background-position:-120px -120px}.icon-warning-sign{background-position:-144px -120px}.icon-plane{background-position:-168px -120px}.icon-calendar{background-position:-192px -120px}.icon-random{background-position:-216px -120px;width:16px}.icon-comment{background-position:-240px -120px}.icon-magnet{background-position:-264px -120px}.icon-chevron-up{background-position:-288px -120px}.icon-chevron-down{background-position:-313px -119px}.icon-retweet{background-position:-336px -120px}.icon-shopping-cart{background-position:-360px -120px}.icon-folder-close{background-position:-384px -120px;width:16px}.icon-folder-open{background-position:-408px -120px;width:16px}.icon-resize-vertical{background-position:-432px -119px}.icon-resize-horizontal{background-position:-456px -118px}.icon-hdd{background-position:0 -144px}.icon-bullhorn{background-position:-24px -144px}.icon-bell{background-position:-48px -144px}.icon-certificate{background-position:-72px -144px}.icon-thumbs-up{background-position:-96px -144px}.icon-thumbs-down{background-position:-120px -144px}.icon-hand-right{background-position:-144px -144px}.icon-hand-left{background-position:-168px -144px}.icon-hand-up{background-position:-192px -144px}.icon-hand-down{background-position:-216px -144px}.icon-circle-arrow-right{background-position:-240px -144px}.icon-circle-arrow-left{background-position:-264px -144px}.icon-circle-arrow-up{background-position:-288px -144px}.icon-circle-arrow-down{background-position:-312px -144px}.icon-globe{background-position:-336px -144px}.icon-wrench{background-position:-360px -144px}.icon-tasks{background-position:-384px -144px}.icon-filter{background-position:-408px -144px}.icon-briefcase{background-position:-432px -144px}.icon-fullscreen{background-position:-456px -144px}.btn-group{position:relative;display:inline-block;*display:inline;*zoom:1;font-size:0;vertical-align:middle;white-space:nowrap;*margin-left:.3em}.btn-group:first-child{*margin-left:0}.btn-group+.btn-group{margin-left:5px}.btn-toolbar{font-size:0;margin-top:10px;margin-bottom:10px}.btn-toolbar>.btn+.btn,.btn-toolbar>.btn+.btn-group,.btn-toolbar>.btn-group+.btn{margin-left:5px}.btn-group>.btn{position:relative;border-radius:0}.btn-group>.btn+.btn{margin-left:-1px}.btn-group>.btn,.btn-group>.dropdown-menu,.btn-group>.popover{font-size:14px}.btn-group>.btn-mini{font-size:10.5px}.btn-group>.btn-small{font-size:11.9px}.btn-group>.btn-large{font-size:17.5px}.btn-group>.btn:first-child{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.btn-group>.btn:last-child,.btn-group>.dropdown-toggle{border-top-right-radius:4px;border-bottom-right-radius:4px}.btn-group>.btn.large:first-child{margin-left:0;border-top-left-radius:6px;border-bottom-left-radius:6px}.btn-group>.btn.large:last-child,.btn-group>.large.dropdown-toggle{border-top-right-radius:6px;border-bottom-right-radius:6px}.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding:5px 8px;box-shadow:inset 1px 0 0 hsla(0,0%,100%,.125),inset 0 1px 0 hsla(0,0%,100%,.2),0 1px 2px rgba(0,0,0,.05)}.btn-group>.btn-mini+.dropdown-toggle{padding:2px 5px}.btn-group>.btn-small+.dropdown-toggle{*padding-top:5px;*padding-bottom:4px}.btn-group>.btn-large+.dropdown-toggle{padding:7px 12px}.btn-group.open .dropdown-toggle{background-image:none;box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05)}.btn-group.open .btn.dropdown-toggle{background-color:#e6e6e6}.btn-group.open .btn-primary.dropdown-toggle{background-color:#04c}.btn-group.open .btn-warning.dropdown-toggle{background-color:#f89406}.btn-group.open .btn-danger.dropdown-toggle{background-color:#bd362f}.btn-group.open .btn-success.dropdown-toggle{background-color:#51a351}.btn-group.open .btn-info.dropdown-toggle{background-color:#2f96b4}.btn-group.open .btn-inverse.dropdown-toggle{background-color:#222}.btn .caret{margin-top:8px;margin-left:0}.btn-large .caret{margin-top:6px;border-left-width:5px;border-right-width:5px;border-top-width:5px}.btn-mini .caret,.btn-small .caret{margin-top:8px}.dropup .btn-large .caret{border-bottom-width:5px}.btn-danger .caret,.btn-info .caret,.btn-inverse .caret,.btn-primary .caret,.btn-success .caret,.btn-warning .caret{border-top-color:#fff;border-bottom-color:#fff}.btn-group-vertical{display:inline-block;*display:inline;*zoom:1}.btn-group-vertical>.btn{display:block;float:none;max-width:100%;border-radius:0}.btn-group-vertical>.btn+.btn{margin-left:0;margin-top:-1px}.btn-group-vertical>.btn:first-child{border-radius:4px 4px 0 0}.btn-group-vertical>.btn:last-child{border-radius:0 0 4px 4px}.btn-group-vertical>.btn-large:first-child{border-radius:6px 6px 0 0}.btn-group-vertical>.btn-large:last-child{border-radius:0 0 6px 6px}.nav{margin-left:0;margin-bottom:20px;list-style:none}.nav>li>a{display:block}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li>a>img{max-width:none}.nav>.pull-right{float:right}.nav-header{display:block;padding:3px 15px;font-size:11px;font-weight:700;line-height:20px;color:#999;text-shadow:0 1px 0 hsla(0,0%,100%,.5);text-transform:uppercase}.nav li+.nav-header{margin-top:9px}.nav-list{padding-left:15px;padding-right:15px;margin-bottom:0}.nav-list .nav-header,.nav-list>li>a{margin-left:-15px;margin-right:-15px;text-shadow:0 1px 0 hsla(0,0%,100%,.5)}.nav-list>li>a{padding:3px 15px}.nav-list>.active>a,.nav-list>.active>a:focus,.nav-list>.active>a:hover{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.2);background-color:#08c}.nav-list [class*=\" icon-\"],.nav-list [class^=icon-]{margin-right:2px}.nav-list .divider{*width:100%;height:1px;margin:9px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.nav-pills,.nav-tabs{*zoom:1}.nav-pills:after,.nav-pills:before,.nav-tabs:after,.nav-tabs:before{display:table;content:\"\";line-height:0}.nav-pills:after,.nav-tabs:after{clear:both}.nav-pills>li,.nav-tabs>li{float:left}.nav-pills>li>a,.nav-tabs>li>a{padding-right:12px;padding-left:12px;margin-right:2px;line-height:14px}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{margin-bottom:-1px}.nav-tabs>li>a{padding-top:8px;padding-bottom:8px;line-height:20px;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs>li>a:focus,.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>.active>a,.nav-tabs>.active>a:focus,.nav-tabs>.active>a:hover{color:#555;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent;cursor:default}.nav-pills>li>a{padding-top:8px;padding-bottom:8px;margin-top:2px;margin-bottom:2px;border-radius:5px}.nav-pills>.active>a,.nav-pills>.active>a:focus,.nav-pills>.active>a:hover{color:#fff;background-color:#08c}.nav-stacked>li{float:none}.nav-stacked>li>a{margin-right:0}.nav-tabs.nav-stacked{border-bottom:0}.nav-tabs.nav-stacked>li>a{border:1px solid #ddd;border-radius:0}.nav-tabs.nav-stacked>li:first-child>a{border-top-right-radius:4px;border-top-left-radius:4px}.nav-tabs.nav-stacked>li:last-child>a{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.nav-tabs.nav-stacked>li>a:focus,.nav-tabs.nav-stacked>li>a:hover{border-color:#ddd;z-index:2}.nav-pills.nav-stacked>li>a{margin-bottom:3px}.nav-pills.nav-stacked>li:last-child>a{margin-bottom:1px}.nav-tabs .dropdown-menu{border-radius:0 0 6px 6px}.nav-pills .dropdown-menu{border-radius:6px}.nav .dropdown-toggle .caret{border-top-color:#08c;border-bottom-color:#08c;margin-top:6px}.nav .dropdown-toggle:focus .caret,.nav .dropdown-toggle:hover .caret{border-top-color:#005580;border-bottom-color:#005580}.nav-tabs .dropdown-toggle .caret{margin-top:8px}.nav .active .dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.nav-tabs .active .dropdown-toggle .caret{border-top-color:#555;border-bottom-color:#555}.nav>.dropdown.active>a:focus,.nav>.dropdown.active>a:hover{cursor:pointer}.nav-pills .open .dropdown-toggle,.nav-tabs .open .dropdown-toggle,.nav>li.dropdown.open.active>a:focus,.nav>li.dropdown.open.active>a:hover{color:#fff;background-color:#999;border-color:#999}.nav li.dropdown.open.active .caret,.nav li.dropdown.open .caret,.nav li.dropdown.open a:focus .caret,.nav li.dropdown.open a:hover .caret{border-top-color:#fff;border-bottom-color:#fff;opacity:1;filter:alpha(opacity=100)}.tabs-stacked .open>a:focus,.tabs-stacked .open>a:hover{border-color:#999}.tabbable{*zoom:1}.tabbable:after,.tabbable:before{display:table;content:\"\";line-height:0}.tabbable:after{clear:both}.tab-content{overflow:auto}.tabs-below>.nav-tabs,.tabs-left>.nav-tabs,.tabs-right>.nav-tabs{border-bottom:0}.pill-content>.pill-pane,.tab-content>.tab-pane{display:none}.pill-content>.active,.tab-content>.active{display:block}.tabs-below>.nav-tabs{border-top:1px solid #ddd}.tabs-below>.nav-tabs>li{margin-top:-1px;margin-bottom:0}.tabs-below>.nav-tabs>li>a{border-radius:0 0 4px 4px}.tabs-below>.nav-tabs>li>a:focus,.tabs-below>.nav-tabs>li>a:hover{border-bottom-color:transparent;border-top-color:#ddd}.tabs-below>.nav-tabs>.active>a,.tabs-below>.nav-tabs>.active>a:focus,.tabs-below>.nav-tabs>.active>a:hover{border-color:transparent #ddd #ddd}.tabs-left>.nav-tabs>li,.tabs-right>.nav-tabs>li{float:none}.tabs-left>.nav-tabs>li>a,.tabs-right>.nav-tabs>li>a{min-width:74px;margin-right:0;margin-bottom:3px}.tabs-left>.nav-tabs{float:left;margin-right:19px;border-right:1px solid #ddd}.tabs-left>.nav-tabs>li>a{margin-right:-1px;border-radius:4px 0 0 4px}.tabs-left>.nav-tabs>li>a:focus,.tabs-left>.nav-tabs>li>a:hover{border-color:#eee #ddd #eee #eee}.tabs-left>.nav-tabs .active>a,.tabs-left>.nav-tabs .active>a:focus,.tabs-left>.nav-tabs .active>a:hover{border-color:#ddd transparent #ddd #ddd;*border-right-color:#fff}.tabs-right>.nav-tabs{float:right;margin-left:19px;border-left:1px solid #ddd}.tabs-right>.nav-tabs>li>a{margin-left:-1px;border-radius:0 4px 4px 0}.tabs-right>.nav-tabs>li>a:focus,.tabs-right>.nav-tabs>li>a:hover{border-color:#eee #eee #eee #ddd}.tabs-right>.nav-tabs .active>a,.tabs-right>.nav-tabs .active>a:focus,.tabs-right>.nav-tabs .active>a:hover{border-color:#ddd #ddd #ddd transparent;*border-left-color:#fff}.nav>.disabled>a{color:#999}.nav>.disabled>a:focus,.nav>.disabled>a:hover{text-decoration:none;background-color:transparent;cursor:default}.navbar{overflow:visible;margin-bottom:20px;*position:relative;*z-index:2}.navbar-inner{min-height:40px;padding-left:20px;padding-right:20px;background-color:#fafafa;background-image:linear-gradient(180deg,#fff,#f2f2f2);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffffffff\",endColorstr=\"#fff2f2f2\",GradientType=0);border:1px solid #d4d4d4;border-radius:4px;box-shadow:0 1px 4px rgba(0,0,0,.065);*zoom:1}.navbar-inner:after,.navbar-inner:before{display:table;content:\"\";line-height:0}.navbar-inner:after{clear:both}.navbar .container{width:auto}.nav-collapse.collapse{height:auto;overflow:visible}.navbar .brand{float:left;display:block;padding:10px 20px;margin-left:-20px;font-size:20px;font-weight:200;color:#777;text-shadow:0 1px 0 #fff}.navbar .brand:focus,.navbar .brand:hover{text-decoration:none}.navbar-text{margin-bottom:0;line-height:40px;color:#777}.navbar-link{color:#777}.navbar-link:focus,.navbar-link:hover{color:#333}.navbar .divider-vertical{height:40px;margin:0 9px;border-left:1px solid #f2f2f2;border-right:1px solid #fff}.navbar .btn,.navbar .btn-group{margin-top:5px}.navbar .btn-group .btn,.navbar .input-append .btn,.navbar .input-append .btn-group,.navbar .input-prepend .btn,.navbar .input-prepend .btn-group{margin-top:0}.navbar-form{margin-bottom:0;*zoom:1}.navbar-form:after,.navbar-form:before{display:table;content:\"\";line-height:0}.navbar-form:after{clear:both}.navbar-form .checkbox,.navbar-form .radio,.navbar-form input,.navbar-form select{margin-top:5px}.navbar-form .btn,.navbar-form input,.navbar-form select{display:inline-block;margin-bottom:0}.navbar-form input[type=checkbox],.navbar-form input[type=image],.navbar-form input[type=radio]{margin-top:3px}.navbar-form .input-append,.navbar-form .input-prepend{margin-top:5px;white-space:nowrap}.navbar-form .input-append input,.navbar-form .input-prepend input{margin-top:0}.navbar-search{position:relative;float:left;margin-top:5px;margin-bottom:0}.navbar-search .search-query{margin-bottom:0;padding:4px 14px;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:13px;font-weight:400;line-height:1;border-radius:15px}.navbar-static-top{position:static;margin-bottom:0}.navbar-static-top .navbar-inner{border-radius:0}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030;margin-bottom:0}.navbar-fixed-top .navbar-inner,.navbar-static-top .navbar-inner{border-width:0 0 1px}.navbar-fixed-bottom .navbar-inner{border-width:1px 0 0}.navbar-fixed-bottom .navbar-inner,.navbar-fixed-top .navbar-inner{padding-left:0;padding-right:0;border-radius:0}.navbar-fixed-bottom .container,.navbar-fixed-top .container,.navbar-static-top .container{width:940px}.navbar-fixed-top{top:0}.navbar-fixed-top .navbar-inner,.navbar-static-top .navbar-inner{box-shadow:0 1px 10px rgba(0,0,0,.1)}.navbar-fixed-bottom{bottom:0}.navbar-fixed-bottom .navbar-inner{box-shadow:0 -1px 10px rgba(0,0,0,.1)}.navbar .nav{position:relative;left:0;display:block;float:left;margin:0 10px 0 0}.navbar .nav.pull-right{float:right;margin-right:0}.navbar .nav>li{float:left}.navbar .nav>li>a{float:none;padding:10px 15px;color:#777;text-decoration:none;text-shadow:0 1px 0 #fff}.navbar .nav .dropdown-toggle .caret{margin-top:8px}.navbar .nav>li>a:focus,.navbar .nav>li>a:hover{background-color:transparent;color:#333;text-decoration:none}.navbar .nav>.active>a,.navbar .nav>.active>a:focus,.navbar .nav>.active>a:hover{color:#555;text-decoration:none;background-color:#e5e5e5;box-shadow:inset 0 3px 8px rgba(0,0,0,.125)}.navbar .btn-navbar{display:none;float:right;padding:7px 10px;margin-left:5px;margin-right:5px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#ededed;background-image:linear-gradient(180deg,#f2f2f2,#e5e5e5);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#fff2f2f2\",endColorstr=\"#ffe5e5e5\",GradientType=0);border-color:#e5e5e5 #e5e5e5 #bfbfbf;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#e5e5e5;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false);box-shadow:inset 0 1px 0 hsla(0,0%,100%,.1),0 1px 0 hsla(0,0%,100%,.075)}.navbar .btn-navbar.active,.navbar .btn-navbar.disabled,.navbar .btn-navbar:active,.navbar .btn-navbar:focus,.navbar .btn-navbar:hover,.navbar .btn-navbar[disabled]{color:#fff;background-color:#e5e5e5;*background-color:#d9d9d9}.navbar .btn-navbar.active,.navbar .btn-navbar:active{background-color:#ccc\\9}.navbar .btn-navbar .icon-bar{display:block;width:18px;height:2px;background-color:#f5f5f5;border-radius:1px;box-shadow:0 1px 0 rgba(0,0,0,.25)}.btn-navbar .icon-bar+.icon-bar{margin-top:3px}.navbar .nav>li>.dropdown-menu:before{content:\"\";display:inline-block;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #ccc;border-bottom-color:rgba(0,0,0,.2);position:absolute;top:-7px;left:9px}.navbar .nav>li>.dropdown-menu:after{content:\"\";display:inline-block;border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:6px solid #fff;position:absolute;top:-6px;left:10px}.navbar-fixed-bottom .nav>li>.dropdown-menu:before{border-top:7px solid #ccc;border-top-color:rgba(0,0,0,.2);border-bottom:0;bottom:-7px;top:auto}.navbar-fixed-bottom .nav>li>.dropdown-menu:after{border-top:6px solid #fff;border-bottom:0;bottom:-6px;top:auto}.navbar .nav li.dropdown>a:focus .caret,.navbar .nav li.dropdown>a:hover .caret{border-top-color:#333;border-bottom-color:#333}.navbar .nav li.dropdown.active>.dropdown-toggle,.navbar .nav li.dropdown.open.active>.dropdown-toggle,.navbar .nav li.dropdown.open>.dropdown-toggle{background-color:#e5e5e5;color:#555}.navbar .nav li.dropdown>.dropdown-toggle .caret{border-top-color:#777;border-bottom-color:#777}.navbar .nav li.dropdown.active>.dropdown-toggle .caret,.navbar .nav li.dropdown.open.active>.dropdown-toggle .caret,.navbar .nav li.dropdown.open>.dropdown-toggle .caret{border-top-color:#555;border-bottom-color:#555}.navbar .nav>li>.dropdown-menu.pull-right,.navbar .pull-right>li>.dropdown-menu{left:auto;right:0}.navbar .nav>li>.dropdown-menu.pull-right:before,.navbar .pull-right>li>.dropdown-menu:before{left:auto;right:12px}.navbar .nav>li>.dropdown-menu.pull-right:after,.navbar .pull-right>li>.dropdown-menu:after{left:auto;right:13px}.navbar .nav>li>.dropdown-menu.pull-right .dropdown-menu,.navbar .pull-right>li>.dropdown-menu .dropdown-menu{left:auto;right:100%;margin-left:0;margin-right:-1px;border-radius:6px 0 6px 6px}.navbar-inverse .navbar-inner{background-color:#1b1b1b;background-image:linear-gradient(180deg,#222,#111);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff222222\",endColorstr=\"#ff111111\",GradientType=0);border-color:#252525}.navbar-inverse .brand,.navbar-inverse .nav>li>a{color:#999;text-shadow:0 -1px 0 rgba(0,0,0,.25)}.navbar-inverse .brand:focus,.navbar-inverse .brand:hover,.navbar-inverse .nav>li>a:focus,.navbar-inverse .nav>li>a:hover{color:#fff}.navbar-inverse .brand,.navbar-inverse .navbar-text{color:#999}.navbar-inverse .nav>li>a:focus,.navbar-inverse .nav>li>a:hover{background-color:transparent;color:#fff}.navbar-inverse .nav .active>a,.navbar-inverse .nav .active>a:focus,.navbar-inverse .nav .active>a:hover{color:#fff;background-color:#111}.navbar-inverse .navbar-link{color:#999}.navbar-inverse .navbar-link:focus,.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .divider-vertical{border-left-color:#111;border-right-color:#222}.navbar-inverse .nav li.dropdown.active>.dropdown-toggle,.navbar-inverse .nav li.dropdown.open.active>.dropdown-toggle,.navbar-inverse .nav li.dropdown.open>.dropdown-toggle{background-color:#111;color:#fff}.navbar-inverse .nav li.dropdown>a:focus .caret,.navbar-inverse .nav li.dropdown>a:hover .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar-inverse .nav li.dropdown>.dropdown-toggle .caret{border-top-color:#999;border-bottom-color:#999}.navbar-inverse .nav li.dropdown.active>.dropdown-toggle .caret,.navbar-inverse .nav li.dropdown.open.active>.dropdown-toggle .caret,.navbar-inverse .nav li.dropdown.open>.dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar-inverse .navbar-search .search-query{color:#fff;background-color:#515151;border-color:#111;box-shadow:inset 0 1px 2px rgba(0,0,0,.1),0 1px 0 hsla(0,0%,100%,.15);transition:none}.navbar-inverse .navbar-search .search-query:-moz-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query:-ms-input-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query::-webkit-input-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query.focused,.navbar-inverse .navbar-search .search-query:focus{padding:5px 15px;color:#333;text-shadow:0 1px 0 #fff;background-color:#fff;border:0;box-shadow:0 0 3px rgba(0,0,0,.15);outline:0}.navbar-inverse .btn-navbar{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#0e0e0e;background-image:linear-gradient(180deg,#151515,#040404);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff151515\",endColorstr=\"#ff040404\",GradientType=0);border-color:#040404 #040404 #000;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);*background-color:#040404;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false)}.navbar-inverse .btn-navbar.active,.navbar-inverse .btn-navbar.disabled,.navbar-inverse .btn-navbar:active,.navbar-inverse .btn-navbar:focus,.navbar-inverse .btn-navbar:hover,.navbar-inverse .btn-navbar[disabled]{color:#fff;background-color:#040404;*background-color:#000}.navbar-inverse .btn-navbar.active,.navbar-inverse .btn-navbar:active{background-color:#000\\9}.breadcrumb{padding:8px 15px;margin:0 0 20px;list-style:none;background-color:#f5f5f5;border-radius:4px}.breadcrumb>li{display:inline-block;*display:inline;*zoom:1;text-shadow:0 1px 0 #fff}.breadcrumb>li>.divider{padding:0 5px;color:#ccc}.breadcrumb>.active{color:#999}.pagination{margin:20px 0}.pagination ul{display:inline-block;*display:inline;*zoom:1;margin-left:0;margin-bottom:0;border-radius:4px;box-shadow:0 1px 2px rgba(0,0,0,.05)}.pagination ul>li{display:inline}.pagination ul>li>a,.pagination ul>li>span{float:left;padding:4px 12px;line-height:20px;text-decoration:none;background-color:#fff;border:1px solid #ddd;border-left-width:0}.pagination ul>.active>a,.pagination ul>.active>span,.pagination ul>li>a:focus,.pagination ul>li>a:hover{background-color:#f5f5f5}.pagination ul>.active>a,.pagination ul>.active>span{color:#999;cursor:default}.pagination ul>.disabled>a,.pagination ul>.disabled>a:focus,.pagination ul>.disabled>a:hover,.pagination ul>.disabled>span{color:#999;background-color:transparent;cursor:default}.pagination ul>li:first-child>a,.pagination ul>li:first-child>span{border-left-width:1px;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination ul>li:last-child>a,.pagination ul>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination-centered{text-align:center}.pagination-right{text-align:right}.pagination-large ul>li>a,.pagination-large ul>li>span{padding:11px 19px;font-size:17.5px}.pagination-large ul>li:first-child>a,.pagination-large ul>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.pagination-large ul>li:last-child>a,.pagination-large ul>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.pagination-mini ul>li:first-child>a,.pagination-mini ul>li:first-child>span,.pagination-small ul>li:first-child>a,.pagination-small ul>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.pagination-mini ul>li:last-child>a,.pagination-mini ul>li:last-child>span,.pagination-small ul>li:last-child>a,.pagination-small ul>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}.pagination-small ul>li>a,.pagination-small ul>li>span{padding:2px 10px;font-size:11.9px}.pagination-mini ul>li>a,.pagination-mini ul>li>span{padding:0 6px;font-size:10.5px}.pager{margin:20px 0;list-style:none;text-align:center;*zoom:1}.pager:after,.pager:before{display:table;content:\"\";line-height:0}.pager:after{clear:both}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#f5f5f5}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#999;background-color:#fff;cursor:default}.thumbnails{margin-left:-20px;list-style:none;*zoom:1}.thumbnails:after,.thumbnails:before{display:table;content:\"\";line-height:0}.thumbnails:after{clear:both}.row-fluid .thumbnails{margin-left:0}.thumbnails>li{float:left;margin-bottom:20px;margin-left:20px}.thumbnail{display:block;padding:4px;line-height:20px;border:1px solid #ddd;border-radius:4px;box-shadow:0 1px 3px rgba(0,0,0,.055);transition:all .2s ease-in-out}a.thumbnail:focus,a.thumbnail:hover{border-color:#08c;box-shadow:0 1px 4px rgba(0,105,214,.25)}.thumbnail>img{display:block;max-width:100%;margin-left:auto;margin-right:auto}.thumbnail .caption{padding:9px;color:#555}.alert{padding:8px 35px 8px 14px;margin-bottom:20px;text-shadow:0 1px 0 hsla(0,0%,100%,.5);background-color:#fcf8e3;border:1px solid #fbeed5;border-radius:4px}.alert,.alert h4{color:#c09853}.alert h4{margin:0}.alert .close{position:relative;top:-2px;right:-21px;line-height:20px}.alert-success{background-color:#dff0d8;border-color:#d6e9c6;color:#468847}.alert-success h4{color:#468847}.alert-danger,.alert-error{background-color:#f2dede;border-color:#eed3d7;color:#b94a48}.alert-danger h4,.alert-error h4{color:#b94a48}.alert-info{background-color:#d9edf7;border-color:#bce8f1}.alert-info,.alert-info h4{color:#3a87ad}.alert-block{padding-top:14px;padding-bottom:14px}.alert-block>p,.alert-block>ul{margin-bottom:0}.alert-block p+p{margin-top:5px}@keyframes progress-bar-stripes{0%{background-position:40px 0}to{background-position:0 0}}.progress{overflow:hidden;height:20px;margin-bottom:20px;background-color:#f7f7f7;background-image:linear-gradient(180deg,#f5f5f5,#f9f9f9);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#fff5f5f5\",endColorstr=\"#fff9f9f9\",GradientType=0);box-shadow:inset 0 1px 2px rgba(0,0,0,.1);border-radius:4px}.progress,.progress .bar{background-repeat:repeat-x}.progress .bar{width:0;height:100%;color:#fff;float:left;font-size:12px;text-align:center;text-shadow:0 -1px 0 rgba(0,0,0,.25);background-color:#0e90d2;background-image:linear-gradient(180deg,#149bdf,#0480be);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff149bdf\",endColorstr=\"#ff0480be\",GradientType=0);box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);box-sizing:border-box;transition:width .6s ease}.progress .bar+.bar{box-shadow:inset 1px 0 0 rgba(0,0,0,.15),inset 0 -1px 0 rgba(0,0,0,.15)}.progress-striped .bar{background-color:#149bdf;background-image:linear-gradient(45deg,hsla(0,0%,100%,.15) 25%,transparent 0,transparent 50%,hsla(0,0%,100%,.15) 0,hsla(0,0%,100%,.15) 75%,transparent 0,transparent);background-size:40px 40px}.progress.active .bar{animation:progress-bar-stripes 2s linear infinite}.progress-danger .bar,.progress .bar-danger{background-color:#dd514c;background-image:linear-gradient(180deg,#ee5f5b,#c43c35);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffee5f5b\",endColorstr=\"#ffc43c35\",GradientType=0)}.progress-danger.progress-striped .bar,.progress-striped .bar-danger{background-color:#ee5f5b;background-image:linear-gradient(45deg,hsla(0,0%,100%,.15) 25%,transparent 0,transparent 50%,hsla(0,0%,100%,.15) 0,hsla(0,0%,100%,.15) 75%,transparent 0,transparent)}.progress-success .bar,.progress .bar-success{background-color:#5eb95e;background-image:linear-gradient(180deg,#62c462,#57a957);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff62c462\",endColorstr=\"#ff57a957\",GradientType=0)}.progress-striped .bar-success,.progress-success.progress-striped .bar{background-color:#62c462;background-image:linear-gradient(45deg,hsla(0,0%,100%,.15) 25%,transparent 0,transparent 50%,hsla(0,0%,100%,.15) 0,hsla(0,0%,100%,.15) 75%,transparent 0,transparent)}.progress-info .bar,.progress .bar-info{background-color:#4bb1cf;background-image:linear-gradient(180deg,#5bc0de,#339bb9);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff5bc0de\",endColorstr=\"#ff339bb9\",GradientType=0)}.progress-info.progress-striped .bar,.progress-striped .bar-info{background-color:#5bc0de;background-image:linear-gradient(45deg,hsla(0,0%,100%,.15) 25%,transparent 0,transparent 50%,hsla(0,0%,100%,.15) 0,hsla(0,0%,100%,.15) 75%,transparent 0,transparent)}.progress-warning .bar,.progress .bar-warning{background-color:#faa732;background-image:linear-gradient(180deg,#fbb450,#f89406);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#fffbb450\",endColorstr=\"#fff89406\",GradientType=0)}.progress-striped .bar-warning,.progress-warning.progress-striped .bar{background-color:#fbb450;background-image:linear-gradient(45deg,hsla(0,0%,100%,.15) 25%,transparent 0,transparent 50%,hsla(0,0%,100%,.15) 0,hsla(0,0%,100%,.15) 75%,transparent 0,transparent)}.hero-unit{padding:60px;margin-bottom:30px;font-size:18px;font-weight:200;line-height:30px;color:inherit;background-color:#eee;border-radius:6px}.hero-unit h1{margin-bottom:0;font-size:60px;line-height:1;color:inherit;letter-spacing:-1px}.hero-unit li{line-height:30px}.media,.media-body{overflow:hidden;*overflow:visible;zoom:1}.media,.media .media{margin-top:15px}.media:first-child{margin-top:0}.media-object{display:block}.media-heading{margin:0 0 5px}.media>.pull-left{margin-right:10px}.media>.pull-right{margin-left:10px}.media-list{margin-left:0;list-style:none}.tooltip{position:absolute;z-index:1030;display:block;visibility:visible;font-size:11px;line-height:1.4;opacity:0;filter:alpha(opacity=0)}.tooltip.in{opacity:.8;filter:alpha(opacity=80)}.tooltip.top{margin-top:-3px;padding:5px 0}.tooltip.right{margin-left:3px;padding:0 5px}.tooltip.bottom{margin-top:3px;padding:5px 0}.tooltip.left{margin-left:-3px;padding:0 5px}.tooltip-inner{max-width:200px;padding:8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.popover{position:absolute;top:0;left:0;z-index:1010;display:none;max-width:276px;padding:1px;text-align:left;background-color:#fff;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);border-radius:6px;box-shadow:0 5px 10px rgba(0,0,0,.2);white-space:normal}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{margin:0;padding:8px 14px;font-size:14px;font-weight:400;line-height:18px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.popover-title:empty{display:none}.popover-content{padding:9px 14px}.popover .arrow,.popover .arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover .arrow{border-width:11px}.popover .arrow:after{border-width:10px;content:\"\"}.popover.top .arrow{left:50%;margin-left:-11px;border-bottom-width:0;border-top-color:#999;border-top-color:rgba(0,0,0,.25);bottom:-11px}.popover.top .arrow:after{bottom:1px;margin-left:-10px;border-bottom-width:0;border-top-color:#fff}.popover.right .arrow{top:50%;left:-11px;margin-top:-11px;border-left-width:0;border-right-color:#999;border-right-color:rgba(0,0,0,.25)}.popover.right .arrow:after{left:1px;bottom:-10px;border-left-width:0;border-right-color:#fff}.popover.bottom .arrow{left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,.25);top:-11px}.popover.bottom .arrow:after{top:1px;margin-left:-10px;border-top-width:0;border-bottom-color:#fff}.popover.left .arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999;border-left-color:rgba(0,0,0,.25)}.popover.left .arrow:after{right:1px;border-right-width:0;border-left-color:#fff;bottom:-10px}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop,.modal-backdrop.fade.in{opacity:.8;filter:alpha(opacity=80)}.modal{position:fixed;top:10%;left:50%;z-index:1050;width:560px;margin-left:-280px;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,.3);*border:1px solid #999;border-radius:6px;box-shadow:0 3px 7px rgba(0,0,0,.3);background-clip:padding-box;outline:none}.modal.fade{transition:opacity .3s linear,top .3s ease-out;top:-25%}.modal.fade.in{top:10%}.modal-header{padding:9px 15px;border-bottom:1px solid #eee}.modal-header .close{margin-top:2px}.modal-header h3{margin:0;line-height:30px}.modal-body{position:relative;overflow-y:auto;max-height:400px;padding:15px}.modal-footer,.modal-form{margin-bottom:0}.modal-footer{padding:14px 15px 15px;text-align:right;background-color:#f5f5f5;border-top:1px solid #ddd;border-radius:0 0 6px 6px;box-shadow:inset 0 1px 0 #fff;*zoom:1}.modal-footer:after,.modal-footer:before{display:table;content:\"\";line-height:0}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-left:5px;margin-bottom:0}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.dropdown,.dropup{position:relative}.dropdown-toggle{*margin-bottom:-3px}.dropdown-toggle:active,.open .dropdown-toggle{outline:0}.caret{display:inline-block;width:0;height:0;vertical-align:top;border-top:4px solid #000;border-right:4px solid transparent;border-left:4px solid transparent;content:\"\"}.dropdown .caret{margin-top:8px;margin-left:2px}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);*border-right-width:2px;*border-bottom-width:2px;border-radius:6px;box-shadow:0 5px 10px rgba(0,0,0,.2);background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{*width:100%;height:1px;margin:9px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:20px;color:#333;white-space:nowrap}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover,.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover,.dropdown-submenu:focus>a,.dropdown-submenu:hover>a{text-decoration:none;color:#fff;background-color:#0081c2;background-image:linear-gradient(180deg,#08c,#0077b3);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ff0088cc\",endColorstr=\"#ff0077b3\",GradientType=0)}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{outline:0}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#999}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false);cursor:default}.open{*z-index:1000}.open>.dropdown-menu{display:block}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px solid #000;content:\"\"}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:1px}.dropdown-submenu{position:relative}.dropdown-submenu>.dropdown-menu{top:0;left:100%;margin-top:-6px;margin-left:-1px;border-radius:0 6px 6px 6px}.dropdown-submenu:hover>.dropdown-menu{display:block}.dropup .dropdown-submenu>.dropdown-menu{top:auto;bottom:0;margin-top:0;margin-bottom:-2px;border-radius:5px 5px 5px 0}.dropdown-submenu>a:after{display:block;content:\" \";float:right;width:0;height:0;border-color:transparent;border-style:solid;border-width:5px 0 5px 5px;border-left-color:#ccc;margin-top:5px;margin-right:-10px}.dropdown-submenu:hover>a:after{border-left-color:#fff}.dropdown-submenu.pull-left{float:none}.dropdown-submenu.pull-left>.dropdown-menu{left:-100%;margin-left:10px;border-radius:6px 0 6px 6px}.dropdown .dropdown-menu .nav-header{padding-left:20px;padding-right:20px}.typeahead{z-index:1051;margin-top:2px;border-radius:4px}.accordion{margin-bottom:20px}.accordion-group{margin-bottom:2px;border:1px solid #e5e5e5;border-radius:4px}.accordion-heading{border-bottom:0}.accordion-heading .accordion-toggle{display:block;padding:8px 15px}.accordion-toggle{cursor:pointer}.accordion-inner{padding:9px 15px;border-top:1px solid #e5e5e5}.carousel{position:relative;margin-bottom:20px;line-height:1}.carousel-inner{overflow:hidden;width:100%;position:relative}.carousel-inner>.item{display:none;position:relative;transition:left .6s ease-in-out}.carousel-inner>.item>a>img,.carousel-inner>.item>img{display:block;line-height:1}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:40%;left:15px;width:40px;height:40px;margin-top:-20px;font-size:60px;font-weight:100;line-height:30px;color:#fff;text-align:center;background:#222;border:3px solid #fff;border-radius:23px;opacity:.5;filter:alpha(opacity=50)}.carousel-control.right{left:auto;right:15px}.carousel-control:focus,.carousel-control:hover{color:#fff;text-decoration:none;opacity:.9;filter:alpha(opacity=90)}.carousel-indicators{position:absolute;top:15px;right:15px;z-index:5;margin:0;list-style:none}.carousel-indicators li{display:block;float:left;width:10px;height:10px;margin-left:5px;text-indent:-999px;background-color:#ccc;background-color:hsla(0,0%,100%,.25);border-radius:5px}.carousel-indicators .active{background-color:#fff}.carousel-caption{position:absolute;left:0;right:0;bottom:0;padding:15px;background:#333;background:rgba(0,0,0,.75)}.carousel-caption h4,.carousel-caption p{color:#fff;line-height:20px}.carousel-caption h4{margin:0 0 5px}.carousel-caption p{margin-bottom:0}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-large{padding:24px;border-radius:6px}.well-small{padding:9px;border-radius:3px}.close{float:right;font-size:20px;font-weight:700;line-height:20px;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;opacity:.4;filter:alpha(opacity=40)}button.close{padding:0;cursor:pointer;background:transparent;border:0;-webkit-appearance:none}.pull-right{float:right}.pull-left{float:left}.hide{display:none}.show{display:block}.invisible{visibility:hidden}.affix{position:fixed}.fade{opacity:0;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{position:relative;height:0;overflow:hidden;transition:height .35s ease}.collapse.in{height:auto}@-ms-viewport{width:device-width}.hidden{display:none;visibility:hidden}.hidden-desktop,.visible-phone,.visible-tablet{display:none!important}.visible-desktop{display:inherit!important}@media (min-width:768px) and (max-width:979px){.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}.visible-tablet{display:inherit!important}.hidden-tablet{display:none!important}}@media (max-width:767px){.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}.visible-phone{display:inherit!important}.hidden-phone{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:inherit!important}.hidden-print{display:none!important}}@media (max-width:767px){body{padding-left:20px;padding-right:20px}.navbar-fixed-bottom,.navbar-fixed-top,.navbar-static-top{margin-left:-20px;margin-right:-20px}.container-fluid{padding:0}.dl-horizontal dt{float:none;clear:none;width:auto;text-align:left}.dl-horizontal dd{margin-left:0}.container{width:auto}.row-fluid{width:100%}.row,.thumbnails{margin-left:0}.thumbnails>li{float:none;margin-left:0}.row-fluid [class*=span],.uneditable-input[class*=span],[class*=span]{float:none;display:block;width:100%;margin-left:0;box-sizing:border-box}.row-fluid .span12,.span12{width:100%;box-sizing:border-box}.row-fluid [class*=offset]:first-child{margin-left:0}.input-large,.input-xlarge,.input-xxlarge,.uneditable-input,input[class*=span],select[class*=span],textarea[class*=span]{display:block;width:100%;min-height:30px;box-sizing:border-box}.input-append input,.input-append input[class*=span],.input-prepend input,.input-prepend input[class*=span]{display:inline-block;width:auto}.controls-row [class*=span]+[class*=span]{margin-left:0}.modal{position:fixed;top:20px;left:20px;right:20px;width:auto;margin:0}.modal.fade{top:-100px}.modal.fade.in{top:20px}}@media (max-width:480px){.nav-collapse{-webkit-transform:translateZ(0)}.page-header h1 small{display:block;line-height:20px}input[type=checkbox],input[type=radio]{border:1px solid #ccc}.form-horizontal .control-label{float:none;width:auto;padding-top:0;text-align:left}.form-horizontal .controls{margin-left:0}.form-horizontal .control-list{padding-top:0}.form-horizontal .form-actions{padding-left:10px;padding-right:10px}.media .pull-left,.media .pull-right{float:none;display:block;margin-bottom:10px}.media-object{margin-right:0;margin-left:0}.modal{top:10px;left:10px;right:10px}.modal-header .close{padding:10px;margin:-10px}.carousel-caption{position:static}}@media (min-width:768px) and (max-width:979px){.row{margin-left:-20px;*zoom:1}.row:after,.row:before{display:table;content:\"\";line-height:0}.row:after{clear:both}[class*=span]{float:left;min-height:1px;margin-left:20px}.container,.navbar-fixed-bottom .container,.navbar-fixed-top .container,.navbar-static-top .container,.span12{width:724px}.span11{width:662px}.span10{width:600px}.span9{width:538px}.span8{width:476px}.span7{width:414px}.span6{width:352px}.span5{width:290px}.span4{width:228px}.span3{width:166px}.span2{width:104px}.span1{width:42px}.offset12{margin-left:764px}.offset11{margin-left:702px}.offset10{margin-left:640px}.offset9{margin-left:578px}.offset8{margin-left:516px}.offset7{margin-left:454px}.offset6{margin-left:392px}.offset5{margin-left:330px}.offset4{margin-left:268px}.offset3{margin-left:206px}.offset2{margin-left:144px}.offset1{margin-left:82px}.row-fluid{width:100%;*zoom:1}.row-fluid:after,.row-fluid:before{display:table;content:\"\";line-height:0}.row-fluid:after{clear:both}.row-fluid [class*=span]{display:block;width:100%;min-height:30px;box-sizing:border-box;float:left;margin-left:2.7624309392265194%;*margin-left:2.709239449864817%}.row-fluid [class*=span]:first-child{margin-left:0}.row-fluid .controls-row [class*=span]+[class*=span]{margin-left:2.7624309392265194%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.43646408839778%;*width:91.38327259903608%}.row-fluid .span10{width:82.87292817679558%;*width:82.81973668743387%}.row-fluid .span9{width:74.30939226519337%;*width:74.25620077583166%}.row-fluid .span8{width:65.74585635359117%;*width:65.69266486422946%}.row-fluid .span7{width:57.18232044198895%;*width:57.12912895262725%}.row-fluid .span6{width:48.61878453038674%;*width:48.56559304102504%}.row-fluid .span5{width:40.05524861878453%;*width:40.00205712942283%}.row-fluid .span4{width:31.491712707182323%;*width:31.43852121782062%}.row-fluid .span3{width:22.92817679558011%;*width:22.87498530621841%}.row-fluid .span2{width:14.3646408839779%;*width:14.311449394616199%}.row-fluid .span1{width:5.801104972375691%;*width:5.747913483013988%}.row-fluid .offset12{margin-left:105.52486187845304%;*margin-left:105.41847889972962%}.row-fluid .offset12:first-child{margin-left:102.76243093922652%;*margin-left:102.6560479605031%}.row-fluid .offset11{margin-left:96.96132596685082%;*margin-left:96.8549429881274%}.row-fluid .offset11:first-child{margin-left:94.1988950276243%;*margin-left:94.09251204890089%}.row-fluid .offset10{margin-left:88.39779005524862%;*margin-left:88.2914070765252%}.row-fluid .offset10:first-child{margin-left:85.6353591160221%;*margin-left:85.52897613729868%}.row-fluid .offset9{margin-left:79.8342541436464%;*margin-left:79.72787116492299%}.row-fluid .offset9:first-child{margin-left:77.07182320441989%;*margin-left:76.96544022569647%}.row-fluid .offset8{margin-left:71.2707182320442%;*margin-left:71.16433525332079%}.row-fluid .offset8:first-child{margin-left:68.50828729281768%;*margin-left:68.40190431409427%}.row-fluid .offset7{margin-left:62.70718232044199%;*margin-left:62.600799341718584%}.row-fluid .offset7:first-child{margin-left:59.94475138121547%;*margin-left:59.838368402492065%}.row-fluid .offset6{margin-left:54.14364640883978%;*margin-left:54.037263430116376%}.row-fluid .offset6:first-child{margin-left:51.38121546961326%;*margin-left:51.27483249088986%}.row-fluid .offset5{margin-left:45.58011049723757%;*margin-left:45.47372751851417%}.row-fluid .offset5:first-child{margin-left:42.81767955801105%;*margin-left:42.71129657928765%}.row-fluid .offset4{margin-left:37.01657458563536%;*margin-left:36.91019160691196%}.row-fluid .offset4:first-child{margin-left:34.25414364640884%;*margin-left:34.14776066768544%}.row-fluid .offset3{margin-left:28.45303867403315%;*margin-left:28.346655695309746%}.row-fluid .offset3:first-child{margin-left:25.69060773480663%;*margin-left:25.584224756083227%}.row-fluid .offset2{margin-left:19.88950276243094%;*margin-left:19.783119783707537%}.row-fluid .offset2:first-child{margin-left:17.12707182320442%;*margin-left:17.02068884448102%}.row-fluid .offset1{margin-left:11.32596685082873%;*margin-left:11.219583872105325%}.row-fluid .offset1:first-child{margin-left:8.56353591160221%;*margin-left:8.457152932878806%}.uneditable-input,input,textarea{margin-left:0}.controls-row [class*=span]+[class*=span]{margin-left:20px}.uneditable-input.span12,input.span12,textarea.span12{width:710px}.uneditable-input.span11,input.span11,textarea.span11{width:648px}.uneditable-input.span10,input.span10,textarea.span10{width:586px}.uneditable-input.span9,input.span9,textarea.span9{width:524px}.uneditable-input.span8,input.span8,textarea.span8{width:462px}.uneditable-input.span7,input.span7,textarea.span7{width:400px}.uneditable-input.span6,input.span6,textarea.span6{width:338px}.uneditable-input.span5,input.span5,textarea.span5{width:276px}.uneditable-input.span4,input.span4,textarea.span4{width:214px}.uneditable-input.span3,input.span3,textarea.span3{width:152px}.uneditable-input.span2,input.span2,textarea.span2{width:90px}.uneditable-input.span1,input.span1,textarea.span1{width:28px}}@media (min-width:1200px){.row{margin-left:-30px;*zoom:1}.row:after,.row:before{display:table;content:\"\";line-height:0}.row:after{clear:both}[class*=span]{float:left;min-height:1px;margin-left:30px}.container,.navbar-fixed-bottom .container,.navbar-fixed-top .container,.navbar-static-top .container,.span12{width:1170px}.span11{width:1070px}.span10{width:970px}.span9{width:870px}.span8{width:770px}.span7{width:670px}.span6{width:570px}.span5{width:470px}.span4{width:370px}.span3{width:270px}.span2{width:170px}.span1{width:70px}.offset12{margin-left:1230px}.offset11{margin-left:1130px}.offset10{margin-left:1030px}.offset9{margin-left:930px}.offset8{margin-left:830px}.offset7{margin-left:730px}.offset6{margin-left:630px}.offset5{margin-left:530px}.offset4{margin-left:430px}.offset3{margin-left:330px}.offset2{margin-left:230px}.offset1{margin-left:130px}.row-fluid{width:100%;*zoom:1}.row-fluid:after,.row-fluid:before{display:table;content:\"\";line-height:0}.row-fluid:after{clear:both}.row-fluid [class*=span]{display:block;width:100%;min-height:30px;box-sizing:border-box;float:left;margin-left:2.564102564102564%;*margin-left:2.5109110747408616%}.row-fluid [class*=span]:first-child{margin-left:0}.row-fluid .controls-row [class*=span]+[class*=span]{margin-left:2.564102564102564%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.45299145299145%;*width:91.39979996362975%}.row-fluid .span10{width:82.90598290598291%;*width:82.8527914166212%}.row-fluid .span9{width:74.35897435897436%;*width:74.30578286961266%}.row-fluid .span8{width:65.81196581196582%;*width:65.75877432260411%}.row-fluid .span7{width:57.26495726495726%;*width:57.21176577559556%}.row-fluid .span6{width:48.717948717948715%;*width:48.664757228587014%}.row-fluid .span5{width:40.17094017094017%;*width:40.11774868157847%}.row-fluid .span4{width:31.623931623931625%;*width:31.570740134569924%}.row-fluid .span3{width:23.076923076923077%;*width:23.023731587561375%}.row-fluid .span2{width:14.52991452991453%;*width:14.476723040552828%}.row-fluid .span1{width:5.982905982905983%;*width:5.929714493544281%}.row-fluid .offset12{margin-left:105.12820512820512%;*margin-left:105.02182214948171%}.row-fluid .offset12:first-child{margin-left:102.56410256410257%;*margin-left:102.45771958537915%}.row-fluid .offset11{margin-left:96.58119658119658%;*margin-left:96.47481360247316%}.row-fluid .offset11:first-child{margin-left:94.01709401709402%;*margin-left:93.91071103837061%}.row-fluid .offset10{margin-left:88.03418803418803%;*margin-left:87.92780505546462%}.row-fluid .offset10:first-child{margin-left:85.47008547008548%;*margin-left:85.36370249136206%}.row-fluid .offset9{margin-left:79.48717948717949%;*margin-left:79.38079650845607%}.row-fluid .offset9:first-child{margin-left:76.92307692307693%;*margin-left:76.81669394435352%}.row-fluid .offset8{margin-left:70.94017094017094%;*margin-left:70.83378796144753%}.row-fluid .offset8:first-child{margin-left:68.37606837606839%;*margin-left:68.26968539734497%}.row-fluid .offset7{margin-left:62.393162393162385%;*margin-left:62.28677941443899%}.row-fluid .offset7:first-child{margin-left:59.82905982905982%;*margin-left:59.72267685033642%}.row-fluid .offset6{margin-left:53.84615384615384%;*margin-left:53.739770867430444%}.row-fluid .offset6:first-child{margin-left:51.28205128205128%;*margin-left:51.175668303327875%}.row-fluid .offset5{margin-left:45.299145299145295%;*margin-left:45.1927623204219%}.row-fluid .offset5:first-child{margin-left:42.73504273504273%;*margin-left:42.62865975631933%}.row-fluid .offset4{margin-left:36.75213675213675%;*margin-left:36.645753773413354%}.row-fluid .offset4:first-child{margin-left:34.18803418803419%;*margin-left:34.081651209310785%}.row-fluid .offset3{margin-left:28.205128205128204%;*margin-left:28.0987452264048%}.row-fluid .offset3:first-child{margin-left:25.641025641025642%;*margin-left:25.53464266230224%}.row-fluid .offset2{margin-left:19.65811965811966%;*margin-left:19.551736679396257%}.row-fluid .offset2:first-child{margin-left:17.094017094017094%;*margin-left:16.98763411529369%}.row-fluid .offset1{margin-left:11.11111111111111%;*margin-left:11.004728132387708%}.row-fluid .offset1:first-child{margin-left:8.547008547008547%;*margin-left:8.440625568285142%}.uneditable-input,input,textarea{margin-left:0}.controls-row [class*=span]+[class*=span]{margin-left:30px}.uneditable-input.span12,input.span12,textarea.span12{width:1156px}.uneditable-input.span11,input.span11,textarea.span11{width:1056px}.uneditable-input.span10,input.span10,textarea.span10{width:956px}.uneditable-input.span9,input.span9,textarea.span9{width:856px}.uneditable-input.span8,input.span8,textarea.span8{width:756px}.uneditable-input.span7,input.span7,textarea.span7{width:656px}.uneditable-input.span6,input.span6,textarea.span6{width:556px}.uneditable-input.span5,input.span5,textarea.span5{width:456px}.uneditable-input.span4,input.span4,textarea.span4{width:356px}.uneditable-input.span3,input.span3,textarea.span3{width:256px}.uneditable-input.span2,input.span2,textarea.span2{width:156px}.uneditable-input.span1,input.span1,textarea.span1{width:56px}.thumbnails{margin-left:-30px}.thumbnails>li{margin-left:30px}.row-fluid .thumbnails{margin-left:0}}@media (max-width:979px){body{padding-top:0}.navbar-fixed-bottom,.navbar-fixed-top{position:static}.navbar-fixed-top{margin-bottom:20px}.navbar-fixed-bottom{margin-top:20px}.navbar-fixed-bottom .navbar-inner,.navbar-fixed-top .navbar-inner{padding:5px}.navbar .container{width:auto;padding:0}.navbar .brand{padding-left:10px;padding-right:10px;margin:0 0 0 -5px}.nav-collapse{clear:both}.nav-collapse .nav{float:none;margin:0 0 10px}.nav-collapse .nav>li{float:none}.nav-collapse .nav>li>a{margin-bottom:2px}.nav-collapse .nav>.divider-vertical{display:none}.nav-collapse .nav .nav-header{color:#777;text-shadow:none}.nav-collapse .dropdown-menu a,.nav-collapse .nav>li>a{padding:9px 15px;font-weight:700;color:#777;border-radius:3px}.nav-collapse .btn{padding:4px 10px;font-weight:400;border-radius:4px}.nav-collapse .dropdown-menu li+li a{margin-bottom:2px}.nav-collapse .dropdown-menu a:focus,.nav-collapse .dropdown-menu a:hover,.nav-collapse .nav>li>a:focus,.nav-collapse .nav>li>a:hover{background-color:#f2f2f2}.navbar-inverse .nav-collapse .dropdown-menu a,.navbar-inverse .nav-collapse .nav>li>a{color:#999}.navbar-inverse .nav-collapse .dropdown-menu a:focus,.navbar-inverse .nav-collapse .dropdown-menu a:hover,.navbar-inverse .nav-collapse .nav>li>a:focus,.navbar-inverse .nav-collapse .nav>li>a:hover{background-color:#111}.nav-collapse.in .btn-group{margin-top:5px;padding:0}.nav-collapse .dropdown-menu{position:static;top:auto;left:auto;float:none;display:none;max-width:none;margin:0 15px;padding:0;background-color:transparent;border:none;border-radius:0;box-shadow:none}.nav-collapse .open>.dropdown-menu{display:block}.nav-collapse .dropdown-menu .divider,.nav-collapse .dropdown-menu:after,.nav-collapse .dropdown-menu:before,.nav-collapse .nav>li>.dropdown-menu:after,.nav-collapse .nav>li>.dropdown-menu:before{display:none}.nav-collapse .navbar-form,.nav-collapse .navbar-search{float:none;padding:10px 15px;margin:10px 0;border-top:1px solid #f2f2f2;border-bottom:1px solid #f2f2f2;box-shadow:inset 0 1px 0 hsla(0,0%,100%,.1),0 1px 0 hsla(0,0%,100%,.1)}.navbar-inverse .nav-collapse .navbar-form,.navbar-inverse .nav-collapse .navbar-search{border-top-color:#111;border-bottom-color:#111}.navbar .nav-collapse .nav.pull-right{float:none;margin-left:0}.nav-collapse,.nav-collapse.collapse{overflow:hidden;height:0}.navbar .btn-navbar{display:block}.navbar-static .navbar-inner{padding-left:10px;padding-right:10px}}@media (min-width:980px){.nav-collapse.collapse{height:auto!important;overflow:visible!important}}", ""]);
	
	// exports


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	/*!
	 * escape-html
	 * Copyright(c) 2012-2013 TJ Holowaychuk
	 * Copyright(c) 2015 Andreas Lubbe
	 * Copyright(c) 2015 Tiancheng "Timothy" Gu
	 * MIT Licensed
	 */
	
	'use strict';
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Module exports.
	 * @public
	 */
	
	module.exports = escapeHtml;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34: // "
	        escape = '&quot;';
	        break;
	      case 38: // &
	        escape = '&amp;';
	        break;
	      case 39: // '
	        escape = '&#39;';
	        break;
	      case 60: // <
	        escape = '&lt;';
	        break;
	      case 62: // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index
	    ? html + str.substring(lastIndex, index)
	    : html;
	}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/*!
	 * jQuery hashchange event - v1.3 - 7/21/2010
	 * http://benalman.com/projects/jquery-hashchange-plugin/
	 *
	 * Copyright (c) 2010 "Cowboy" Ben Alman
	 * Dual licensed under the MIT and GPL licenses.
	 * http://benalman.com/about/license/
	 */
	
	// Script: jQuery hashchange event
	//
	// *Version: 1.3, Last updated: 7/21/2010*
	//
	// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
	// GitHub       - http://github.com/cowboy/jquery-hashchange/
	// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
	// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)
	//
	// About: License
	//
	// Copyright (c) 2010 "Cowboy" Ben Alman,
	// Dual licensed under the MIT and GPL licenses.
	// http://benalman.com/about/license/
	//
	// About: Examples
	//
	// These working examples, complete with fully commented code, illustrate a few
	// ways in which this plugin can be used.
	//
	// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
	// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/
	//
	// About: Support and Testing
	//
	// Information about what version or versions of jQuery this plugin has been
	// tested with, what browsers it has been tested in, and where the unit tests
	// reside (so you can test it yourself).
	//
	// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
	// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
	//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
	// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
	//
	// About: Known issues
	//
	// While this jQuery hashchange event implementation is quite stable and
	// robust, there are a few unfortunate browser bugs surrounding expected
	// hashchange event-based behaviors, independent of any JavaScript
	// window.onhashchange abstraction. See the following examples for more
	// information:
	//
	// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
	// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
	// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
	// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
	//
	// Also note that should a browser natively support the window.onhashchange
	// event, but not report that it does, the fallback polling loop will be used.
	//
	// About: Release History
	//
	// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more
	//         "removable" for mobile-only development. Added IE6/7 document.title
	//         support. Attempted to make Iframe as hidden as possible by using
	//         techniques from http://www.paciellogroup.com/blog/?p=604. Added
	//         support for the "shortcut" format $(window).hashchange( fn ) and
	//         $(window).hashchange() like jQuery provides for built-in events.
	//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and
	//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>
	//         and <jQuery.fn.hashchange.src> properties plus document-domain.html
	//         file to address access denied issues when setting document.domain in
	//         IE6/7.
	// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
	//         from a page on another domain would cause an error in Safari 4. Also,
	//         IE6/7 Iframe is now inserted after the body (this actually works),
	//         which prevents the page from scrolling when the event is first bound.
	//         Event can also now be bound before DOM ready, but it won't be usable
	//         before then in IE6/7.
	// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
	//         where browser version is incorrectly reported as 8.0, despite
	//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
	// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
	//         window.onhashchange functionality into a separate plugin for users
	//         who want just the basic event & back button support, without all the
	//         extra awesomeness that BBQ provides. This plugin will be included as
	//         part of jQuery BBQ, but also be available separately.
	
	(function($,window,undefined){
	  '$:nomunge'; // Used by YUI compressor.
	
	  // Reused string.
	  var str_hashchange = 'hashchange',
	
	    // Method / object references.
	    doc = document,
	    fake_onhashchange,
	    special = $.event.special,
	
	    // Does the browser support window.onhashchange? Note that IE8 running in
	    // IE7 compatibility mode reports true for 'onhashchange' in window, even
	    // though the event isn't supported, so also test document.documentMode.
	    doc_mode = doc.documentMode,
	    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );
	
	  // Get location.hash (or what you'd expect location.hash to be) sans any
	  // leading #. Thanks for making this necessary, Firefox!
	  function get_fragment( url ) {
	    url = url || location.href;
	    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );
	  };
	
	  // Method: jQuery.fn.hashchange
	  //
	  // Bind a handler to the window.onhashchange event or trigger all bound
	  // window.onhashchange event handlers. This behavior is consistent with
	  // jQuery's built-in event handlers.
	  //
	  // Usage:
	  //
	  // > jQuery(window).hashchange( [ handler ] );
	  //
	  // Arguments:
	  //
	  //  handler - (Function) Optional handler to be bound to the hashchange
	  //    event. This is a "shortcut" for the more verbose form:
	  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,
	  //    all bound window.onhashchange event handlers will be triggered. This
	  //    is a shortcut for the more verbose
	  //    jQuery(window).trigger( 'hashchange' ). These forms are described in
	  //    the <hashchange event> section.
	  //
	  // Returns:
	  //
	  //  (jQuery) The initial jQuery collection of elements.
	
	  // Allow the "shortcut" format $(elem).hashchange( fn ) for binding and
	  // $(elem).hashchange() for triggering, like jQuery does for built-in events.
	  $.fn[ str_hashchange ] = function( fn ) {
	    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );
	  };
	
	  // Property: jQuery.fn.hashchange.delay
	  //
	  // The numeric interval (in milliseconds) at which the <hashchange event>
	  // polling loop executes. Defaults to 50.
	
	  // Property: jQuery.fn.hashchange.domain
	  //
	  // If you're setting document.domain in your JavaScript, and you want hash
	  // history to work in IE6/7, not only must this property be set, but you must
	  // also set document.domain BEFORE jQuery is loaded into the page. This
	  // property is only applicable if you are supporting IE6/7 (or IE8 operating
	  // in "IE7 compatibility" mode).
	  //
	  // In addition, the <jQuery.fn.hashchange.src> property must be set to the
	  // path of the included "document-domain.html" file, which can be renamed or
	  // modified if necessary (note that the document.domain specified must be the
	  // same in both your main JavaScript as well as in this file).
	  //
	  // Usage:
	  //
	  // jQuery.fn.hashchange.domain = document.domain;
	
	  // Property: jQuery.fn.hashchange.src
	  //
	  // If, for some reason, you need to specify an Iframe src file (for example,
	  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can
	  // do so using this property. Note that when using this property, history
	  // won't be recorded in IE6/7 until the Iframe src file loads. This property
	  // is only applicable if you are supporting IE6/7 (or IE8 operating in "IE7
	  // compatibility" mode).
	  //
	  // Usage:
	  //
	  // jQuery.fn.hashchange.src = 'path/to/file.html';
	
	  $.fn[ str_hashchange ].delay = 50;
	  /*
	  $.fn[ str_hashchange ].domain = null;
	  $.fn[ str_hashchange ].src = null;
	  */
	
	  // Event: hashchange event
	  //
	  // Fired when location.hash changes. In browsers that support it, the native
	  // HTML5 window.onhashchange event is used, otherwise a polling loop is
	  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to
	  // see if the hash has changed. In IE6/7 (and IE8 operating in "IE7
	  // compatibility" mode), a hidden Iframe is created to allow the back button
	  // and hash-based history to work.
	  //
	  // Usage as described in <jQuery.fn.hashchange>:
	  //
	  // > // Bind an event handler.
	  // > jQuery(window).hashchange( function(e) {
	  // >   var hash = location.hash;
	  // >   ...
	  // > });
	  // >
	  // > // Manually trigger the event handler.
	  // > jQuery(window).hashchange();
	  //
	  // A more verbose usage that allows for event namespacing:
	  //
	  // > // Bind an event handler.
	  // > jQuery(window).bind( 'hashchange', function(e) {
	  // >   var hash = location.hash;
	  // >   ...
	  // > });
	  // >
	  // > // Manually trigger the event handler.
	  // > jQuery(window).trigger( 'hashchange' );
	  //
	  // Additional Notes:
	  //
	  // * The polling loop and Iframe are not created until at least one handler
	  //   is actually bound to the 'hashchange' event.
	  // * If you need the bound handler(s) to execute immediately, in cases where
	  //   a location.hash exists on page load, via bookmark or page refresh for
	  //   example, use jQuery(window).hashchange() or the more verbose
	  //   jQuery(window).trigger( 'hashchange' ).
	  // * The event can be bound before DOM ready, but since it won't be usable
	  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
	  //   to bind it inside a DOM ready handler.
	
	  // Override existing $.event.special.hashchange methods (allowing this plugin
	  // to be defined after jQuery BBQ in BBQ's source code).
	  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {
	
	    // Called only when the first 'hashchange' event is bound to window.
	    setup: function() {
	      // If window.onhashchange is supported natively, there's nothing to do..
	      if ( supports_onhashchange ) { return false; }
	
	      // Otherwise, we need to create our own. And we don't want to call this
	      // until the user binds to the event, just in case they never do, since it
	      // will create a polling loop and possibly even a hidden Iframe.
	      $( fake_onhashchange.start );
	    },
	
	    // Called only when the last 'hashchange' event is unbound from window.
	    teardown: function() {
	      // If window.onhashchange is supported natively, there's nothing to do..
	      if ( supports_onhashchange ) { return false; }
	
	      // Otherwise, we need to stop ours (if possible).
	      $( fake_onhashchange.stop );
	    }
	
	  });
	
	  // fake_onhashchange does all the work of triggering the window.onhashchange
	  // event for browsers that don't natively support it, including creating a
	  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
	  // Iframe to enable back and forward.
	  fake_onhashchange = (function(){
	    var self = {},
	      timeout_id,
	
	      // Remember the initial hash so it doesn't get triggered immediately.
	      last_hash = get_fragment(),
	
	      fn_retval = function(val){ return val; },
	      history_set = fn_retval,
	      history_get = fn_retval;
	
	    // Start the polling loop.
	    self.start = function() {
	      timeout_id || poll();
	    };
	
	    // Stop the polling loop.
	    self.stop = function() {
	      timeout_id && clearTimeout( timeout_id );
	      timeout_id = undefined;
	    };
	
	    // This polling loop checks every $.fn.hashchange.delay milliseconds to see
	    // if location.hash has changed, and triggers the 'hashchange' event on
	    // window when necessary.
	    function poll() {
	      var hash = get_fragment(),
	        history_hash = history_get( last_hash );
	
	      if ( hash !== last_hash ) {
	        history_set( last_hash = hash, history_hash );
	
	        $(window).trigger( str_hashchange );
	
	      } else if ( history_hash !== last_hash ) {
	        location.href = location.href.replace( /#.*/, '' ) + history_hash;
	      }
	
	      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );
	    };
	
	    return self;
	  })();
	
	})(jQuery,this);
	
	}.call(window));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(1);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (kinds, undefined) {
	buf.push("<div class=\"full-screen\"><header><h1>source-map-visualization</h1><p>");
	// iterate kinds
	;(function(){
	  var $$obj = kinds;
	  if ('number' == typeof $$obj.length) {
	
	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var kind = $$obj[$index];
	
	buf.push("<a" + (jade.attr("href", "#"+kind, true, true)) + (jade.attr("data-example", kind, true, true)) + " class=\"btn example\">" + (jade.escape(null == (jade_interp = kind) ? "" : jade_interp)) + "</a>" + (jade.escape(null == (jade_interp = " ") ? "" : jade_interp)));
	    }
	
	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var kind = $$obj[$index];
	
	buf.push("<a" + (jade.attr("href", "#"+kind, true, true)) + (jade.attr("data-example", kind, true, true)) + " class=\"btn example\">" + (jade.escape(null == (jade_interp = kind) ? "" : jade_interp)) + "</a>" + (jade.escape(null == (jade_interp = " ") ? "" : jade_interp)));
	    }
	
	  }
	}).call(this);
	
	buf.push("<a href=\"#custom-choose\" title=\"You can also drag'n'drop all files into this page\" class=\"btn-primary btn custom\">custom...</a>" + (jade.escape(null == (jade_interp = " ") ? "" : jade_interp)) + "<a class=\"custom-link\"></a><button title=\"Minify the generated JS with uglify-js and combine the SourceMaps.\" class=\"btn btn-info js-minify\">minify generated</button></p><small><span>made with ♡ by sokra & paulirish, modified by twitchbronbron. &nbsp;</span><a href=\"https://github.com/twitchbronbron/source-map-visualization/\">repo</a></small></header><main></main><footer></footer><div class=\"custom-modal modal fade hide\"><div class=\"modal-header\"><a data-dismiss=\"modal\" class=\"close\">&times;</a><h3>Custom SourceMap</h3></div><div class=\"modal-body\"></div><div class=\"model-footer\"><div class=\"alert alert-error custom-error hide\"></div></div></div></div>");}.call(this,"kinds" in locals_for_with?locals_for_with.kinds:typeof kinds!=="undefined"?kinds:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(1);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	
	buf.push("<h4>Drag'n'Drop</h4><p>Drop all files anywhere to load them</p><p>The SourceMap must have the extension \".map\", though \".json\" is acceptable if it's the only json file.</p>");;return buf.join("");
	}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(1);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	
	buf.push("<div class=\"alert alert-info\">Note: You can drag 'n drop your generated/map files onto the app.</div><h4>Step 1</h4><p>Provide generated code file:</p><p><input type=\"file\" class=\"input file\"><button class=\"btn btn-primary custom-continue\">Load</button></p>");;return buf.join("");
	}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(1);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (generatedSource) {
	buf.push("<h4>Step 1</h4><p>Provide generated code file:</p><p>Generated code provided. (size=" + (jade.escape(null == (jade_interp = generatedSource.length) ? "" : jade_interp)) + ")</p><h4>Step 2</h4><p>Provide SourceMap file:</p><p><input type=\"file\" class=\"input file\"><button class=\"btn btn-primary custom-continue\">Load</button></p>");}.call(this,"generatedSource" in locals_for_with?locals_for_with.generatedSource:typeof generatedSource!=="undefined"?generatedSource:undefined));;return buf.join("");
	}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(1);
	
	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (generatedSource, source, sourceMap) {
	buf.push("<h4>Step 1</h4><p>Provide generated code file:</p><p>Generated code provided. (size=" + (jade.escape(null == (jade_interp = generatedSource.length) ? "" : jade_interp)) + ")</p><h4>Step 2</h4><p>Provide SourceMap file:</p><p>SourceMap provided. (mappingsSize=" + (jade.escape(null == (jade_interp = sourceMap.mappings.length) ? "" : jade_interp)) + ")</p><h4>Step 3</h4><p>Provide original source file \"<b>" + (jade.escape((jade_interp = source) == null ? '' : jade_interp)) + "</b>\":</p><p><input type=\"file\" class=\"input file\"><button class=\"btn btn-primary custom-continue\">Load</button></p>");}.call(this,"generatedSource" in locals_for_with?locals_for_with.generatedSource:typeof generatedSource!=="undefined"?generatedSource:undefined,"source" in locals_for_with?locals_for_with.source:typeof source!=="undefined"?source:undefined,"sourceMap" in locals_for_with?locals_for_with.sourceMap:typeof sourceMap!=="undefined"?sourceMap:undefined));;return buf.join("");
	}

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	module.exports = {"version":3,"sources":["example"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AACA,IAAI,OAAO,MAAM,GAAN,CAAU;SAAK,IAAI,CAAJ;CAAL,CAAjB;AACJ,IAAI,OAAO,MAAM,GAAN,CAAU,UAAC,CAAD,EAAI,CAAJ;SAAU,IAAI,CAAJ;CAAV,CAAjB;;;AAGJ,KAAK,OAAL,CAAa,aAAK;AAChB,MAAI,IAAI,CAAJ,KAAU,CAAV,EACF,MAAM,IAAN,CAAW,CAAX,EADF;CADW,CAAb;;;AAMA,IAAI,MAAM;AACR,SAAO,KAAP;AACA,YAAU,EAAV;AACA,wCAAe;;;AACb,SAAK,QAAL,CAAc,OAAd,CAAsB;aACpB,QAAQ,GAAR,CAAY,MAAK,KAAL,GAAa,SAAb,GAAyB,CAAzB;KADQ,CAAtB,CADa;GAHP;CAAN;;IAUE;;;AACJ,WADI,WACJ,CAAY,QAAZ,EAAsB,SAAtB,EAAiC;0BAD7B,aAC6B;;wEAD7B,wBAEI,UAAU,YADe;;AAG/B,WAAK,QAAL,GAAgB,YAAY,aAAZ,EAAhB,CAH+B;AAI/B,WAAK,KAAL,GAAa,EAAb,CAJ+B;AAK/B,WAAK,YAAL,GAAoB,EAApB;;AAL+B;GAAjC;;eADI;;2BASG,QAAQ;;AAEb,iCAXE,kDAWF,CAFa;;;;oCAIQ;AACrB,aAAO,IAAI,MAAM,OAAN,EAAX,CADqB;;;;SAbnB;EAAoB,MAAM,IAAN;;AAmB1B,IAAI;;AAEA,aAAW,WAAX;;AAEA,eAAa,aAAb;;AAEA;;AAEA,gCAAW;;AAEV,WAAO,qEAAP,CAFU;;GAKT,UAAU;SAAO;CAAN,EAAX,EAA0B,GAb5B;;;AAkBJ;;;;;;AAOA,IAAI,OAAO,KAAP;IAAc,OAAO,OAAP;AAClB,WAAS,0BAAqB,UAA9B;;;AAGA,OAAO,GAAP;;;AAGA,sBAA2B,GAAO,GAEb,aACN,KACA,IAJf,CAIsB,2BAJtB;;;WAQc,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL;IAAT;IAAI;;AACT,MAAM,CAAN;AACA,MAAM,CAAN;;;;kBAIS;;IADC,gBAAJ;IAAkB,gBAAX,IAAO;IAAc,gBAAL;;;;;mBAKR;;IAAhB;IAAI;IAAK;;;;AAGd,SAAS,CAAT,QAAsB;MAAJ,UAAN,KAAU;;AACpB,UAAQ,GAAR,CAAY,CAAZ,EADoB;CAAtB;AAGA,EAAE,EAAC,MAAM,CAAN,EAAH;;;YAGU;IAAL;;AACL,MAAM,SAAN;;;YAGc;;IAAT,2BAAI;;AACT,MAAM,CAAN;;;AAGA,SAAS,CAAT,QAAmC;MAAvB,YAAuB;MAApB,YAAoB;sBAAjB,EAAiB;MAAjB,4BAAI,aAAa;sBAAT,EAAS;MAAT,4BAAI,aAAK;;AACjC,SAAO,IAAI,CAAJ,GAAQ,CAAR,GAAY,CAAZ,CAD0B;CAAnC;AAGA,EAAE,EAAC,GAAE,CAAF,EAAK,GAAE,CAAF,EAAR,MAAkB,EAAlB;;AAGA,SAAS,CAAT,CAAW,CAAX,EAAoB;MAAN,0DAAE,kBAAI;;;AAElB,SAAO,IAAI,CAAJ,CAFW;CAApB;AAIA,EAAE,CAAF,KAAQ,EAAR;AACA,SAAS,CAAT,CAAW,CAAX,EAAoB;;AAElB,SAAO,0BAAP,CAFkB;CAApB;AAIA,EAAE,CAAF,EAAK,OAAL,EAAc,IAAd,KAAuB,CAAvB;AACA,SAAS,CAAT,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB;AAClB,SAAO,IAAI,CAAJ,GAAQ,CAAR,CADW;CAApB;;AAIA,mBAAK,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAL,KAAiB,CAAjB;;AAGA,SAAS,CAAT,GAAa;AACX;AACE,QAAI,aAAJ,CADF;AAEE;;AAEE,UAAM,MAAI,QAAJ,CAFR;;;AAFF,KAOE,GAAI,KAAJ,CAPF;GADW;CAAb;;AAaA,SAAS,SAAT,CAAmB,CAAnB,EAA+B;AAC3B,eAD2B;;MAAT,4DAAM,iBAAG;AAE3B,MAAI,KAAK,CAAL,EAAQ,OAAO,GAAP,CAAZ;AACA,SAAO,UAAU,IAAI,CAAJ,EAAO,IAAI,GAAJ,CAAxB,CAH2B;CAA/B;;;;AAQA,UAAU,MAAV","file":"example.js","sourcesContent":["// Expression bodies\r\nvar odds = evens.map(v => v + 1);\r\nvar nums = evens.map((v, i) => v + i);\r\n\r\n// Statement bodies\r\nnums.forEach(v => {\r\n  if (v % 5 === 0)\r\n    fives.push(v);\r\n});\r\n\r\n// Lexical this\r\nvar bob = {\r\n  _name: \"Bob\",\r\n  _friends: [],\r\n  printFriends() {\r\n    this._friends.forEach(f =>\r\n      console.log(this._name + \" knows \" + f));\r\n  }\r\n};\r\n\r\n\r\nclass SkinnedMesh extends THREE.Mesh {\r\n  constructor(geometry, materials) {\r\n    super(geometry, materials);\r\n\r\n    this.idMatrix = SkinnedMesh.defaultMatrix();\r\n    this.bones = [];\r\n    this.boneMatrices = [];\r\n    //...\r\n  }\r\n  update(camera) {\r\n    //...\r\n    super.update();\r\n  }\r\n  static defaultMatrix() {\r\n    return new THREE.Matrix4();\r\n  }\r\n}\r\n\r\n\r\nvar obj = {\r\n    // __proto__\r\n    __proto__: theProtoObj,\r\n    // Does not set internal prototype\r\n    '__proto__': somethingElse,\r\n    // Shorthand for ‘handler: handler’\r\n    handler,\r\n    // Methods\r\n    toString() {\r\n     // Super calls\r\n     return \"d \" + super.toString();\r\n    },\r\n    // Computed (dynamic) property names\r\n    [ \"prop_\" + (() => 42)() ]: 42\r\n};\r\n\r\n\r\n// Basic literal string creation\r\n`This is a pretty little template string.`\r\n\r\n// Multiline strings\r\n`In ES5 this is\r\n not legal.`\r\n\r\n// Interpolate variable bindings\r\nvar name = \"Bob\", time = \"today\";\r\n`Hello ${name}, how are you ${time}?`\r\n\r\n// Unescaped template strings\r\nString.raw`In ES5 \"\\n\" is a line-feed.`\r\n\r\n// Construct an HTTP request prefix is used to interpret the replacements and construction\r\nGET`http://foo.org/bar?a=${a}&b=${b}\r\n    Content-Type: application/json\r\n    X-Credentials: ${credentials}\r\n    { \"foo\": ${foo},\r\n      \"bar\": ${bar}}`(myOnReadyStateChangeHandler);\r\n\r\n\r\n// list matching\r\nvar [a, ,b] = [1,2,3];\r\na === 1;\r\nb === 3;\r\n\r\n// object matching\r\nvar { op: a, lhs: { op: b }, rhs: c }\r\n       = getASTNode()\r\n\r\n// object matching shorthand\r\n// binds `op`, `lhs` and `rhs` in scope\r\nvar {op, lhs, rhs} = getASTNode()\r\n\r\n// Can be used in parameter position\r\nfunction g({name: x}) {\r\n  console.log(x);\r\n}\r\ng({name: 5})\r\n\r\n// Fail-soft destructuring\r\nvar [a] = [];\r\na === undefined;\r\n\r\n// Fail-soft destructuring with defaults\r\nvar [a = 1] = [];\r\na === 1;\r\n\r\n// Destructuring + defaults arguments\r\nfunction r({x, y, w = 10, h = 10}) {\r\n  return x + y + w + h;\r\n}\r\nr({x:1, y:2}) === 23\r\n\r\n\r\nfunction f(x, y=12) {\r\n  // y is 12 if not passed (or passed as undefined)\r\n  return x + y;\r\n}\r\nf(3) == 15\r\nfunction f(x, ...y) {\r\n  // y is an Array\r\n  return x * y.length;\r\n}\r\nf(3, \"hello\", true) == 6\r\nfunction f(x, y, z) {\r\n  return x + y + z;\r\n}\r\n// Pass each elem of array as argument\r\nf(...[1,2,3]) == 6\r\n\r\n\r\nfunction f() {\r\n  {\r\n    let x;\r\n    {\r\n      // okay, block scoped name\r\n      const x = \"sneaky\";\r\n    }\r\n    // okay, declared with `let`\r\n    x = \"bar\";\r\n  }\r\n}\r\n\r\n\r\nfunction factorial(n, acc = 1) {\r\n    \"use strict\";\r\n    if (n <= 1) return acc;\r\n    return factorial(n - 1, n * acc);\r\n}\r\n\r\n// Stack overflow in most implementations today,\r\n// but safe on arbitrary inputs in ES2015\r\nfactorial(100000)"]}

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	module.exports = {"version":3,"file":"example.js","sourceRoot":"","sources":["example"],"names":[],"mappings":";AACA,IAAA,sDAAA;EAAA;;AAAA,MAAA,GAAW;;AACX,QAAA,GAAW;;AAGX,IAAgB,QAAhB;EAAA,MAAA,GAAS,CAAC,GAAV;;;AAGA,MAAA,GAAS,SAAC,CAAD;SAAO,CAAA,GAAI;AAAX;;AAGT,IAAA,GAAO,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb;;AAGP,IAAA,GACE;EAAA,IAAA,EAAQ,IAAI,CAAC,IAAb;EACA,MAAA,EAAQ,MADR;EAEA,IAAA,EAAQ,SAAC,CAAD;WAAO,CAAA,GAAI,MAAA,CAAO,CAAP;EAAX,CAFR;;;AAKF,IAAA,GAAO,SAAA;AACL,MAAA;EADM,uBAAQ;SACd,KAAA,CAAM,MAAN,EAAc,OAAd;AADK;;AAIP,IAAsB,8CAAtB;EAAA,KAAA,CAAM,YAAN,EAAA;;;AAGA,KAAA;;AAAS;OAAA,sCAAA;;iBAAA,IAAI,CAAC,IAAL,CAAU,GAAV;AAAA"}

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	module.exports = {"version":3,"file":"looks.css","sources":["looks.scss"],"mappings":"AAsBA,AAAA,CAAC,CAAC;EACA,UAAU,EAAE,UAAW,GACxB;;AAED,AAAA,IAAI,EAAE,AAAA,IAAI,CAAC;EACT,OAAO,EAAE,CAAE;EACX,MAAM,EAAE,CAAE;EACV,MAAM,EAAE,IAAK;EACb,KAAK,EAAE,IAAK;EACZ,WAAW,EAAE,kCAAmC;EAChD,WAAW,EAAE,GAAI;EAEjB,YAAY,EAAE,QAAS;EACvB,KAAK,EAlCS,IAAI,GAmCnB;;AAED,AAAA,IAAI,CAAC;EACH,QAAQ,EAAE,MAAO,GAClB;;AAED,AAAA,IAAI,CAAC;EAxBH,cAAc,EAAE,MAAO;EAbvB,OAAO,EAAE,IAAK;EACd,eAAe,EAAE,UAAW;EAC5B,WAAW,EAAE,OAAQ;EACrB,IAAI,EAAE,CAAE;EAoCR,SAAS,EAAE,MAAO;EAClB,UAAU,EAAE,OAAQ,GACrB;;AAED,AAAA,OAAO,CAAC;EACN,KAAK,EAAE,IAAK;EACZ,UAAU,EAAE,IAAK;EACjB,KAAK,EAnDC,IAAI;EAoDV,UAAU,EAlDU,OAAO;EAmD3B,QAAQ,EAAE,KAAM;EAChB,SAAS,EAAE,IAAK;EAChB,OAAO,EAAE,gBAAiB;EAC1B,WAAW,EAAE,SAAU;EA5CvB,cAAc,EAAE,GAAI;EACpB,SAAS,EAAE,QAAS;EARpB,OAAO,EAAE,IAAK;EACd,eAAe,EAAE,UAAW;EAC5B,WAAW,EAAE,OAAQ;EACrB,IAAI,EAAE,CAAE;EAkDR,UAAU,EAAE,SAAS,CAAC,MAAM,CAAC,2BAAY,CAAa,IAAI;EAC1D,OAAO,EAAE,IAAK,GAoBf;EA/BD,AAaE,OAbK,CAaL,aAAa,CAAC;IACZ,KAAK,EAAE,IAAK;IACZ,MAAM,EAAE,IAAK;IACb,YAAY,EAAE,IAAK;IACnB,WAAW,EAAE,QAAS;IACtB,QAAQ,EAAE,MAAO;IACjB,OAAO,EAAE,IAAK;IACd,UAAU,EAAE,OAAO,CAAC,MAAM,CAAC,2BAAY;IACvC,MAAM,EAAE,IAAK;IACb,OAAO,EAAE,IAAK;IACd,MAAM,EAAE,OAAQ,GACjB;EAxBH,AAyBE,OAzBK,CAyBL,WAAW,CAAC;IACV,UAAU,EAAuC,sCAAC,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,GAC3E;EA3BH,AA4BE,OA5BK,CA4BL,OAAO,CAAC;IACN,UAAU,EAAmC,kCAAC,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,GACvE;;AAGH,AAAA,cAAc,CAAC;EACb,WAAW,EAAE,GAAI;EACjB,SAAS,EAAE,IAAK;EAChB,MAAM,EAAE,CAAE;EACV,IAAI,EAAE,CAAE,GACT;;AAED,AAAA,OAAO,CAAC;EACN,IAAI,EAAE,GAAI;EACV,GAAG,EAAE,GAAI;EACT,QAAQ,EAAE,KAAM;EAChB,SAAS,EAAE,qBAAS,GAwCrB;EA5CD,AAME,OANK,CAML,QAAQ,CAAC;IACP,UAAU,EAAE,UAAW;IACvB,MAAM,EAAE,OAAQ;IAChB,YAAY,EAAE,GAAI;IAClB,gBAAgB,EAAE,GAAI;IAEtB,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,4BAAY,CAAmB,QAAQ,EAC1D,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,GAC9B;;AAED,UAAU,CAAV,MAAU;EAER,AAAA,IAAI;IACF,SAAS,EAAE,SAAM;EAGnB,AAAA,EAAE;IACA,SAAS,EAAE,cAAM;;AAIrB,UAAU,CAAV,IAAU;EACR,AAAA,EAAE;IACA,gBAAgB,EAAE,SAAU;IAC5B,SAAS,EAAE,SAAM;EAGnB,AAAA,GAAG;IACD,gBAAgB,EAAE,eAAgB;IAClC,iBAAiB,EAAE,CAAE;EAGvB,AAAA,IAAI;IACF,gBAAgB,EAAE,SAAU;IAC5B,iBAAiB,EAAE,OAAQ;IAC3B,SAAS,EAAE,aAAM;;AAKvB,AAAA,KAAK,CAAC;EACJ,WAAW,EAAE,IAAK;EAClB,IAAI,EAAE,CAAE;EACR,UAAU,EAAE,MAAO;EACnB,UAAU,EAAE,IAAK;EACjB,0BAA0B,EAAE,KAAM,GACnC;;AAED,AAAA,iBAAiB,CAAC;EAChB,UAAU,EAAE,mBAAI;EAChB,QAAQ,EAAE,KAAM;EAChB,IAAI,EAAE,CAAE;EACR,GAAG,EAAE,CAAE;EACP,KAAK,EAAE,IAAK;EACZ,MAAM,EAAE,IAAK;EACb,OAAO,EAAE,CAAE;EACX,cAAc,EAAE,IAAK;EACrB,WAAW,EAAE,OAAQ;EACrB,UAAU,EAAE,OAAO,CAAC,MAAM,CAAC,2BAAY,GACxC;;AAED,AAAA,0BAA0B,CAAC;EACzB,OAAO,EAAE,CAAE;EACX,cAAc,EAAE,IAAK,GACtB;;AAED,AAAA,OAAO,CAAC;EACN,UAAU,EAAE,IAAK;EACjB,aAAa,EAAE,GAAI;EACnB,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAI,EACb,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAI;EAC5B,SAAS,EAAE,KAAM;EACjB,QAAQ,EAAE,QAAS;EACnB,IAAI,EAAE,GAAI;EACV,GAAG,EAAE,GAAI;EACT,SAAS,EAAE,qBAAS,CAAa,gBAAU;EAC3C,UAAU,EAAE,SAAS,CAAC,MAAM,CAAC,2BAAY,CAAa,KAAK;EAC3D,OAAO,EAAE,IAAK;EACd,SAAS,EAAE,IAAK,GAKjB;EAjBD,AAcE,OAdK,CAcL,MAAM,EAdR,AAcU,OAdH,CAcG,MAAM,CAAC;IACb,SAAS,EAAE,IAAK,GACjB;;AASH,AAAA,KAAK,CAAC;EACJ,OAAO,EAAE,IAAK;EACd,QAAQ,EAAE,QAAS;EACnB,UAAU,EAAE,UAAW;EACvB,UAAU,EAAE,IAAK;EACjB,aAAa,EAAE,GAAI;EACnB,MAAM,EAAE,IAAK;EACb,UAAU,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,kBAAI;EAZ9B,YAAY,EAaW,IAAI;EAZ3B,YAAY,EAYiB,GAAG;EAXhC,YAAY,EAAE,KAAM,GAYrB;;AAED,+CAA+C;AAG/C,AACW,iBADM,CACf,QAAQ,CAAC,KAAK,CAAC;EACb,KAAK,EAJE,IAAI;EAKX,MAAM,EALC,IAAI,GAMZ;;AAJH,AAKU,iBALO,CAKf,OAAO,CAAC,KAAK,CAAC;EACZ,KAAK,EAAE,IAAK;EACZ,MAAM,EAAE,IAAK,GACd;;AARH,AAUE,iBAVe,CAUf,QAAQ,CAAC;EACP,OAAO,EAAE,IAAK,GA4Cf;EAvDH,AAYI,iBAZa,CAUf,QAAQ,CAEN,OAAO,CAAC;IACN,OAAO,EAAE,IAAK;IACd,SAAS,EAAE,GAAI,GAKhB;IAnBL,AAeM,iBAfW,CAUf,QAAQ,CAEN,OAAO,CAGL,MAAM,CAAC;MACL,SAAS,EAAE,KAAM;MACjB,cAAc,EAAE,KAAM,GACvB;EAlBP,AAqBI,iBArBa,CAUf,QAAQ,CAWN,OAAO,EArBX,AAqBa,iBArBI,CAUf,QAAQ,CAWG,YAAY,CAAC;IACpB,SAAS,EAAE,CAAE,GACd;EAvBL,AA0Be,iBA1BE,CAUf,QAAQ,CAgBN,WAAW,AAAA,OAAO,CAAC;IACjB,OAAO,EAAE,cAAe;IACxB,KAAK,EAHI,IAAI,GAId;EA7BL,AA+BS,iBA/BQ,CAUf,QAAQ,CAqBN,KAAK,AAAA,OAAO,CAAC;IACX,OAAO,EAAE,QAAS;IAClB,KAAK,EARI,IAAI,GASd;EAlCL,AAoCW,iBApCM,CAUf,QAAQ,CA0BN,OAAO,AAAA,OAAO,CAAC;IACb,OAAO,EAAE,iBAAkB;IAC3B,KAAK,EAbI,IAAI,GAcd;EAvCL,AAyCa,iBAzCI,CAUf,QAAQ,CA+BN,SAAS,AAAA,OAAO,CAAC;IACf,OAAO,EAAE,YAAa;IACtB,KAAK,EAlBI,IAAI,GAmBd;EA5CL,AA8CW,iBA9CM,CAUf,QAAQ,CAoCN,OAAO,AAAA,OAAO,CAAC;IACb,OAAO,EAAE,gBAAiB;IAC1B,KAAK,EAvBI,IAAI,GAwBd;EAjDL,AAmDW,iBAnDM,CAUf,QAAQ,CAyCN,OAAO,AAAA,OAAO,CAAC;IACb,OAAO,EAAE,SAAU;IACnB,KAAK,EA5BI,IAAI,GA6Bd;;AAtDL,AAyDE,iBAzDe,CAyDf,SAAS,CAAC;EACR,SAAS,EAAE,MAAO,GACnB;;AA3DH,AA4DE,iBA5De,CA4Df,KAAK,EA5DP,AA4DS,iBA5DQ,CA4DR,YAAY,CAAC;EAClB,SAAS,EAAE,KAAM,GAClB;;AA9DH,AAiEE,iBAjEe,CAiEf,OAAO,CAAC;EACN,OAAO,EAAE,IAAK,GAmBf;EArFH,AAoEI,iBApEa,CAiEf,OAAO,CAGL,OAAO,CAAC;IACN,SAAS,EAAE,CAAE;IACb,UAAU,EAAE,MAAO,GAcpB;IApFL,AAwEM,iBAxEW,CAiEf,OAAO,CAGL,OAAO,CAIL,KAAK,CAAC;MACJ,WAAW,EAAE,IAAK;MAClB,YAAY,EAAE,IAAK,GACpB;IA3EP,AA6EM,iBA7EW,CAiEf,OAAO,CAGL,OAAO,CASL,UAAU,EA7EhB,AA6EkB,iBA7ED,CAiEf,OAAO,CAGL,OAAO,CASO,SAAS,CAAC;MACpB,OAAO,EAAE,YAAa,GACvB;IA/EP,AAiFM,iBAjFW,CAiEf,OAAO,CAGL,OAAO,CAaL,SAAS,CAAC;MACR,KAAK,EAAE,IAAK,GACb;;AAnFP,AAuFE,iBAvFe,CAuFf,KAAK,CAAC;EACJ,iBAAiB,EAAE,SAAU;EAC7B,eAAe,EAAE,OAAQ,GAY1B;EArGH,AAuFE,iBAvFe,CAuFf,KAAK,AAGF,UAAU,CAAC;IAAE,gBAAgB,EAAE,wBAAG,GAAyB;EA1FhE,AAuFE,iBAvFe,CAuFf,KAAK,AAIF,YAAY,CAAC;IAAE,gBAAgB,EAAE,wBAAG,GAAyB;EA3FlE,AAuFE,iBAvFe,CAuFf,KAAK,AAKF,KAAK,CAAC;IAAE,gBAAgB,EAAE,uBAAG,GAAwB;EA5F1D,AAuFE,iBAvFe,CAuFf,KAAK,AAMF,KAAK,CAAC;IAAE,gBAAgB,EAAE,uBAAG,GAAwB;EA7F1D,AAuFE,iBAvFe,CAuFf,KAAK,AAOF,MAAM,CAAC;IAAE,gBAAgB,EAAE,wBAAG,GAAyB;EA9F5D,AAuFE,iBAvFe,CAuFf,KAAK,AAQF,KAAK,CAAC;IAAE,gBAAgB,EAAE,uBAAG,GAAwB;EA/F1D,AAuFE,iBAvFe,CAuFf,KAAK,AASF,IAAI,CAAC;IAAE,gBAAgB,EAAE,sBAAG,GAAuB;EAhGxD,AAuFE,iBAvFe,CAuFf,KAAK,AAUF,OAAO,CAAC;IAAE,gBAAgB,EAAE,yBAAG,GAA0B;EAjG9D,AAuFE,iBAvFe,CAuFf,KAAK,AAWF,kBAAkB,CAAC;IAAE,gBAAgB,EAAE,gCAAG,GAAiC;EAlGhF,AAuFE,iBAvFe,CAuFf,KAAK,AAYF,oBAAoB,CAAC;IAAE,gBAAgB,EAAE,gCAAG,GAAiC;EAnGlF,AAuFE,iBAvFe,CAuFf,KAAK,AAaF,cAAc,CAAC;IAAE,gBAAgB,EAAE,gCAAG,GAAiC;;AAI5E,MAAM,EAAL,SAAS,EAAE,KAAK;EACf,AACE,iBADe,CACf,SAAS,CAAC;IACR,SAAS,EAAE,MAAO,GACnB;EAHH,AAIE,iBAJe,CAIf,KAAK,EAJP,AAIS,iBAJQ,CAIR,YAAY,CAAC;IAClB,SAAS,EAAE,KAAM,GAClB;EANH,AAQI,iBARa,CAOf,QAAQ,CACN,OAAO,CAAC;IACN,SAAS,EAAE,GAAI,GAChB;;AAKP,MAAM,EAAL,SAAS,EAAE,KAAK;EACf,AACE,iBADe,CACf,KAAK,EADP,AACS,iBADQ,CACR,YAAY,CAAC;IAClB,SAAS,EAAE,MAAO,GACnB;EAHH,AAIE,iBAJe,CAIf,SAAS,CAAC;IACR,SAAS,EAAE,MAAO,GACnB;EANH,AAQI,iBARa,CAOf,QAAQ,CACN,KAAK,CAAC;IACJ,KAAK,EAAE,KAAM;IACb,MAAM,EAAE,KAAM,GACf;EAXL,AAYI,iBAZa,CAOf,QAAQ,CAKN,OAAO,CAAC;IACN,SAAS,EAAE,GAAI,GAChB;EAdL,AAkBM,iBAlBW,CAgBf,OAAO,CACL,OAAO,CACL,KAAK,CAAC;IACJ,KAAK,EAAE,IAAK;IACZ,MAAM,EAAE,IAAK,GACd;;AAMT,MAAM,EAAL,SAAS,EAAE,MAAM;EAChB,AAAA,KAAK,CAAC;IACJ,OAAO,EAAE,IAAK;IACd,WAAW,EAAE,UAAW;IACxB,SAAS,EAAE,IAAK;IAChB,aAAa,EAAE,UAAW,GAC3B;EAED,AAAA,KAAK,CAAC;IACJ,IAAI,EAAE,QAAS;IACf,SAAS,EAAE,gBAAI,GAChB;;AAKH,AAAA,MAAM,CAAC;EACL,KAAK,EAAE,IAAK;EACZ,MAAM,EAAE,IAAK;EACb,UAAU,EA5WU,OAAO;EA6W3B,QAAQ,EAAE,KAAM;EAChB,SAAS,EAAE,IAAK;EAChB,MAAM,EAAE,CAAE;EACV,WAAW,EAAE,SAAU;EACvB,UAAU,EAAE,SAAS,CAAC,MAAM,CAAC,2BAAY,CAAa,IAAI;EAC1D,OAAO,EAAE,IAAK,GACf","names":[],"sourceRoot":"/sass"}

/***/ }),
/* 34 */
/***/ (function(module, exports) {

	module.exports = {"version":3,"file":"example.js","sourceRoot":"","sources":["example"],"names":[],"mappings":";AAAA,IAAA;;AAAA,MAAA,GAAS,SAAC,CAAD;SAAO,CAAA,GAAI;AAAX;;AACT,IAAA,GAAS,SAAC,CAAD;SAAO,MAAA,CAAO,CAAP,CAAA,GAAY;AAAnB;;AAET,KAAA,CAAM,IAAA,CAAK,CAAL,CAAN"}

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	module.exports = {"version":3,"file":"example.js","sourceRoot":"","sources":["example"],"names":["Sayings","Sayings.Greeter","Sayings.Greeter.constructor","Sayings.Greeter.greet"],"mappings":"AAAA,IAAO,OAAO,CAUb;AAVD,WAAO,OAAO,EAAC,CAAC;IACZA;QAEIC,iBAAYA,OAAeA;YACvBC,IAAIA,CAACA,QAAQA,GAAGA,OAAOA,CAACA;QAC5BA,CAACA;QACDD,uBAAKA,GAALA;YACIE,MAAMA,CAACA,SAASA,GAAGA,IAAIA,CAACA,QAAQA,CAACA;QACrCA,CAACA;QACLF,cAACA;IAADA,CAACA,AARDD,IAQCA;IARYA,eAAOA,UAQnBA,CAAAA;AACLA,CAACA,EAVM,OAAO,KAAP,OAAO,QAUb;AACD,IAAI,OAAO,GAAG,IAAI,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;AAE3C,IAAI,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AAC9C,MAAM,CAAC,SAAS,GAAG,WAAW,CAAC;AAC/B,MAAM,CAAC,OAAO,GAAG;IACb,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;AAC3B,CAAC,CAAC;AAEF,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC"}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

	module.exports = "\"use strict\";\n\nvar _obj;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _templateObject = _taggedTemplateLiteral([\"In ES5 this is\\n not legal.\"], [\"In ES5 this is\\n not legal.\"]),\n    _templateObject2 = _taggedTemplateLiteral([\"In ES5 \\\"\\n\\\" is a line-feed.\"], [\"In ES5 \\\"\\\\n\\\" is a line-feed.\"]),\n    _templateObject3 = _taggedTemplateLiteral([\"http://foo.org/bar?a=\", \"&b=\", \"\\n    Content-Type: application/json\\n    X-Credentials: \", \"\\n    { \\\"foo\\\": \", \",\\n      \\\"bar\\\": \", \"}\"], [\"http://foo.org/bar?a=\", \"&b=\", \"\\n    Content-Type: application/json\\n    X-Credentials: \", \"\\n    { \\\"foo\\\": \", \",\\n      \\\"bar\\\": \", \"}\"]);\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Expression bodies\nvar odds = evens.map(function (v) {\n  return v + 1;\n});\nvar nums = evens.map(function (v, i) {\n  return v + i;\n});\n\n// Statement bodies\nnums.forEach(function (v) {\n  if (v % 5 === 0) fives.push(v);\n});\n\n// Lexical this\nvar bob = {\n  _name: \"Bob\",\n  _friends: [],\n  printFriends: function printFriends() {\n    var _this = this;\n\n    this._friends.forEach(function (f) {\n      return console.log(_this._name + \" knows \" + f);\n    });\n  }\n};\n\nvar SkinnedMesh = function (_THREE$Mesh) {\n  _inherits(SkinnedMesh, _THREE$Mesh);\n\n  function SkinnedMesh(geometry, materials) {\n    _classCallCheck(this, SkinnedMesh);\n\n    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(SkinnedMesh).call(this, geometry, materials));\n\n    _this2.idMatrix = SkinnedMesh.defaultMatrix();\n    _this2.bones = [];\n    _this2.boneMatrices = [];\n    //...\n    return _this2;\n  }\n\n  _createClass(SkinnedMesh, [{\n    key: \"update\",\n    value: function update(camera) {\n      //...\n      _get(Object.getPrototypeOf(SkinnedMesh.prototype), \"update\", this).call(this);\n    }\n  }], [{\n    key: \"defaultMatrix\",\n    value: function defaultMatrix() {\n      return new THREE.Matrix4();\n    }\n  }]);\n\n  return SkinnedMesh;\n}(THREE.Mesh);\n\nvar obj = _obj = _defineProperty({\n  // __proto__\n  __proto__: theProtoObj,\n  // Does not set internal prototype\n  '__proto__': somethingElse,\n  // Shorthand for ‘handler: handler’\n  handler: handler,\n  // Methods\n  toString: function toString() {\n    // Super calls\n    return \"d \" + _get(Object.getPrototypeOf(_obj), \"toString\", this).call(this);\n  }\n}, \"prop_\" + function () {\n  return 42;\n}(), 42);\n\n// Basic literal string creation\n\"This is a pretty little template string.\"\n\n// Multiline strings\n(_templateObject);\n\n// Interpolate variable bindings\nvar name = \"Bob\",\n    time = \"today\";\n\"Hello \" + name + \", how are you \" + time + \"?\";\n\n// Unescaped template strings\nString.raw(_templateObject2);\n\n// Construct an HTTP request prefix is used to interpret the replacements and construction\nGET(_templateObject3, a, b, credentials, foo, bar)(myOnReadyStateChangeHandler);\n\n// list matching\nvar _ref = [1, 2, 3];\nvar a = _ref[0];\nvar b = _ref[2];\n\na === 1;\nb === 3;\n\n// object matching\n\nvar _getASTNode = getASTNode();\n\nvar a = _getASTNode.op;\nvar b = _getASTNode.lhs.op;\nvar c = _getASTNode.rhs;\n\n// object matching shorthand\n// binds `op`, `lhs` and `rhs` in scope\n\nvar _getASTNode2 = getASTNode();\n\nvar op = _getASTNode2.op;\nvar lhs = _getASTNode2.lhs;\nvar rhs = _getASTNode2.rhs;\n\n// Can be used in parameter position\n\nfunction g(_ref2) {\n  var x = _ref2.name;\n\n  console.log(x);\n}\ng({ name: 5 });\n\n// Fail-soft destructuring\nvar _ref3 = [];\nvar a = _ref3[0];\n\na === undefined;\n\n// Fail-soft destructuring with defaults\nvar _ref4 = [];\nvar _ref4$ = _ref4[0];\nvar a = _ref4$ === undefined ? 1 : _ref4$;\n\na === 1;\n\n// Destructuring + defaults arguments\nfunction r(_ref5) {\n  var x = _ref5.x;\n  var y = _ref5.y;\n  var _ref5$w = _ref5.w;\n  var w = _ref5$w === undefined ? 10 : _ref5$w;\n  var _ref5$h = _ref5.h;\n  var h = _ref5$h === undefined ? 10 : _ref5$h;\n\n  return x + y + w + h;\n}\nr({ x: 1, y: 2 }) === 23;\n\nfunction f(x) {\n  var y = arguments.length <= 1 || arguments[1] === undefined ? 12 : arguments[1];\n\n  // y is 12 if not passed (or passed as undefined)\n  return x + y;\n}\nf(3) == 15;\nfunction f(x) {\n  // y is an Array\n  return x * (arguments.length - 1);\n}\nf(3, \"hello\", true) == 6;\nfunction f(x, y, z) {\n  return x + y + z;\n}\n// Pass each elem of array as argument\nf.apply(undefined, [1, 2, 3]) == 6;\n\nfunction f() {\n  {\n    var x = undefined;\n    {\n      // okay, block scoped name\n      var _x2 = \"sneaky\";\n    }\n    // okay, declared with `let`\n    x = \"bar\";\n  }\n}\n\nfunction factorial(n) {\n  \"use strict\";\n\n  var acc = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n  if (n <= 1) return acc;\n  return factorial(n - 1, n * acc);\n}\n\n// Stack overflow in most implementations today,\n// but safe on arbitrary inputs in ES2015\nfactorial(100000);\n\n//# sourceMappingURL=example.js.map"

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	module.exports = "// Generated by CoffeeScript 1.10.0\nvar cubes, list, math, num, number, opposite, race, square,\n  slice = [].slice;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  number = -42;\n}\n\nsquare = function(x) {\n  return x * x;\n};\n\nlist = [1, 2, 3, 4, 5];\n\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\nrace = function() {\n  var runners, winner;\n  winner = arguments[0], runners = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  alert(\"I knew it!\");\n}\n\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n\n//# sourceMappingURL=example.map\n"

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	module.exports = "* {\n  box-sizing: border-box; }\n\nhtml, body {\n  padding: 0;\n  margin: 0;\n  height: 100%;\n  width: 100%;\n  font-family: 'Helvetica', 'Verdana', sans-serif;\n  font-weight: 400;\n  font-display: optional;\n  color: #444; }\n\nhtml {\n  overflow: hidden; }\n\nbody {\n  flex-direction: column;\n  display: flex;\n  justify-content: flex-start;\n  align-items: stretch;\n  flex: 1;\n  flex-wrap: nowrap;\n  background: #ececec; }\n\n.header {\n  width: 100%;\n  min-height: 56px;\n  color: #fff;\n  background: #301e80;\n  position: fixed;\n  font-size: 20px;\n  padding: 16px 16px 0 16px;\n  will-change: transform;\n  flex-direction: row;\n  flex-flow: row wrap;\n  display: flex;\n  justify-content: flex-start;\n  align-items: stretch;\n  flex: 1;\n  transition: transform 0.233s cubic-bezier(0, 0, 0.21, 1) 0.1s;\n  z-index: 1000; }\n  .header .headerButton {\n    width: 24px;\n    height: 24px;\n    margin-right: 16px;\n    text-indent: -30000px;\n    overflow: hidden;\n    opacity: 0.54;\n    transition: opacity 0.333s cubic-bezier(0, 0, 0.21, 1);\n    border: none;\n    outline: none;\n    cursor: pointer; }\n  .header .butRefresh {\n    background: url(/images/ic_refresh_white_24px.svg) center center no-repeat; }\n  .header .butAdd {\n    background: url(/images/ic_add_white_24px.svg) center center no-repeat; }\n\n.header__title {\n  font-weight: 400;\n  font-size: 20px;\n  margin: 0;\n  flex: 1; }\n\n.loader {\n  left: 50%;\n  top: 50%;\n  position: fixed;\n  transform: translate(-50%, -50%); }\n  .loader .spinner {\n    box-sizing: border-box;\n    stroke: #673AB7;\n    stroke-width: 3px;\n    transform-origin: 50%;\n    animation: line 1.6s cubic-bezier(0.4, 0, 0.2, 1) infinite, rotate 1.6s linear infinite; }\n\n@keyframes rotate {\n  from {\n    transform: rotate(0); }\n  to {\n    transform: rotate(450deg); } }\n\n@keyframes line {\n  0% {\n    stroke-dasharray: 2, 85.964;\n    transform: rotate(0); }\n  50% {\n    stroke-dasharray: 65.973, 21.9911;\n    stroke-dashoffset: 0; }\n  100% {\n    stroke-dasharray: 2, 85.964;\n    stroke-dashoffset: -65.973;\n    transform: rotate(90deg); } }\n\n.main {\n  padding-top: 60px;\n  flex: 1;\n  overflow-x: hidden;\n  overflow-y: auto;\n  -webkit-overflow-scrolling: touch; }\n\n.dialog-container {\n  background: rgba(0, 0, 0, 0.57);\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0;\n  pointer-events: none;\n  will-change: opacity;\n  transition: opacity 0.333s cubic-bezier(0, 0, 0.21, 1); }\n\n.dialog-container--visible {\n  opacity: 1;\n  pointer-events: auto; }\n\n.dialog {\n  background: #FFF;\n  border-radius: 2px;\n  box-shadow: 0 0 14px rgba(0, 0, 0, 0.24), 0 14px 28px rgba(0, 0, 0, 0.48);\n  min-width: 280px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%) translateY(30px);\n  transition: transform 0.333s cubic-bezier(0, 0, 0.21, 1) 0.05s;\n  padding: 24px;\n  font-size: 30px; }\n  .dialog select, .dialog button {\n    font-size: 20px; }\n\n.card {\n  padding: 16px;\n  position: relative;\n  box-sizing: border-box;\n  background: #fff;\n  border-radius: 2px;\n  margin: 16px;\n  box-shadow: 0 3px 1px 1px rgba(0, 0, 0, 0.2);\n  border-color: #eee;\n  border-width: 1px;\n  border-style: solid; }\n\n/* TODO: use variable for smaller icon, too. */\n.weather-forecast .current .icon {\n  width: 96px;\n  height: 96px; }\n\n.weather-forecast .future .icon {\n  width: 32px;\n  height: 32px; }\n\n.weather-forecast .current {\n  display: flex; }\n  .weather-forecast .current .visual {\n    display: flex;\n    font-size: 2em; }\n    .weather-forecast .current .visual .scale {\n      font-size: 0.5em;\n      vertical-align: super; }\n  .weather-forecast .current .visual, .weather-forecast .current .description {\n    flex-grow: 1; }\n  .weather-forecast .current .feels-like:before {\n    content: \"Feels like: \";\n    color: #888; }\n  .weather-forecast .current .wind:before {\n    content: \"Wind: \";\n    color: #888; }\n  .weather-forecast .current .precip:before {\n    content: \"Precipitation: \";\n    color: #888; }\n  .weather-forecast .current .humidity:before {\n    content: \"Humidity: \";\n    color: #888; }\n  .weather-forecast .current .pollen:before {\n    content: \"Pollen Count: \";\n    color: #888; }\n  .weather-forecast .current .pcount:before {\n    content: \"Pollen \";\n    color: #888; }\n\n.weather-forecast .location {\n  font-size: 1.35em; }\n\n.weather-forecast .date, .weather-forecast .description {\n  font-size: 0.7em; }\n\n.weather-forecast .future {\n  display: flex; }\n  .weather-forecast .future .oneday {\n    flex-grow: 1;\n    text-align: center; }\n    .weather-forecast .future .oneday .icon {\n      margin-left: auto;\n      margin-right: auto; }\n    .weather-forecast .future .oneday .temp-high, .weather-forecast .future .oneday .temp-low {\n      display: inline-block; }\n    .weather-forecast .future .oneday .temp-low {\n      color: #888; }\n\n.weather-forecast .icon {\n  background-repeat: no-repeat;\n  background-size: contain; }\n  .weather-forecast .icon.clear-day {\n    background-image: url(\"/images/clear.png\"); }\n  .weather-forecast .icon.clear-night {\n    background-image: url(\"/images/clear.png\"); }\n  .weather-forecast .icon.rain {\n    background-image: url(\"/images/rain.png\"); }\n  .weather-forecast .icon.snow {\n    background-image: url(\"/images/snow.png\"); }\n  .weather-forecast .icon.sleet {\n    background-image: url(\"/images/sleet.png\"); }\n  .weather-forecast .icon.wind {\n    background-image: url(\"/images/wind.png\"); }\n  .weather-forecast .icon.fog {\n    background-image: url(\"/images/fog.png\"); }\n  .weather-forecast .icon.cloudy {\n    background-image: url(\"/images/cloudy.png\"); }\n  .weather-forecast .icon.partly-cloudy-day {\n    background-image: url(\"/images/partly-cloudy.png\"); }\n  .weather-forecast .icon.partly-cloudy-night {\n    background-image: url(\"/images/partly-cloudy.png\"); }\n  .weather-forecast .icon.thunderstorms {\n    background-image: url(\"/images/thunderstorms.png\"); }\n\n@media (min-width: 360px) {\n  .weather-forecast .location {\n    font-size: 2.25em; }\n  .weather-forecast .date, .weather-forecast .description {\n    font-size: 0.9em; }\n  .weather-forecast .current .visual {\n    font-size: 3em; } }\n\n@media (min-width: 500px) {\n  .weather-forecast .date, .weather-forecast .description {\n    font-size: 1.25em; }\n  .weather-forecast .location {\n    font-size: 2.45em; }\n  .weather-forecast .current .icon {\n    width: 128px;\n    height: 128px; }\n  .weather-forecast .current .visual {\n    font-size: 4em; }\n  .weather-forecast .future .oneday .icon {\n    width: 64px;\n    height: 64px; } }\n\n@media (min-width: 1015px) {\n  .main {\n    display: flex;\n    align-items: flex-start;\n    flex-wrap: wrap;\n    align-content: flex-start; }\n  .card {\n    flex: 1 1 auto;\n    max-width: calc(50% - 32px); } }\n\nfooter {\n  width: 100%;\n  height: 26px;\n  background: #301e80;\n  position: fixed;\n  font-size: 20px;\n  bottom: 0;\n  will-change: transform;\n  transition: transform 0.233s cubic-bezier(0, 0, 0.21, 1) 0.1s;\n  z-index: 1000; }\n\n/*# sourceMappingURL=looks.css.map */\n"

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	module.exports = "// Generated by CoffeeScript 1.10.0\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n\nalert(cube(5));\n\n//# sourceMappingURL=example.map\n"

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	module.exports = "var Sayings;\n(function (Sayings) {\n    var Greeter = (function () {\n        function Greeter(message) {\n            this.greeting = message;\n        }\n        Greeter.prototype.greet = function () {\n            return \"Hello, \" + this.greeting;\n        };\n        return Greeter;\n    })();\n    Sayings.Greeter = Greeter;\n})(Sayings || (Sayings = {}));\nvar greeter = new Sayings.Greeter(\"world\");\nvar button = document.createElement('button');\nbutton.innerText = \"Say Hello\";\nbutton.onclick = function () {\n    alert(greeter.greet());\n};\ndocument.body.appendChild(button);\n//# sourceMappingURL=example.map"

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	exports.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};
	
	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	exports.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'
	
	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'
	
	  var zero = 48;     // '0'
	  var nine = 57;     // '9'
	
	  var plus = 43;     // '+'
	  var slash = 47;    // '/'
	
	  var littleOffset = 26;
	  var numberOffset = 52;
	
	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }
	
	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }
	
	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }
	
	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }
	
	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }
	
	  // Invalid base64 digit.
	  return -1;
	};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;
	
	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }
	
	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }
	
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}
	
	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }
	
	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }
	
	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }
	
	  return index;
	};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(2);
	
	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	
	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}
	
	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };
	
	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};
	
	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};
	
	exports.MappingList = MappingList;


/***/ }),
/* 44 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.
	
	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}
	
	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}
	
	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.
	
	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.
	
	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;
	
	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];
	
	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }
	
	    swap(ary, i + 1, j);
	    var q = i + 1;
	
	    // (2) Recurse on each half.
	
	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}
	
	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	exports.quickSort = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(2);
	var binarySearch = __webpack_require__(42);
	var ArraySet = __webpack_require__(10).ArraySet;
	var base64VLQ = __webpack_require__(11);
	var quickSort = __webpack_require__(44).quickSort;
	
	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	
	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}
	
	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	}
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;
	
	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.
	
	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	
	    return this.__generatedMappings;
	  }
	});
	
	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	
	    return this.__originalMappings;
	  }
	});
	
	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };
	
	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }
	
	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };
	
	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number is 1-based.
	 *   - column: Optional. the column number in the original source.
	 *    The column number is 0-based.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *    line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *    The column number is 0-based.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');
	
	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };
	
	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }
	
	    var mappings = [];
	
	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	
	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;
	
	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	
	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;
	
	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	
	          mapping = this._originalMappings[++index];
	        }
	      }
	    }
	
	    return mappings;
	  };
	
	exports.SourceMapConsumer = SourceMapConsumer;
	
	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The first parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	
	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);
	
	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	
	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }
	
	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });
	
	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);
	
	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });
	
	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}
	
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	/**
	 * Utility function to find the index of a source.  Returns -1 if not
	 * found.
	 */
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }
	
	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }
	
	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }
	
	  return -1;
	};
	
	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @param String aSourceMapURL
	 *        The URL at which the source map can be found (optional)
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });
	
	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.
	
	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];
	
	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;
	
	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;
	
	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }
	
	        destOriginalMappings.push(destMapping);
	      }
	
	      destGeneratedMappings.push(destMapping);
	    }
	
	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	    return smc;
	  };
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;
	
	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});
	
	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;
	
	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;
	
	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);
	
	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }
	
	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }
	
	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }
	
	          cachedSegments[str] = segment;
	        }
	
	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];
	
	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;
	
	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }
	
	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }
	
	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;
	
	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };
	
	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.
	
	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }
	
	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };
	
	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];
	
	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];
	
	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }
	
	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };
	
	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	
	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	
	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];
	
	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }
	
	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };
	
	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };
	
	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }
	
	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }
	
	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }
	
	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }
	
	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }
	
	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };
	
	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	
	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };
	
	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	
	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }
	
	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };
	
	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The first parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	
	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');
	
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	
	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');
	
	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;
	
	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}
	
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;
	
	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});
	
	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	
	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }
	
	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];
	
	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }
	
	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };
	
	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };
	
	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	
	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };
	
	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based. 
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	
	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }
	
	    return {
	      line: null,
	      column: null
	    };
	  };
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];
	
	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);
	
	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }
	
	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };
	
	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }
	
	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };
	
	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var SourceMapGenerator = __webpack_require__(12).SourceMapGenerator;
	var util = __webpack_require__(2);
	
	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;
	
	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;
	
	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";
	
	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}
	
	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();
	
	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;
	
	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };
	
	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;
	
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }
	
	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });
	
	    return node;
	
	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };
	
	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};
	
	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};
	
	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};
	
	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};
	
	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};
	
	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };
	
	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }
	
	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };
	
	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};
	
	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });
	
	  return { code: generated.code, map: map };
	};
	
	exports.SourceNode = SourceNode;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(22);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/less-loader/index.js!./app.less", function() {
				var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/less-loader/index.js!./app.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(23);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/css-loader/index.js!./bootstrap.css", function() {
				var newContent = require("!!../../../node_modules/css-loader/index.js!./bootstrap.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9bbc6e9602998a385c2ea13df56470fd.png";

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2516339970d710819585f90773aebe0a.png";

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(52);

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	/* ===================================================
	 * bootstrap-transition.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#transitions
	 * ===================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	  /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
	   * ======================================================= */
	
	  $(function () {
	
	    $.support.transition = (function () {
	
	      var transitionEnd = (function () {
	
	        var el = document.createElement('bootstrap')
	          , transEndEventNames = {
	               'WebkitTransition' : 'webkitTransitionEnd'
	            ,  'MozTransition'    : 'transitionend'
	            ,  'OTransition'      : 'oTransitionEnd otransitionend'
	            ,  'transition'       : 'transitionend'
	            }
	          , name
	
	        for (name in transEndEventNames){
	          if (el.style[name] !== undefined) {
	            return transEndEventNames[name]
	          }
	        }
	
	      }())
	
	      return transitionEnd && {
	        end: transitionEnd
	      }
	
	    })()
	
	  })
	
	}(window.jQuery);
	/* =========================================================
	 * bootstrap-modal.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#modals
	 * =========================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================= */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* MODAL CLASS DEFINITION
	  * ====================== */
	
	  var Modal = function (element, options) {
	    this.options = options
	    this.$element = $(element)
	      .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
	    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)
	  }
	
	  Modal.prototype = {
	
	      constructor: Modal
	
	    , toggle: function () {
	        return this[!this.isShown ? 'show' : 'hide']()
	      }
	
	    , show: function () {
	        var that = this
	          , e = $.Event('show')
	
	        this.$element.trigger(e)
	
	        if (this.isShown || e.isDefaultPrevented()) return
	
	        this.isShown = true
	
	        this.escape()
	
	        this.backdrop(function () {
	          var transition = $.support.transition && that.$element.hasClass('fade')
	
	          if (!that.$element.parent().length) {
	            that.$element.appendTo(document.body) //don't move modals dom position
	          }
	
	          that.$element.show()
	
	          if (transition) {
	            that.$element[0].offsetWidth // force reflow
	          }
	
	          that.$element
	            .addClass('in')
	            .attr('aria-hidden', false)
	
	          that.enforceFocus()
	
	          transition ?
	            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :
	            that.$element.focus().trigger('shown')
	
	        })
	      }
	
	    , hide: function (e) {
	        e && e.preventDefault()
	
	        var that = this
	
	        e = $.Event('hide')
	
	        this.$element.trigger(e)
	
	        if (!this.isShown || e.isDefaultPrevented()) return
	
	        this.isShown = false
	
	        this.escape()
	
	        $(document).off('focusin.modal')
	
	        this.$element
	          .removeClass('in')
	          .attr('aria-hidden', true)
	
	        $.support.transition && this.$element.hasClass('fade') ?
	          this.hideWithTransition() :
	          this.hideModal()
	      }
	
	    , enforceFocus: function () {
	        var that = this
	        $(document).on('focusin.modal', function (e) {
	          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
	            that.$element.focus()
	          }
	        })
	      }
	
	    , escape: function () {
	        var that = this
	        if (this.isShown && this.options.keyboard) {
	          this.$element.on('keyup.dismiss.modal', function ( e ) {
	            e.which == 27 && that.hide()
	          })
	        } else if (!this.isShown) {
	          this.$element.off('keyup.dismiss.modal')
	        }
	      }
	
	    , hideWithTransition: function () {
	        var that = this
	          , timeout = setTimeout(function () {
	              that.$element.off($.support.transition.end)
	              that.hideModal()
	            }, 500)
	
	        this.$element.one($.support.transition.end, function () {
	          clearTimeout(timeout)
	          that.hideModal()
	        })
	      }
	
	    , hideModal: function () {
	        var that = this
	        this.$element.hide()
	        this.backdrop(function () {
	          that.removeBackdrop()
	          that.$element.trigger('hidden')
	        })
	      }
	
	    , removeBackdrop: function () {
	        this.$backdrop.remove()
	        this.$backdrop = null
	      }
	
	    , backdrop: function (callback) {
	        var that = this
	          , animate = this.$element.hasClass('fade') ? 'fade' : ''
	
	        if (this.isShown && this.options.backdrop) {
	          var doAnimate = $.support.transition && animate
	
	          this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
	            .appendTo(document.body)
	
	          this.$backdrop.click(
	            this.options.backdrop == 'static' ?
	              $.proxy(this.$element[0].focus, this.$element[0])
	            : $.proxy(this.hide, this)
	          )
	
	          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
	
	          this.$backdrop.addClass('in')
	
	          if (!callback) return
	
	          doAnimate ?
	            this.$backdrop.one($.support.transition.end, callback) :
	            callback()
	
	        } else if (!this.isShown && this.$backdrop) {
	          this.$backdrop.removeClass('in')
	
	          $.support.transition && this.$element.hasClass('fade')?
	            this.$backdrop.one($.support.transition.end, callback) :
	            callback()
	
	        } else if (callback) {
	          callback()
	        }
	      }
	  }
	
	
	 /* MODAL PLUGIN DEFINITION
	  * ======================= */
	
	  var old = $.fn.modal
	
	  $.fn.modal = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('modal')
	        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)
	      if (!data) $this.data('modal', (data = new Modal(this, options)))
	      if (typeof option == 'string') data[option]()
	      else if (options.show) data.show()
	    })
	  }
	
	  $.fn.modal.defaults = {
	      backdrop: true
	    , keyboard: true
	    , show: true
	  }
	
	  $.fn.modal.Constructor = Modal
	
	
	 /* MODAL NO CONFLICT
	  * ================= */
	
	  $.fn.modal.noConflict = function () {
	    $.fn.modal = old
	    return this
	  }
	
	
	 /* MODAL DATA-API
	  * ============== */
	
	  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
	    var $this = $(this)
	      , href = $this.attr('href')
	      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
	      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())
	
	    e.preventDefault()
	
	    $target
	      .modal(option)
	      .one('hide', function () {
	        $this.focus()
	      })
	  })
	
	}(window.jQuery);
	
	/* ============================================================
	 * bootstrap-dropdown.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
	 * ============================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================ */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* DROPDOWN CLASS DEFINITION
	  * ========================= */
	
	  var toggle = '[data-toggle=dropdown]'
	    , Dropdown = function (element) {
	        var $el = $(element).on('click.dropdown.data-api', this.toggle)
	        $('html').on('click.dropdown.data-api', function () {
	          $el.parent().removeClass('open')
	        })
	      }
	
	  Dropdown.prototype = {
	
	    constructor: Dropdown
	
	  , toggle: function (e) {
	      var $this = $(this)
	        , $parent
	        , isActive
	
	      if ($this.is('.disabled, :disabled')) return
	
	      $parent = getParent($this)
	
	      isActive = $parent.hasClass('open')
	
	      clearMenus()
	
	      if (!isActive) {
	        $parent.toggleClass('open')
	      }
	
	      $this.focus()
	
	      return false
	    }
	
	  , keydown: function (e) {
	      var $this
	        , $items
	        , $active
	        , $parent
	        , isActive
	        , index
	
	      if (!/(38|40|27)/.test(e.keyCode)) return
	
	      $this = $(this)
	
	      e.preventDefault()
	      e.stopPropagation()
	
	      if ($this.is('.disabled, :disabled')) return
	
	      $parent = getParent($this)
	
	      isActive = $parent.hasClass('open')
	
	      if (!isActive || (isActive && e.keyCode == 27)) {
	        if (e.which == 27) $parent.find(toggle).focus()
	        return $this.click()
	      }
	
	      $items = $('[role=menu] li:not(.divider):visible a', $parent)
	
	      if (!$items.length) return
	
	      index = $items.index($items.filter(':focus'))
	
	      if (e.keyCode == 38 && index > 0) index--                                        // up
	      if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
	      if (!~index) index = 0
	
	      $items
	        .eq(index)
	        .focus()
	    }
	
	  }
	
	  function clearMenus() {
	    $(toggle).each(function () {
	      getParent($(this)).removeClass('open')
	    })
	  }
	
	  function getParent($this) {
	    var selector = $this.attr('data-target')
	      , $parent
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
	    }
	
	    $parent = selector && $(selector)
	
	    if (!$parent || !$parent.length) $parent = $this.parent()
	
	    return $parent
	  }
	
	
	  /* DROPDOWN PLUGIN DEFINITION
	   * ========================== */
	
	  var old = $.fn.dropdown
	
	  $.fn.dropdown = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('dropdown')
	      if (!data) $this.data('dropdown', (data = new Dropdown(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }
	
	  $.fn.dropdown.Constructor = Dropdown
	
	
	 /* DROPDOWN NO CONFLICT
	  * ==================== */
	
	  $.fn.dropdown.noConflict = function () {
	    $.fn.dropdown = old
	    return this
	  }
	
	
	  /* APPLY TO STANDARD DROPDOWN ELEMENTS
	   * =================================== */
	
	  $(document)
	    .on('click.dropdown.data-api', clearMenus)
	    .on('click.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	    .on('.dropdown-menu', function (e) { e.stopPropagation() })
	    .on('click.dropdown.data-api'  , toggle, Dropdown.prototype.toggle)
	    .on('keydown.dropdown.data-api', toggle + ', [role=menu]' , Dropdown.prototype.keydown)
	
	}(window.jQuery);
	
	/* =============================================================
	 * bootstrap-scrollspy.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#scrollspy
	 * =============================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* SCROLLSPY CLASS DEFINITION
	  * ========================== */
	
	  function ScrollSpy(element, options) {
	    var process = $.proxy(this.process, this)
	      , $element = $(element).is('body') ? $(window) : $(element)
	      , href
	    this.options = $.extend({}, $.fn.scrollspy.defaults, options)
	    this.$scrollElement = $element.on('scroll.scroll-spy.data-api', process)
	    this.selector = (this.options.target
	      || ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
	      || '') + ' .nav li > a'
	    this.$body = $('body')
	    this.refresh()
	    this.process()
	  }
	
	  ScrollSpy.prototype = {
	
	      constructor: ScrollSpy
	
	    , refresh: function () {
	        var self = this
	          , $targets
	
	        this.offsets = $([])
	        this.targets = $([])
	
	        $targets = this.$body
	          .find(this.selector)
	          .map(function () {
	            var $el = $(this)
	              , href = $el.data('target') || $el.attr('href')
	              , $href = /^#\w/.test(href) && $(href)
	            return ( $href
	              && $href.length
	              && [[ $href.position().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ]] ) || null
	          })
	          .sort(function (a, b) { return a[0] - b[0] })
	          .each(function () {
	            self.offsets.push(this[0])
	            self.targets.push(this[1])
	          })
	      }
	
	    , process: function () {
	        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
	          , scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight
	          , maxScroll = scrollHeight - this.$scrollElement.height()
	          , offsets = this.offsets
	          , targets = this.targets
	          , activeTarget = this.activeTarget
	          , i
	
	        if (scrollTop >= maxScroll) {
	          return activeTarget != (i = targets.last()[0])
	            && this.activate ( i )
	        }
	
	        for (i = offsets.length; i--;) {
	          activeTarget != targets[i]
	            && scrollTop >= offsets[i]
	            && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
	            && this.activate( targets[i] )
	        }
	      }
	
	    , activate: function (target) {
	        var active
	          , selector
	
	        this.activeTarget = target
	
	        $(this.selector)
	          .parent('.active')
	          .removeClass('active')
	
	        selector = this.selector
	          + '[data-target="' + target + '"],'
	          + this.selector + '[href="' + target + '"]'
	
	        active = $(selector)
	          .parent('li')
	          .addClass('active')
	
	        if (active.parent('.dropdown-menu').length)  {
	          active = active.closest('li.dropdown').addClass('active')
	        }
	
	        active.trigger('activate')
	      }
	
	  }
	
	
	 /* SCROLLSPY PLUGIN DEFINITION
	  * =========================== */
	
	  var old = $.fn.scrollspy
	
	  $.fn.scrollspy = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('scrollspy')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('scrollspy', (data = new ScrollSpy(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.scrollspy.Constructor = ScrollSpy
	
	  $.fn.scrollspy.defaults = {
	    offset: 10
	  }
	
	
	 /* SCROLLSPY NO CONFLICT
	  * ===================== */
	
	  $.fn.scrollspy.noConflict = function () {
	    $.fn.scrollspy = old
	    return this
	  }
	
	
	 /* SCROLLSPY DATA-API
	  * ================== */
	
	  $(window).on('load', function () {
	    $('[data-spy="scroll"]').each(function () {
	      var $spy = $(this)
	      $spy.scrollspy($spy.data())
	    })
	  })
	
	}(window.jQuery);
	/* ========================================================
	 * bootstrap-tab.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#tabs
	 * ========================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ======================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* TAB CLASS DEFINITION
	  * ==================== */
	
	  var Tab = function (element) {
	    this.element = $(element)
	  }
	
	  Tab.prototype = {
	
	    constructor: Tab
	
	  , show: function () {
	      var $this = this.element
	        , $ul = $this.closest('ul:not(.dropdown-menu)')
	        , selector = $this.attr('data-target')
	        , previous
	        , $target
	        , e
	
	      if (!selector) {
	        selector = $this.attr('href')
	        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
	      }
	
	      if ( $this.parent('li').hasClass('active') ) return
	
	      previous = $ul.find('.active:last a')[0]
	
	      e = $.Event('show', {
	        relatedTarget: previous
	      })
	
	      $this.trigger(e)
	
	      if (e.isDefaultPrevented()) return
	
	      $target = $(selector)
	
	      this.activate($this.parent('li'), $ul)
	      this.activate($target, $target.parent(), function () {
	        $this.trigger({
	          type: 'shown'
	        , relatedTarget: previous
	        })
	      })
	    }
	
	  , activate: function ( element, container, callback) {
	      var $active = container.find('> .active')
	        , transition = callback
	            && $.support.transition
	            && $active.hasClass('fade')
	
	      function next() {
	        $active
	          .removeClass('active')
	          .find('> .dropdown-menu > .active')
	          .removeClass('active')
	
	        element.addClass('active')
	
	        if (transition) {
	          element[0].offsetWidth // reflow for transition
	          element.addClass('in')
	        } else {
	          element.removeClass('fade')
	        }
	
	        if ( element.parent('.dropdown-menu') ) {
	          element.closest('li.dropdown').addClass('active')
	        }
	
	        callback && callback()
	      }
	
	      transition ?
	        $active.one($.support.transition.end, next) :
	        next()
	
	      $active.removeClass('in')
	    }
	  }
	
	
	 /* TAB PLUGIN DEFINITION
	  * ===================== */
	
	  var old = $.fn.tab
	
	  $.fn.tab = function ( option ) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('tab')
	      if (!data) $this.data('tab', (data = new Tab(this)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.tab.Constructor = Tab
	
	
	 /* TAB NO CONFLICT
	  * =============== */
	
	  $.fn.tab.noConflict = function () {
	    $.fn.tab = old
	    return this
	  }
	
	
	 /* TAB DATA-API
	  * ============ */
	
	  $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
	    e.preventDefault()
	    $(this).tab('show')
	  })
	
	}(window.jQuery);
	/* ===========================================================
	 * bootstrap-tooltip.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#tooltips
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ===========================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* TOOLTIP PUBLIC CLASS DEFINITION
	  * =============================== */
	
	  var Tooltip = function (element, options) {
	    this.init('tooltip', element, options)
	  }
	
	  Tooltip.prototype = {
	
	    constructor: Tooltip
	
	  , init: function (type, element, options) {
	      var eventIn
	        , eventOut
	        , triggers
	        , trigger
	        , i
	
	      this.type = type
	      this.$element = $(element)
	      this.options = this.getOptions(options)
	      this.enabled = true
	
	      triggers = this.options.trigger.split(' ')
	
	      for (i = triggers.length; i--;) {
	        trigger = triggers[i]
	        if (trigger == 'click') {
	          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	        } else if (trigger != 'manual') {
	          eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
	          eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
	          this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
	          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	        }
	      }
	
	      this.options.selector ?
	        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	        this.fixTitle()
	    }
	
	  , getOptions: function (options) {
	      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)
	
	      if (options.delay && typeof options.delay == 'number') {
	        options.delay = {
	          show: options.delay
	        , hide: options.delay
	        }
	      }
	
	      return options
	    }
	
	  , enter: function (e) {
	      var self = $(e.currentTarget)[this.type](this._options).data(this.type)
	
	      if (!self.options.delay || !self.options.delay.show) return self.show()
	
	      clearTimeout(this.timeout)
	      self.hoverState = 'in'
	      this.timeout = setTimeout(function() {
	        if (self.hoverState == 'in') self.show()
	      }, self.options.delay.show)
	    }
	
	  , leave: function (e) {
	      var self = $(e.currentTarget)[this.type](this._options).data(this.type)
	
	      if (this.timeout) clearTimeout(this.timeout)
	      if (!self.options.delay || !self.options.delay.hide) return self.hide()
	
	      self.hoverState = 'out'
	      this.timeout = setTimeout(function() {
	        if (self.hoverState == 'out') self.hide()
	      }, self.options.delay.hide)
	    }
	
	  , show: function () {
	      var $tip
	        , pos
	        , actualWidth
	        , actualHeight
	        , placement
	        , tp
	        , e = $.Event('show')
	
	      if (this.hasContent() && this.enabled) {
	        this.$element.trigger(e)
	        if (e.isDefaultPrevented()) return
	        $tip = this.tip()
	        this.setContent()
	
	        if (this.options.animation) {
	          $tip.addClass('fade')
	        }
	
	        placement = typeof this.options.placement == 'function' ?
	          this.options.placement.call(this, $tip[0], this.$element[0]) :
	          this.options.placement
	
	        $tip
	          .detach()
	          .css({ top: 0, left: 0, display: 'block' })
	
	        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
	
	        pos = this.getPosition()
	
	        actualWidth = $tip[0].offsetWidth
	        actualHeight = $tip[0].offsetHeight
	
	        switch (placement) {
	          case 'bottom':
	            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
	            break
	          case 'top':
	            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
	            break
	          case 'left':
	            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
	            break
	          case 'right':
	            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
	            break
	        }
	
	        this.applyPlacement(tp, placement)
	        this.$element.trigger('shown')
	      }
	    }
	
	  , applyPlacement: function(offset, placement){
	      var $tip = this.tip()
	        , width = $tip[0].offsetWidth
	        , height = $tip[0].offsetHeight
	        , actualWidth
	        , actualHeight
	        , delta
	        , replace
	
	      $tip
	        .offset(offset)
	        .addClass(placement)
	        .addClass('in')
	
	      actualWidth = $tip[0].offsetWidth
	      actualHeight = $tip[0].offsetHeight
	
	      if (placement == 'top' && actualHeight != height) {
	        offset.top = offset.top + height - actualHeight
	        replace = true
	      }
	
	      if (placement == 'bottom' || placement == 'top') {
	        delta = 0
	
	        if (offset.left < 0){
	          delta = offset.left * -2
	          offset.left = 0
	          $tip.offset(offset)
	          actualWidth = $tip[0].offsetWidth
	          actualHeight = $tip[0].offsetHeight
	        }
	
	        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
	      } else {
	        this.replaceArrow(actualHeight - height, actualHeight, 'top')
	      }
	
	      if (replace) $tip.offset(offset)
	    }
	
	  , replaceArrow: function(delta, dimension, position){
	      this
	        .arrow()
	        .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
	    }
	
	  , setContent: function () {
	      var $tip = this.tip()
	        , title = this.getTitle()
	
	      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	      $tip.removeClass('fade in top bottom left right')
	    }
	
	  , hide: function () {
	      var that = this
	        , $tip = this.tip()
	        , e = $.Event('hide')
	
	      this.$element.trigger(e)
	      if (e.isDefaultPrevented()) return
	
	      $tip.removeClass('in')
	
	      function removeWithAnimation() {
	        var timeout = setTimeout(function () {
	          $tip.off($.support.transition.end).detach()
	        }, 500)
	
	        $tip.one($.support.transition.end, function () {
	          clearTimeout(timeout)
	          $tip.detach()
	        })
	      }
	
	      $.support.transition && this.$tip.hasClass('fade') ?
	        removeWithAnimation() :
	        $tip.detach()
	
	      this.$element.trigger('hidden')
	
	      return this
	    }
	
	  , fixTitle: function () {
	      var $e = this.$element
	      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
	        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	      }
	    }
	
	  , hasContent: function () {
	      return this.getTitle()
	    }
	
	  , getPosition: function () {
	      var el = this.$element[0]
	      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
	        width: el.offsetWidth
	      , height: el.offsetHeight
	      }, this.$element.offset())
	    }
	
	  , getTitle: function () {
	      var title
	        , $e = this.$element
	        , o = this.options
	
	      title = $e.attr('data-original-title')
	        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)
	
	      return title
	    }
	
	  , tip: function () {
	      return this.$tip = this.$tip || $(this.options.template)
	    }
	
	  , arrow: function(){
	      return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
	    }
	
	  , validate: function () {
	      if (!this.$element[0].parentNode) {
	        this.hide()
	        this.$element = null
	        this.options = null
	      }
	    }
	
	  , enable: function () {
	      this.enabled = true
	    }
	
	  , disable: function () {
	      this.enabled = false
	    }
	
	  , toggleEnabled: function () {
	      this.enabled = !this.enabled
	    }
	
	  , toggle: function (e) {
	      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
	      self.tip().hasClass('in') ? self.hide() : self.show()
	    }
	
	  , destroy: function () {
	      this.hide().$element.off('.' + this.type).removeData(this.type)
	    }
	
	  }
	
	
	 /* TOOLTIP PLUGIN DEFINITION
	  * ========================= */
	
	  var old = $.fn.tooltip
	
	  $.fn.tooltip = function ( option ) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('tooltip')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.tooltip.Constructor = Tooltip
	
	  $.fn.tooltip.defaults = {
	    animation: true
	  , placement: 'top'
	  , selector: false
	  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
	  , trigger: 'hover focus'
	  , title: ''
	  , delay: 0
	  , html: false
	  , container: false
	  }
	
	
	 /* TOOLTIP NO CONFLICT
	  * =================== */
	
	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }
	
	}(window.jQuery);
	
	/* ===========================================================
	 * bootstrap-popover.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#popovers
	 * ===========================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * =========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* POPOVER PUBLIC CLASS DEFINITION
	  * =============================== */
	
	  var Popover = function (element, options) {
	    this.init('popover', element, options)
	  }
	
	
	  /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
	     ========================================== */
	
	  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {
	
	    constructor: Popover
	
	  , setContent: function () {
	      var $tip = this.tip()
	        , title = this.getTitle()
	        , content = this.getContent()
	
	      $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	      $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)
	
	      $tip.removeClass('fade top bottom left right in')
	    }
	
	  , hasContent: function () {
	      return this.getTitle() || this.getContent()
	    }
	
	  , getContent: function () {
	      var content
	        , $e = this.$element
	        , o = this.options
	
	      content = (typeof o.content == 'function' ? o.content.call($e[0]) :  o.content)
	        || $e.attr('data-content')
	
	      return content
	    }
	
	  , tip: function () {
	      if (!this.$tip) {
	        this.$tip = $(this.options.template)
	      }
	      return this.$tip
	    }
	
	  , destroy: function () {
	      this.hide().$element.off('.' + this.type).removeData(this.type)
	    }
	
	  })
	
	
	 /* POPOVER PLUGIN DEFINITION
	  * ======================= */
	
	  var old = $.fn.popover
	
	  $.fn.popover = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('popover')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('popover', (data = new Popover(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.popover.Constructor = Popover
	
	  $.fn.popover.defaults = $.extend({} , $.fn.tooltip.defaults, {
	    placement: 'right'
	  , trigger: 'click'
	  , content: ''
	  , template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	  })
	
	
	 /* POPOVER NO CONFLICT
	  * =================== */
	
	  $.fn.popover.noConflict = function () {
	    $.fn.popover = old
	    return this
	  }
	
	}(window.jQuery);
	
	/* ==========================================================
	 * bootstrap-affix.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#affix
	 * ==========================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* AFFIX CLASS DEFINITION
	  * ====================== */
	
	  var Affix = function (element, options) {
	    this.options = $.extend({}, $.fn.affix.defaults, options)
	    this.$window = $(window)
	      .on('scroll.affix.data-api', $.proxy(this.checkPosition, this))
	      .on('click.affix.data-api',  $.proxy(function () { setTimeout($.proxy(this.checkPosition, this), 1) }, this))
	    this.$element = $(element)
	    this.checkPosition()
	  }
	
	  Affix.prototype.checkPosition = function () {
	    if (!this.$element.is(':visible')) return
	
	    var scrollHeight = $(document).height()
	      , scrollTop = this.$window.scrollTop()
	      , position = this.$element.offset()
	      , offset = this.options.offset
	      , offsetBottom = offset.bottom
	      , offsetTop = offset.top
	      , reset = 'affix affix-top affix-bottom'
	      , affix
	
	    if (typeof offset != 'object') offsetBottom = offsetTop = offset
	    if (typeof offsetTop == 'function') offsetTop = offset.top()
	    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()
	
	    affix = this.unpin != null && (scrollTop + this.unpin <= position.top) ?
	      false    : offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ?
	      'bottom' : offsetTop != null && scrollTop <= offsetTop ?
	      'top'    : false
	
	    if (this.affixed === affix) return
	
	    this.affixed = affix
	    this.unpin = affix == 'bottom' ? position.top - scrollTop : null
	
	    this.$element.removeClass(reset).addClass('affix' + (affix ? '-' + affix : ''))
	  }
	
	
	 /* AFFIX PLUGIN DEFINITION
	  * ======================= */
	
	  var old = $.fn.affix
	
	  $.fn.affix = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('affix')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('affix', (data = new Affix(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.affix.Constructor = Affix
	
	  $.fn.affix.defaults = {
	    offset: 0
	  }
	
	
	 /* AFFIX NO CONFLICT
	  * ================= */
	
	  $.fn.affix.noConflict = function () {
	    $.fn.affix = old
	    return this
	  }
	
	
	 /* AFFIX DATA-API
	  * ============== */
	
	  $(window).on('load', function () {
	    $('[data-spy="affix"]').each(function () {
	      var $spy = $(this)
	        , data = $spy.data()
	
	      data.offset = data.offset || {}
	
	      data.offsetBottom && (data.offset.bottom = data.offsetBottom)
	      data.offsetTop && (data.offset.top = data.offsetTop)
	
	      $spy.affix(data)
	    })
	  })
	
	
	}(window.jQuery);
	/* ==========================================================
	 * bootstrap-alert.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#alerts
	 * ==========================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* ALERT CLASS DEFINITION
	  * ====================== */
	
	  var dismiss = '[data-dismiss="alert"]'
	    , Alert = function (el) {
	        $(el).on('click', dismiss, this.close)
	      }
	
	  Alert.prototype.close = function (e) {
	    var $this = $(this)
	      , selector = $this.attr('data-target')
	      , $parent
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
	    }
	
	    $parent = $(selector)
	
	    e && e.preventDefault()
	
	    $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())
	
	    $parent.trigger(e = $.Event('close'))
	
	    if (e.isDefaultPrevented()) return
	
	    $parent.removeClass('in')
	
	    function removeElement() {
	      $parent
	        .trigger('closed')
	        .remove()
	    }
	
	    $.support.transition && $parent.hasClass('fade') ?
	      $parent.on($.support.transition.end, removeElement) :
	      removeElement()
	  }
	
	
	 /* ALERT PLUGIN DEFINITION
	  * ======================= */
	
	  var old = $.fn.alert
	
	  $.fn.alert = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('alert')
	      if (!data) $this.data('alert', (data = new Alert(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }
	
	  $.fn.alert.Constructor = Alert
	
	
	 /* ALERT NO CONFLICT
	  * ================= */
	
	  $.fn.alert.noConflict = function () {
	    $.fn.alert = old
	    return this
	  }
	
	
	 /* ALERT DATA-API
	  * ============== */
	
	  $(document).on('click.alert.data-api', dismiss, Alert.prototype.close)
	
	}(window.jQuery);
	/* ============================================================
	 * bootstrap-button.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#buttons
	 * ============================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================ */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* BUTTON PUBLIC CLASS DEFINITION
	  * ============================== */
	
	  var Button = function (element, options) {
	    this.$element = $(element)
	    this.options = $.extend({}, $.fn.button.defaults, options)
	  }
	
	  Button.prototype.setState = function (state) {
	    var d = 'disabled'
	      , $el = this.$element
	      , data = $el.data()
	      , val = $el.is('input') ? 'val' : 'html'
	
	    state = state + 'Text'
	    data.resetText || $el.data('resetText', $el[val]())
	
	    $el[val](data[state] || this.options[state])
	
	    // push to event loop to allow forms to submit
	    setTimeout(function () {
	      state == 'loadingText' ?
	        $el.addClass(d).attr(d, d) :
	        $el.removeClass(d).removeAttr(d)
	    }, 0)
	  }
	
	  Button.prototype.toggle = function () {
	    var $parent = this.$element.closest('[data-toggle="buttons-radio"]')
	
	    $parent && $parent
	      .find('.active')
	      .removeClass('active')
	
	    this.$element.toggleClass('active')
	  }
	
	
	 /* BUTTON PLUGIN DEFINITION
	  * ======================== */
	
	  var old = $.fn.button
	
	  $.fn.button = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('button')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('button', (data = new Button(this, options)))
	      if (option == 'toggle') data.toggle()
	      else if (option) data.setState(option)
	    })
	  }
	
	  $.fn.button.defaults = {
	    loadingText: 'loading...'
	  }
	
	  $.fn.button.Constructor = Button
	
	
	 /* BUTTON NO CONFLICT
	  * ================== */
	
	  $.fn.button.noConflict = function () {
	    $.fn.button = old
	    return this
	  }
	
	
	 /* BUTTON DATA-API
	  * =============== */
	
	  $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) {
	    var $btn = $(e.target)
	    if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
	    $btn.button('toggle')
	  })
	
	}(window.jQuery);
	/* =============================================================
	 * bootstrap-collapse.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#collapse
	 * =============================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================ */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* COLLAPSE PUBLIC CLASS DEFINITION
	  * ================================ */
	
	  var Collapse = function (element, options) {
	    this.$element = $(element)
	    this.options = $.extend({}, $.fn.collapse.defaults, options)
	
	    if (this.options.parent) {
	      this.$parent = $(this.options.parent)
	    }
	
	    this.options.toggle && this.toggle()
	  }
	
	  Collapse.prototype = {
	
	    constructor: Collapse
	
	  , dimension: function () {
	      var hasWidth = this.$element.hasClass('width')
	      return hasWidth ? 'width' : 'height'
	    }
	
	  , show: function () {
	      var dimension
	        , scroll
	        , actives
	        , hasData
	
	      if (this.transitioning || this.$element.hasClass('in')) return
	
	      dimension = this.dimension()
	      scroll = $.camelCase(['scroll', dimension].join('-'))
	      actives = this.$parent && this.$parent.find('> .accordion-group > .in')
	
	      if (actives && actives.length) {
	        hasData = actives.data('collapse')
	        if (hasData && hasData.transitioning) return
	        actives.collapse('hide')
	        hasData || actives.data('collapse', null)
	      }
	
	      this.$element[dimension](0)
	      this.transition('addClass', $.Event('show'), 'shown')
	      $.support.transition && this.$element[dimension](this.$element[0][scroll])
	    }
	
	  , hide: function () {
	      var dimension
	      if (this.transitioning || !this.$element.hasClass('in')) return
	      dimension = this.dimension()
	      this.reset(this.$element[dimension]())
	      this.transition('removeClass', $.Event('hide'), 'hidden')
	      this.$element[dimension](0)
	    }
	
	  , reset: function (size) {
	      var dimension = this.dimension()
	
	      this.$element
	        .removeClass('collapse')
	        [dimension](size || 'auto')
	        [0].offsetWidth
	
	      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse')
	
	      return this
	    }
	
	  , transition: function (method, startEvent, completeEvent) {
	      var that = this
	        , complete = function () {
	            if (startEvent.type == 'show') that.reset()
	            that.transitioning = 0
	            that.$element.trigger(completeEvent)
	          }
	
	      this.$element.trigger(startEvent)
	
	      if (startEvent.isDefaultPrevented()) return
	
	      this.transitioning = 1
	
	      this.$element[method]('in')
	
	      $.support.transition && this.$element.hasClass('collapse') ?
	        this.$element.one($.support.transition.end, complete) :
	        complete()
	    }
	
	  , toggle: function () {
	      this[this.$element.hasClass('in') ? 'hide' : 'show']()
	    }
	
	  }
	
	
	 /* COLLAPSE PLUGIN DEFINITION
	  * ========================== */
	
	  var old = $.fn.collapse
	
	  $.fn.collapse = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('collapse')
	        , options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option)
	      if (!data) $this.data('collapse', (data = new Collapse(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.collapse.defaults = {
	    toggle: true
	  }
	
	  $.fn.collapse.Constructor = Collapse
	
	
	 /* COLLAPSE NO CONFLICT
	  * ==================== */
	
	  $.fn.collapse.noConflict = function () {
	    $.fn.collapse = old
	    return this
	  }
	
	
	 /* COLLAPSE DATA-API
	  * ================= */
	
	  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
	    var $this = $(this), href
	      , target = $this.attr('data-target')
	        || e.preventDefault()
	        || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
	      , option = $(target).data('collapse') ? 'toggle' : $this.data()
	    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
	    $(target).collapse(option)
	  })
	
	}(window.jQuery);
	/* ==========================================================
	 * bootstrap-carousel.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#carousel
	 * ==========================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================== */
	
	
	!function ($) {
	
	  "use strict"; // jshint ;_;
	
	
	 /* CAROUSEL CLASS DEFINITION
	  * ========================= */
	
	  var Carousel = function (element, options) {
	    this.$element = $(element)
	    this.$indicators = this.$element.find('.carousel-indicators')
	    this.options = options
	    this.options.pause == 'hover' && this.$element
	      .on('mouseenter', $.proxy(this.pause, this))
	      .on('mouseleave', $.proxy(this.cycle, this))
	  }
	
	  Carousel.prototype = {
	
	    cycle: function (e) {
	      if (!e) this.paused = false
	      if (this.interval) clearInterval(this.interval);
	      this.options.interval
	        && !this.paused
	        && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
	      return this
	    }
	
	  , getActiveIndex: function () {
	      this.$active = this.$element.find('.item.active')
	      this.$items = this.$active.parent().children()
	      return this.$items.index(this.$active)
	    }
	
	  , to: function (pos) {
	      var activeIndex = this.getActiveIndex()
	        , that = this
	
	      if (pos > (this.$items.length - 1) || pos < 0) return
	
	      if (this.sliding) {
	        return this.$element.one('slid', function () {
	          that.to(pos)
	        })
	      }
	
	      if (activeIndex == pos) {
	        return this.pause().cycle()
	      }
	
	      return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
	    }
	
	  , pause: function (e) {
	      if (!e) this.paused = true
	      if (this.$element.find('.next, .prev').length && $.support.transition.end) {
	        this.$element.trigger($.support.transition.end)
	        this.cycle()
	      }
	      clearInterval(this.interval)
	      this.interval = null
	      return this
	    }
	
	  , next: function () {
	      if (this.sliding) return
	      return this.slide('next')
	    }
	
	  , prev: function () {
	      if (this.sliding) return
	      return this.slide('prev')
	    }
	
	  , slide: function (type, next) {
	      var $active = this.$element.find('.item.active')
	        , $next = next || $active[type]()
	        , isCycling = this.interval
	        , direction = type == 'next' ? 'left' : 'right'
	        , fallback  = type == 'next' ? 'first' : 'last'
	        , that = this
	        , e
	
	      this.sliding = true
	
	      isCycling && this.pause()
	
	      $next = $next.length ? $next : this.$element.find('.item')[fallback]()
	
	      e = $.Event('slide', {
	        relatedTarget: $next[0]
	      , direction: direction
	      })
	
	      if ($next.hasClass('active')) return
	
	      if (this.$indicators.length) {
	        this.$indicators.find('.active').removeClass('active')
	        this.$element.one('slid', function () {
	          var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()])
	          $nextIndicator && $nextIndicator.addClass('active')
	        })
	      }
	
	      if ($.support.transition && this.$element.hasClass('slide')) {
	        this.$element.trigger(e)
	        if (e.isDefaultPrevented()) return
	        $next.addClass(type)
	        $next[0].offsetWidth // force reflow
	        $active.addClass(direction)
	        $next.addClass(direction)
	        this.$element.one($.support.transition.end, function () {
	          $next.removeClass([type, direction].join(' ')).addClass('active')
	          $active.removeClass(['active', direction].join(' '))
	          that.sliding = false
	          setTimeout(function () { that.$element.trigger('slid') }, 0)
	        })
	      } else {
	        this.$element.trigger(e)
	        if (e.isDefaultPrevented()) return
	        $active.removeClass('active')
	        $next.addClass('active')
	        this.sliding = false
	        this.$element.trigger('slid')
	      }
	
	      isCycling && this.cycle()
	
	      return this
	    }
	
	  }
	
	
	 /* CAROUSEL PLUGIN DEFINITION
	  * ========================== */
	
	  var old = $.fn.carousel
	
	  $.fn.carousel = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('carousel')
	        , options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option)
	        , action = typeof option == 'string' ? option : options.slide
	      if (!data) $this.data('carousel', (data = new Carousel(this, options)))
	      if (typeof option == 'number') data.to(option)
	      else if (action) data[action]()
	      else if (options.interval) data.pause().cycle()
	    })
	  }
	
	  $.fn.carousel.defaults = {
	    interval: 5000
	  , pause: 'hover'
	  }
	
	  $.fn.carousel.Constructor = Carousel
	
	
	 /* CAROUSEL NO CONFLICT
	  * ==================== */
	
	  $.fn.carousel.noConflict = function () {
	    $.fn.carousel = old
	    return this
	  }
	
	 /* CAROUSEL DATA-API
	  * ================= */
	
	  $(document).on('click.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
	    var $this = $(this), href
	      , $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
	      , options = $.extend({}, $target.data(), $this.data())
	      , slideIndex
	
	    $target.carousel(options)
	
	    if (slideIndex = $this.attr('data-slide-to')) {
	      $target.data('carousel').pause().to(slideIndex).cycle()
	    }
	
	    e.preventDefault()
	  })
	
	}(window.jQuery);
	/* =============================================================
	 * bootstrap-typeahead.js v2.3.0
	 * http://twitter.github.com/bootstrap/javascript.html#typeahead
	 * =============================================================
	 * Copyright 2012 Twitter, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ============================================================ */
	
	
	!function($){
	
	  "use strict"; // jshint ;_;
	
	
	 /* TYPEAHEAD PUBLIC CLASS DEFINITION
	  * ================================= */
	
	  var Typeahead = function (element, options) {
	    this.$element = $(element)
	    this.options = $.extend({}, $.fn.typeahead.defaults, options)
	    this.matcher = this.options.matcher || this.matcher
	    this.sorter = this.options.sorter || this.sorter
	    this.highlighter = this.options.highlighter || this.highlighter
	    this.updater = this.options.updater || this.updater
	    this.source = this.options.source
	    this.$menu = $(this.options.menu)
	    this.shown = false
	    this.listen()
	  }
	
	  Typeahead.prototype = {
	
	    constructor: Typeahead
	
	  , select: function () {
	      var val = this.$menu.find('.active').attr('data-value')
	      this.$element
	        .val(this.updater(val))
	        .change()
	      return this.hide()
	    }
	
	  , updater: function (item) {
	      return item
	    }
	
	  , show: function () {
	      var pos = $.extend({}, this.$element.position(), {
	        height: this.$element[0].offsetHeight
	      })
	
	      this.$menu
	        .insertAfter(this.$element)
	        .css({
	          top: pos.top + pos.height
	        , left: pos.left
	        })
	        .show()
	
	      this.shown = true
	      return this
	    }
	
	  , hide: function () {
	      this.$menu.hide()
	      this.shown = false
	      return this
	    }
	
	  , lookup: function (event) {
	      var items
	
	      this.query = this.$element.val()
	
	      if (!this.query || this.query.length < this.options.minLength) {
	        return this.shown ? this.hide() : this
	      }
	
	      items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source
	
	      return items ? this.process(items) : this
	    }
	
	  , process: function (items) {
	      var that = this
	
	      items = $.grep(items, function (item) {
	        return that.matcher(item)
	      })
	
	      items = this.sorter(items)
	
	      if (!items.length) {
	        return this.shown ? this.hide() : this
	      }
	
	      return this.render(items.slice(0, this.options.items)).show()
	    }
	
	  , matcher: function (item) {
	      return ~item.toLowerCase().indexOf(this.query.toLowerCase())
	    }
	
	  , sorter: function (items) {
	      var beginswith = []
	        , caseSensitive = []
	        , caseInsensitive = []
	        , item
	
	      while (item = items.shift()) {
	        if (!item.toLowerCase().indexOf(this.query.toLowerCase())) beginswith.push(item)
	        else if (~item.indexOf(this.query)) caseSensitive.push(item)
	        else caseInsensitive.push(item)
	      }
	
	      return beginswith.concat(caseSensitive, caseInsensitive)
	    }
	
	  , highlighter: function (item) {
	      var query = this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
	      return item.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) {
	        return '<strong>' + match + '</strong>'
	      })
	    }
	
	  , render: function (items) {
	      var that = this
	
	      items = $(items).map(function (i, item) {
	        i = $(that.options.item).attr('data-value', item)
	        i.find('a').html(that.highlighter(item))
	        return i[0]
	      })
	
	      items.first().addClass('active')
	      this.$menu.html(items)
	      return this
	    }
	
	  , next: function (event) {
	      var active = this.$menu.find('.active').removeClass('active')
	        , next = active.next()
	
	      if (!next.length) {
	        next = $(this.$menu.find('li')[0])
	      }
	
	      next.addClass('active')
	    }
	
	  , prev: function (event) {
	      var active = this.$menu.find('.active').removeClass('active')
	        , prev = active.prev()
	
	      if (!prev.length) {
	        prev = this.$menu.find('li').last()
	      }
	
	      prev.addClass('active')
	    }
	
	  , listen: function () {
	      this.$element
	        .on('focus',    $.proxy(this.focus, this))
	        .on('blur',     $.proxy(this.blur, this))
	        .on('keypress', $.proxy(this.keypress, this))
	        .on('keyup',    $.proxy(this.keyup, this))
	
	      if (this.eventSupported('keydown')) {
	        this.$element.on('keydown', $.proxy(this.keydown, this))
	      }
	
	      this.$menu
	        .on('click', $.proxy(this.click, this))
	        .on('mouseenter', 'li', $.proxy(this.mouseenter, this))
	        .on('mouseleave', 'li', $.proxy(this.mouseleave, this))
	    }
	
	  , eventSupported: function(eventName) {
	      var isSupported = eventName in this.$element
	      if (!isSupported) {
	        this.$element.setAttribute(eventName, 'return;')
	        isSupported = typeof this.$element[eventName] === 'function'
	      }
	      return isSupported
	    }
	
	  , move: function (e) {
	      if (!this.shown) return
	
	      switch(e.keyCode) {
	        case 9: // tab
	        case 13: // enter
	        case 27: // escape
	          e.preventDefault()
	          break
	
	        case 38: // up arrow
	          e.preventDefault()
	          this.prev()
	          break
	
	        case 40: // down arrow
	          e.preventDefault()
	          this.next()
	          break
	      }
	
	      e.stopPropagation()
	    }
	
	  , keydown: function (e) {
	      this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40,38,9,13,27])
	      this.move(e)
	    }
	
	  , keypress: function (e) {
	      if (this.suppressKeyPressRepeat) return
	      this.move(e)
	    }
	
	  , keyup: function (e) {
	      switch(e.keyCode) {
	        case 40: // down arrow
	        case 38: // up arrow
	        case 16: // shift
	        case 17: // ctrl
	        case 18: // alt
	          break
	
	        case 9: // tab
	        case 13: // enter
	          if (!this.shown) return
	          this.select()
	          break
	
	        case 27: // escape
	          if (!this.shown) return
	          this.hide()
	          break
	
	        default:
	          this.lookup()
	      }
	
	      e.stopPropagation()
	      e.preventDefault()
	  }
	
	  , focus: function (e) {
	      this.focused = true
	    }
	
	  , blur: function (e) {
	      this.focused = false
	      if (!this.mousedover && this.shown) this.hide()
	    }
	
	  , click: function (e) {
	      e.stopPropagation()
	      e.preventDefault()
	      this.select()
	      this.$element.focus()
	    }
	
	  , mouseenter: function (e) {
	      this.mousedover = true
	      this.$menu.find('.active').removeClass('active')
	      $(e.currentTarget).addClass('active')
	    }
	
	  , mouseleave: function (e) {
	      this.mousedover = false
	      if (!this.focused && this.shown) this.hide()
	    }
	
	  }
	
	
	  /* TYPEAHEAD PLUGIN DEFINITION
	   * =========================== */
	
	  var old = $.fn.typeahead
	
	  $.fn.typeahead = function (option) {
	    return this.each(function () {
	      var $this = $(this)
	        , data = $this.data('typeahead')
	        , options = typeof option == 'object' && option
	      if (!data) $this.data('typeahead', (data = new Typeahead(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  $.fn.typeahead.defaults = {
	    source: []
	  , items: 8
	  , menu: '<ul class="typeahead dropdown-menu"></ul>'
	  , item: '<li><a href="#"></a></li>'
	  , minLength: 1
	  }
	
	  $.fn.typeahead.Constructor = Typeahead
	
	
	 /* TYPEAHEAD NO CONFLICT
	  * =================== */
	
	  $.fn.typeahead.noConflict = function () {
	    $.fn.typeahead = old
	    return this
	  }
	
	
	 /* TYPEAHEAD DATA-API
	  * ================== */
	
	  $(document).on('focus.typeahead.data-api', '[data-provide="typeahead"]', function (e) {
	    var $this = $(this)
	    if ($this.data('typeahead')) return
	    $this.typeahead($this.data())
	  })
	
	}(window.jQuery);


/***/ }),
/* 53 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ })
/******/ ]);
//# sourceMappingURL=bundle.js.map